// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: control.proto
// Original file comments:
// Created by Gwanwoo Kim on 2021-05-28.
// Copyright 2021 Neuromeka Inc. All rights reserved.
//
#ifndef GRPC_control_2eproto__INCLUDED
#define GRPC_control_2eproto__INCLUDED

#include "control.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class CompletionQueue;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc

namespace IndyFramework {
namespace Protobuf {
namespace Control {

class Control final {
 public:
  static constexpr char const* service_full_name() {
    return "IndyFramework.Protobuf.Control.Control";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Default Motion
    virtual ::grpc::Status AMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJReq& request, ::IndyFramework::Protobuf::Control::AMoveJRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveJRes>> AsyncAMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveJRes>>(AsyncAMoveJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveJRes>> PrepareAsyncAMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveJRes>>(PrepareAsyncAMoveJRaw(context, request, cq));
    }
    virtual ::grpc::Status AMoveJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJTReq& request, ::IndyFramework::Protobuf::Control::AMoveJTRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveJTRes>> AsyncAMoveJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveJTRes>>(AsyncAMoveJTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveJTRes>> PrepareAsyncAMoveJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveJTRes>>(PrepareAsyncAMoveJTRaw(context, request, cq));
    }
    virtual ::grpc::Status AMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLReq& request, ::IndyFramework::Protobuf::Control::AMoveLRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveLRes>> AsyncAMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveLRes>>(AsyncAMoveLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveLRes>> PrepareAsyncAMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveLRes>>(PrepareAsyncAMoveLRaw(context, request, cq));
    }
    virtual ::grpc::Status AMoveLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLTReq& request, ::IndyFramework::Protobuf::Control::AMoveLTRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveLTRes>> AsyncAMoveLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveLTRes>>(AsyncAMoveLTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveLTRes>> PrepareAsyncAMoveLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveLTRes>>(PrepareAsyncAMoveLTRaw(context, request, cq));
    }
    virtual ::grpc::Status AMoveC(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCReq& request, ::IndyFramework::Protobuf::Control::AMoveCRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveCRes>> AsyncAMoveC(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveCRes>>(AsyncAMoveCRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveCRes>> PrepareAsyncAMoveC(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveCRes>>(PrepareAsyncAMoveCRaw(context, request, cq));
    }
    virtual ::grpc::Status AMoveCT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCTReq& request, ::IndyFramework::Protobuf::Control::AMoveCTRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveCTRes>> AsyncAMoveCT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveCTRes>>(AsyncAMoveCTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveCTRes>> PrepareAsyncAMoveCT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveCTRes>>(PrepareAsyncAMoveCTRaw(context, request, cq));
    }
    virtual ::grpc::Status AWaitIO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitIOReq& request, ::IndyFramework::Protobuf::Control::AWaitIORes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitIORes>> AsyncAWaitIO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitIOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitIORes>>(AsyncAWaitIORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitIORes>> PrepareAsyncAWaitIO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitIOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitIORes>>(PrepareAsyncAWaitIORaw(context, request, cq));
    }
    virtual ::grpc::Status AWaitTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTimeReq& request, ::IndyFramework::Protobuf::Control::AWaitTimeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitTimeRes>> AsyncAWaitTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitTimeRes>>(AsyncAWaitTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitTimeRes>> PrepareAsyncAWaitTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitTimeRes>>(PrepareAsyncAWaitTimeRaw(context, request, cq));
    }
    virtual ::grpc::Status AWaitProgress(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitProgressReq& request, ::IndyFramework::Protobuf::Control::AWaitProgressRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitProgressRes>> AsyncAWaitProgress(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitProgressReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitProgressRes>>(AsyncAWaitProgressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitProgressRes>> PrepareAsyncAWaitProgress(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitProgressReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitProgressRes>>(PrepareAsyncAWaitProgressRaw(context, request, cq));
    }
    virtual ::grpc::Status AWaitTraj(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTrajReq& request, ::IndyFramework::Protobuf::Control::AWaitTrajRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitTrajRes>> AsyncAWaitTraj(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTrajReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitTrajRes>>(AsyncAWaitTrajRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitTrajRes>> PrepareAsyncAWaitTraj(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTrajReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitTrajRes>>(PrepareAsyncAWaitTrajRaw(context, request, cq));
    }
    virtual ::grpc::Status AWaitRadius(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq& request, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitRadiusRes>> AsyncAWaitRadius(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitRadiusRes>>(AsyncAWaitRadiusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitRadiusRes>> PrepareAsyncAWaitRadius(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitRadiusRes>>(PrepareAsyncAWaitRadiusRaw(context, request, cq));
    }
    virtual ::grpc::Status AMotionStop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMotionStopReq& request, ::IndyFramework::Protobuf::Control::AMotionStopRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMotionStopRes>> AsyncAMotionStop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMotionStopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMotionStopRes>>(AsyncAMotionStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMotionStopRes>> PrepareAsyncAMotionStop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMotionStopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMotionStopRes>>(PrepareAsyncAMotionStopRaw(context, request, cq));
    }
    // Advanced Motion
    virtual ::grpc::Status MoveSJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJReq& request, ::IndyFramework::Protobuf::Control::MoveSJRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSJRes>> AsyncMoveSJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSJRes>>(AsyncMoveSJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSJRes>> PrepareAsyncMoveSJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSJRes>>(PrepareAsyncMoveSJRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveSJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJTReq& request, ::IndyFramework::Protobuf::Control::MoveSJTRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSJTRes>> AsyncMoveSJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSJTRes>>(AsyncMoveSJTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSJTRes>> PrepareAsyncMoveSJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSJTRes>>(PrepareAsyncMoveSJTRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveSL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLReq& request, ::IndyFramework::Protobuf::Control::MoveSLRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSLRes>> AsyncMoveSL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSLRes>>(AsyncMoveSLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSLRes>> PrepareAsyncMoveSL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSLRes>>(PrepareAsyncMoveSLRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveSLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLTReq& request, ::IndyFramework::Protobuf::Control::MoveSLTRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSLTRes>> AsyncMoveSLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSLTRes>>(AsyncMoveSLTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSLTRes>> PrepareAsyncMoveSLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSLTRes>>(PrepareAsyncMoveSLTRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveSpiral(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSpiralReq& request, ::IndyFramework::Protobuf::Control::MoveSpiralRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSpiralRes>> AsyncMoveSpiral(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSpiralReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSpiralRes>>(AsyncMoveSpiralRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSpiralRes>> PrepareAsyncMoveSpiral(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSpiralReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSpiralRes>>(PrepareAsyncMoveSpiralRaw(context, request, cq));
    }
    // Motion Config
    virtual ::grpc::Status SetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFrameReq& request, ::IndyFramework::Protobuf::Control::SetRefFrameRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetRefFrameRes>> AsyncSetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetRefFrameRes>>(AsyncSetRefFrameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetRefFrameRes>> PrepareAsyncSetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetRefFrameRes>>(PrepareAsyncSetRefFrameRaw(context, request, cq));
    }
    virtual ::grpc::Status SetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq& request, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>> AsyncSetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>>(AsyncSetRefFramePlanarRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>> PrepareAsyncSetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>>(PrepareAsyncSetRefFramePlanarRaw(context, request, cq));
    }
    virtual ::grpc::Status SetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolFrameReq& request, ::IndyFramework::Protobuf::Control::SetToolFrameRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetToolFrameRes>> AsyncSetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetToolFrameRes>>(AsyncSetToolFrameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetToolFrameRes>> PrepareAsyncSetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetToolFrameRes>>(PrepareAsyncSetToolFrameRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq& request, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>> AsyncSetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>>(AsyncSetSpeedRatioRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>> PrepareAsyncSetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>>(PrepareAsyncSetSpeedRatioRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCommandSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq& request, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>> AsyncSetCommandSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>>(AsyncSetCommandSpeedRatioRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>> PrepareAsyncSetCommandSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>>(PrepareAsyncSetCommandSpeedRatioRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Command
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status Reboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RebootReq& request, ::IndyFramework::Protobuf::Control::RebootRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::RebootRes>> AsyncReboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RebootReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::RebootRes>>(AsyncRebootRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::RebootRes>> PrepareAsyncReboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RebootReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::RebootRes>>(PrepareAsyncRebootRaw(context, request, cq));
    }
    virtual ::grpc::Status Recover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RecoverReq& request, ::IndyFramework::Protobuf::Control::RecoverRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::RecoverRes>> AsyncRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RecoverReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::RecoverRes>>(AsyncRecoverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::RecoverRes>> PrepareAsyncRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RecoverReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::RecoverRes>>(PrepareAsyncRecoverRaw(context, request, cq));
    }
    virtual ::grpc::Status Stop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::StopReq& request, ::IndyFramework::Protobuf::Control::StopRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::StopRes>> AsyncStop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::StopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::StopRes>>(AsyncStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::StopRes>> PrepareAsyncStop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::StopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::StopRes>>(PrepareAsyncStopRaw(context, request, cq));
    }
    virtual ::grpc::Status Pause(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::PauseReq& request, ::IndyFramework::Protobuf::Control::PauseRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::PauseRes>> AsyncPause(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::PauseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::PauseRes>>(AsyncPauseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::PauseRes>> PrepareAsyncPause(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::PauseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::PauseRes>>(PrepareAsyncPauseRaw(context, request, cq));
    }
    virtual ::grpc::Status Resume(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ResumeReq& request, ::IndyFramework::Protobuf::Control::ResumeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::ResumeRes>> AsyncResume(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ResumeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::ResumeRes>>(AsyncResumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::ResumeRes>> PrepareAsyncResume(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ResumeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::ResumeRes>>(PrepareAsyncResumeRaw(context, request, cq));
    }
    virtual ::grpc::Status Brake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::BrakeReq& request, ::IndyFramework::Protobuf::Control::BrakeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::BrakeRes>> AsyncBrake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::BrakeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::BrakeRes>>(AsyncBrakeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::BrakeRes>> PrepareAsyncBrake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::BrakeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::BrakeRes>>(PrepareAsyncBrakeRaw(context, request, cq));
    }
    virtual ::grpc::Status Servo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ServoReq& request, ::IndyFramework::Protobuf::Control::ServoRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::ServoRes>> AsyncServo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ServoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::ServoRes>>(AsyncServoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::ServoRes>> PrepareAsyncServo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ServoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::ServoRes>>(PrepareAsyncServoRaw(context, request, cq));
    }
    virtual ::grpc::Status SetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq& request, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>> AsyncSetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>>(AsyncSetAutoServoOffRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>> PrepareAsyncSetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>>(PrepareAsyncSetAutoServoOffRaw(context, request, cq));
    }
    virtual ::grpc::Status GetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq& request, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>> AsyncGetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>>(AsyncGetAutoServoOffRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>> PrepareAsyncGetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>>(PrepareAsyncGetAutoServoOffRaw(context, request, cq));
    }
    virtual ::grpc::Status SimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SimulationModeReq& request, ::IndyFramework::Protobuf::Control::SimulationModeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SimulationModeRes>> AsyncSimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SimulationModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SimulationModeRes>>(AsyncSimulationModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SimulationModeRes>> PrepareAsyncSimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SimulationModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SimulationModeRes>>(PrepareAsyncSimulationModeRaw(context, request, cq));
    }
    virtual ::grpc::Status DirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq& request, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>> AsyncDirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>>(AsyncDirectTeachingModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>> PrepareAsyncDirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>>(PrepareAsyncDirectTeachingModeRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Data
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status GetRTControlData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq& request, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetRTControlDataRes>> AsyncGetRTControlData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetRTControlDataRes>>(AsyncGetRTControlDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetRTControlDataRes>> PrepareAsyncGetRTControlData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetRTControlDataRes>>(PrepareAsyncGetRTControlDataRaw(context, request, cq));
    }
    virtual ::grpc::Status GetIOData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetIODataReq& request, ::IndyFramework::Protobuf::Control::GetIODataRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetIODataRes>> AsyncGetIOData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetIODataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetIODataRes>>(AsyncGetIODataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetIODataRes>> PrepareAsyncGetIOData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetIODataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetIODataRes>>(PrepareAsyncGetIODataRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCoreData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCoreDataReq& request, ::IndyFramework::Protobuf::Control::GetCoreDataRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCoreDataRes>> AsyncGetCoreData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCoreDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCoreDataRes>>(AsyncGetCoreDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCoreDataRes>> PrepareAsyncGetCoreData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCoreDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCoreDataRes>>(PrepareAsyncGetCoreDataRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSystemInfoData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq& request, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>> AsyncGetSystemInfoData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>>(AsyncGetSystemInfoDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>> PrepareAsyncGetSystemInfoData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>>(PrepareAsyncGetSystemInfoDataRaw(context, request, cq));
    }
    virtual ::grpc::Status GetMotionData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMotionDataReq& request, ::IndyFramework::Protobuf::Control::GetMotionDataRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetMotionDataRes>> AsyncGetMotionData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMotionDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetMotionDataRes>>(AsyncGetMotionDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetMotionDataRes>> PrepareAsyncGetMotionData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMotionDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetMotionDataRes>>(PrepareAsyncGetMotionDataRaw(context, request, cq));
    }
    virtual ::grpc::Status GetStateData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetStateDataReq& request, ::IndyFramework::Protobuf::Control::GetStateDataRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetStateDataRes>> AsyncGetStateData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetStateDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetStateDataRes>>(AsyncGetStateDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetStateDataRes>> PrepareAsyncGetStateData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetStateDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetStateDataRes>>(PrepareAsyncGetStateDataRaw(context, request, cq));
    }
    virtual ::grpc::Status GetViolationData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetViolationDataReq& request, ::IndyFramework::Protobuf::Control::GetViolationDataRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetViolationDataRes>> AsyncGetViolationData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetViolationDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetViolationDataRes>>(AsyncGetViolationDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetViolationDataRes>> PrepareAsyncGetViolationData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetViolationDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetViolationDataRes>>(PrepareAsyncGetViolationDataRaw(context, request, cq));
    }
    virtual ::grpc::Status SetProgramState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetProgramStateReq& request, ::IndyFramework::Protobuf::Control::SetProgramStateRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetProgramStateRes>> AsyncSetProgramState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetProgramStateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetProgramStateRes>>(AsyncSetProgramStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetProgramStateRes>> PrepareAsyncSetProgramState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetProgramStateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetProgramStateRes>>(PrepareAsyncSetProgramStateRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Utility
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status InverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq& request, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::InverseKinematicsRes>> AsyncInverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::InverseKinematicsRes>>(AsyncInverseKinematicsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::InverseKinematicsRes>> PrepareAsyncInverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::InverseKinematicsRes>>(PrepareAsyncInverseKinematicsRaw(context, request, cq));
    }
    virtual ::grpc::Status CheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq& request, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>> AsyncCheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>>(AsyncCheckAproachRetractValidRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>> PrepareAsyncCheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>>(PrepareAsyncCheckAproachRetractValidRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq& request, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetPalletPointListRes>> AsyncGetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetPalletPointListRes>>(AsyncGetPalletPointListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetPalletPointListRes>> PrepareAsyncGetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetPalletPointListRes>>(PrepareAsyncGetPalletPointListRaw(context, request, cq));
    }
    virtual ::grpc::Status CalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq& request, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>> AsyncCalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>>(AsyncCalculateRelativePoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>> PrepareAsyncCalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>>(PrepareAsyncCalculateRelativePoseRaw(context, request, cq));
    }
    virtual ::grpc::Status CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq& request, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>> AsyncCalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>>(AsyncCalculateCurrentPoseRelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>> PrepareAsyncCalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>>(PrepareAsyncCalculateCurrentPoseRelRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // DIO
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status GetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDIReq& request, ::IndyFramework::Protobuf::Control::GetDIRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetDIRes>> AsyncGetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetDIRes>>(AsyncGetDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetDIRes>> PrepareAsyncGetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetDIRes>>(PrepareAsyncGetDIRaw(context, request, cq));
    }
    virtual ::grpc::Status SetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDIReq& request, ::IndyFramework::Protobuf::Control::SetDIRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetDIRes>> AsyncSetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetDIRes>>(AsyncSetDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetDIRes>> PrepareAsyncSetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetDIRes>>(PrepareAsyncSetDIRaw(context, request, cq));
    }
    virtual ::grpc::Status SetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDOReq& request, ::IndyFramework::Protobuf::Control::SetDORes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetDORes>> AsyncSetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetDORes>>(AsyncSetDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetDORes>> PrepareAsyncSetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetDORes>>(PrepareAsyncSetDORaw(context, request, cq));
    }
    virtual ::grpc::Status GetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDOReq& request, ::IndyFramework::Protobuf::Control::GetDORes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetDORes>> AsyncGetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetDORes>>(AsyncGetDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetDORes>> PrepareAsyncGetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetDORes>>(PrepareAsyncGetDORaw(context, request, cq));
    }
    virtual ::grpc::Status GetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAIReq& request, ::IndyFramework::Protobuf::Control::GetAIRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAIRes>> AsyncGetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAIRes>>(AsyncGetAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAIRes>> PrepareAsyncGetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAIRes>>(PrepareAsyncGetAIRaw(context, request, cq));
    }
    virtual ::grpc::Status SetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAIReq& request, ::IndyFramework::Protobuf::Control::SetAIRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAIRes>> AsyncSetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAIRes>>(AsyncSetAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAIRes>> PrepareAsyncSetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAIRes>>(PrepareAsyncSetAIRaw(context, request, cq));
    }
    virtual ::grpc::Status GetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAOReq& request, ::IndyFramework::Protobuf::Control::GetAORes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAORes>> AsyncGetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAORes>>(AsyncGetAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAORes>> PrepareAsyncGetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAORes>>(PrepareAsyncGetAORaw(context, request, cq));
    }
    virtual ::grpc::Status SetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAOReq& request, ::IndyFramework::Protobuf::Control::SetAORes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAORes>> AsyncSetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAORes>>(AsyncSetAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAORes>> PrepareAsyncSetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAORes>>(PrepareAsyncSetAORaw(context, request, cq));
    }
    virtual ::grpc::Status GetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDIReq& request, ::IndyFramework::Protobuf::Control::GetEndDIRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndDIRes>> AsyncGetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndDIRes>>(AsyncGetEndDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndDIRes>> PrepareAsyncGetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndDIRes>>(PrepareAsyncGetEndDIRaw(context, request, cq));
    }
    virtual ::grpc::Status SetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDIReq& request, ::IndyFramework::Protobuf::Control::SetEndDIRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndDIRes>> AsyncSetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndDIRes>>(AsyncSetEndDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndDIRes>> PrepareAsyncSetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndDIRes>>(PrepareAsyncSetEndDIRaw(context, request, cq));
    }
    virtual ::grpc::Status SetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDOReq& request, ::IndyFramework::Protobuf::Control::SetEndDORes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndDORes>> AsyncSetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndDORes>>(AsyncSetEndDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndDORes>> PrepareAsyncSetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndDORes>>(PrepareAsyncSetEndDORaw(context, request, cq));
    }
    virtual ::grpc::Status GetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDOReq& request, ::IndyFramework::Protobuf::Control::GetEndDORes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndDORes>> AsyncGetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndDORes>>(AsyncGetEndDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndDORes>> PrepareAsyncGetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndDORes>>(PrepareAsyncGetEndDORaw(context, request, cq));
    }
    virtual ::grpc::Status GetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAIReq& request, ::IndyFramework::Protobuf::Control::GetEndAIRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndAIRes>> AsyncGetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndAIRes>>(AsyncGetEndAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndAIRes>> PrepareAsyncGetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndAIRes>>(PrepareAsyncGetEndAIRaw(context, request, cq));
    }
    virtual ::grpc::Status SetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAIReq& request, ::IndyFramework::Protobuf::Control::SetEndAIRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndAIRes>> AsyncSetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndAIRes>>(AsyncSetEndAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndAIRes>> PrepareAsyncSetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndAIRes>>(PrepareAsyncSetEndAIRaw(context, request, cq));
    }
    virtual ::grpc::Status GetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAOReq& request, ::IndyFramework::Protobuf::Control::GetEndAORes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndAORes>> AsyncGetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndAORes>>(AsyncGetEndAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndAORes>> PrepareAsyncGetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndAORes>>(PrepareAsyncGetEndAORaw(context, request, cq));
    }
    virtual ::grpc::Status SetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAOReq& request, ::IndyFramework::Protobuf::Control::SetEndAORes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndAORes>> AsyncSetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndAORes>>(AsyncSetEndAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndAORes>> PrepareAsyncSetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndAORes>>(PrepareAsyncSetEndAORaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Config Setting
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq& request, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetJointControlGainRes>> AsyncSetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetJointControlGainRes>>(AsyncSetJointControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetJointControlGainRes>> PrepareAsyncSetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetJointControlGainRes>>(PrepareAsyncSetJointControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status GetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq& request, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetJointControlGainRes>> AsyncGetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetJointControlGainRes>>(AsyncGetJointControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetJointControlGainRes>> PrepareAsyncGetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetJointControlGainRes>>(PrepareAsyncGetJointControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status SetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq& request, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>> AsyncSetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>>(AsyncSetTaskControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>> PrepareAsyncSetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>>(PrepareAsyncSetTaskControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq& request, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>> AsyncGetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>>(AsyncGetTaskControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>> PrepareAsyncGetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>>(PrepareAsyncGetTaskControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status SetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq& request, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>> AsyncSetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>>(AsyncSetImpedanceControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>> PrepareAsyncSetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>>(PrepareAsyncSetImpedanceControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status GetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq& request, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>> AsyncGetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>>(AsyncGetImpedanceControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>> PrepareAsyncGetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>>(PrepareAsyncGetImpedanceControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status SetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetFricCompReq& request, ::IndyFramework::Protobuf::Control::SetFricCompRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetFricCompRes>> AsyncSetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetFricCompRes>>(AsyncSetFricCompRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetFricCompRes>> PrepareAsyncSetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetFricCompRes>>(PrepareAsyncSetFricCompRaw(context, request, cq));
    }
    virtual ::grpc::Status GetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetFricCompReq& request, ::IndyFramework::Protobuf::Control::GetFricCompRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetFricCompRes>> AsyncGetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetFricCompRes>>(AsyncGetFricCompRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetFricCompRes>> PrepareAsyncGetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetFricCompRes>>(PrepareAsyncGetFricCompRaw(context, request, cq));
    }
    virtual ::grpc::Status SetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetMountPosReq& request, ::IndyFramework::Protobuf::Control::SetMountPosRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetMountPosRes>> AsyncSetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetMountPosRes>>(AsyncSetMountPosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetMountPosRes>> PrepareAsyncSetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetMountPosRes>>(PrepareAsyncSetMountPosRaw(context, request, cq));
    }
    virtual ::grpc::Status GetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMountPosReq& request, ::IndyFramework::Protobuf::Control::GetMountPosRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetMountPosRes>> AsyncGetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetMountPosRes>>(AsyncGetMountPosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetMountPosRes>> PrepareAsyncGetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetMountPosRes>>(PrepareAsyncGetMountPosRaw(context, request, cq));
    }
    virtual ::grpc::Status SetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq& request, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetToolPropertyRes>> AsyncSetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetToolPropertyRes>>(AsyncSetToolPropertyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetToolPropertyRes>> PrepareAsyncSetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetToolPropertyRes>>(PrepareAsyncSetToolPropertyRaw(context, request, cq));
    }
    virtual ::grpc::Status GetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq& request, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetToolPropertyRes>> AsyncGetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetToolPropertyRes>>(AsyncGetToolPropertyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetToolPropertyRes>> PrepareAsyncGetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetToolPropertyRes>>(PrepareAsyncGetToolPropertyRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq& request, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>> AsyncSetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>>(AsyncSetCollSensLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>> PrepareAsyncSetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>>(PrepareAsyncSetCollSensLevelRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq& request, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>> AsyncGetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>>(AsyncGetCollSensLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>> PrepareAsyncGetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>>(PrepareAsyncGetCollSensLevelRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq& request, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollSensParamRes>> AsyncSetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollSensParamRes>>(AsyncSetCollSensParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollSensParamRes>> PrepareAsyncSetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollSensParamRes>>(PrepareAsyncSetCollSensParamRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq& request, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollSensParamRes>> AsyncGetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollSensParamRes>>(AsyncGetCollSensParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollSensParamRes>> PrepareAsyncGetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollSensParamRes>>(PrepareAsyncGetCollSensParamRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq& request, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollPolicyRes>> AsyncSetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollPolicyRes>>(AsyncSetCollPolicyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollPolicyRes>> PrepareAsyncSetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollPolicyRes>>(PrepareAsyncSetCollPolicyRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq& request, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollPolicyRes>> AsyncGetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollPolicyRes>>(AsyncGetCollPolicyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollPolicyRes>> PrepareAsyncGetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollPolicyRes>>(PrepareAsyncGetCollPolicyRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCollTuningParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq& request, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>> AsyncGetCollTuningParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>>(AsyncGetCollTuningParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>> PrepareAsyncGetCollTuningParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>>(PrepareAsyncGetCollTuningParamRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq& request, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>> AsyncGetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>>(AsyncGetSafetyLimitConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>> PrepareAsyncGetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>>(PrepareAsyncGetSafetyLimitConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq& request, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>> AsyncSetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>>(AsyncSetSafetyLimitConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>> PrepareAsyncSetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>>(PrepareAsyncSetSafetyLimitConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq& request, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>> AsyncGetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>>(AsyncGetSafetyStopConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>> PrepareAsyncGetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>>(PrepareAsyncGetSafetyStopConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq& request, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>> AsyncSetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>>(AsyncSetSafetyStopConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>> PrepareAsyncSetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>>(PrepareAsyncSetSafetyStopConfigRaw(context, request, cq));
    }
    // beckhoff_conv
    virtual ::grpc::Status GetEL5001(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5001Req& request, ::IndyFramework::Protobuf::Control::GetEL5001Res* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEL5001Res>> AsyncGetEL5001(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5001Req& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEL5001Res>>(AsyncGetEL5001Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEL5001Res>> PrepareAsyncGetEL5001(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5001Req& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEL5001Res>>(PrepareAsyncGetEL5001Raw(context, request, cq));
    }
    virtual ::grpc::Status GetEL5101(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5101Req& request, ::IndyFramework::Protobuf::Control::GetEL5101Res* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEL5101Res>> AsyncGetEL5101(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5101Req& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEL5101Res>>(AsyncGetEL5101Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEL5101Res>> PrepareAsyncGetEL5101(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5101Req& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEL5101Res>>(PrepareAsyncGetEL5101Raw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Default Motion
      virtual void AMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJReq* request, ::IndyFramework::Protobuf::Control::AMoveJRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AMoveJ(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveJRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJReq* request, ::IndyFramework::Protobuf::Control::AMoveJRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AMoveJ(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveJRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AMoveJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJTReq* request, ::IndyFramework::Protobuf::Control::AMoveJTRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AMoveJT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveJTRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AMoveJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJTReq* request, ::IndyFramework::Protobuf::Control::AMoveJTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AMoveJT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveJTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLReq* request, ::IndyFramework::Protobuf::Control::AMoveLRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AMoveL(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveLRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLReq* request, ::IndyFramework::Protobuf::Control::AMoveLRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AMoveL(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveLRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AMoveLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLTReq* request, ::IndyFramework::Protobuf::Control::AMoveLTRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AMoveLT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveLTRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AMoveLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLTReq* request, ::IndyFramework::Protobuf::Control::AMoveLTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AMoveLT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveLTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AMoveC(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCReq* request, ::IndyFramework::Protobuf::Control::AMoveCRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AMoveC(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveCRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AMoveC(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCReq* request, ::IndyFramework::Protobuf::Control::AMoveCRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AMoveC(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveCRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AMoveCT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCTReq* request, ::IndyFramework::Protobuf::Control::AMoveCTRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AMoveCT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveCTRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AMoveCT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCTReq* request, ::IndyFramework::Protobuf::Control::AMoveCTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AMoveCT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveCTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AWaitIO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitIOReq* request, ::IndyFramework::Protobuf::Control::AWaitIORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AWaitIO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitIORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AWaitIO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitIOReq* request, ::IndyFramework::Protobuf::Control::AWaitIORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AWaitIO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitIORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AWaitTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTimeReq* request, ::IndyFramework::Protobuf::Control::AWaitTimeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AWaitTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitTimeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AWaitTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTimeReq* request, ::IndyFramework::Protobuf::Control::AWaitTimeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AWaitTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitTimeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AWaitProgress(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitProgressReq* request, ::IndyFramework::Protobuf::Control::AWaitProgressRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AWaitProgress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitProgressRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AWaitProgress(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitProgressReq* request, ::IndyFramework::Protobuf::Control::AWaitProgressRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AWaitProgress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitProgressRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AWaitTraj(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTrajReq* request, ::IndyFramework::Protobuf::Control::AWaitTrajRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AWaitTraj(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitTrajRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AWaitTraj(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTrajReq* request, ::IndyFramework::Protobuf::Control::AWaitTrajRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AWaitTraj(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitTrajRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AWaitRadius(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq* request, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AWaitRadius(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AWaitRadius(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq* request, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AWaitRadius(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AMotionStop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMotionStopReq* request, ::IndyFramework::Protobuf::Control::AMotionStopRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AMotionStop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMotionStopRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AMotionStop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMotionStopReq* request, ::IndyFramework::Protobuf::Control::AMotionStopRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AMotionStop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMotionStopRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Advanced Motion
      virtual void MoveSJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJReq* request, ::IndyFramework::Protobuf::Control::MoveSJRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveSJ(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSJRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveSJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJReq* request, ::IndyFramework::Protobuf::Control::MoveSJRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void MoveSJ(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSJRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void MoveSJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJTReq* request, ::IndyFramework::Protobuf::Control::MoveSJTRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveSJT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSJTRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveSJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJTReq* request, ::IndyFramework::Protobuf::Control::MoveSJTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void MoveSJT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSJTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void MoveSL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLReq* request, ::IndyFramework::Protobuf::Control::MoveSLRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveSL(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSLRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveSL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLReq* request, ::IndyFramework::Protobuf::Control::MoveSLRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void MoveSL(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSLRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void MoveSLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLTReq* request, ::IndyFramework::Protobuf::Control::MoveSLTRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveSLT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSLTRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveSLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLTReq* request, ::IndyFramework::Protobuf::Control::MoveSLTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void MoveSLT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSLTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void MoveSpiral(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSpiralReq* request, ::IndyFramework::Protobuf::Control::MoveSpiralRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveSpiral(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSpiralRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveSpiral(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSpiralReq* request, ::IndyFramework::Protobuf::Control::MoveSpiralRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void MoveSpiral(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSpiralRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Motion Config
      virtual void SetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFrameReq* request, ::IndyFramework::Protobuf::Control::SetRefFrameRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRefFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetRefFrameRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFrameReq* request, ::IndyFramework::Protobuf::Control::SetRefFrameRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetRefFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetRefFrameRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq* request, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRefFramePlanar(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq* request, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetRefFramePlanar(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolFrameReq* request, ::IndyFramework::Protobuf::Control::SetToolFrameRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetToolFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetToolFrameRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolFrameReq* request, ::IndyFramework::Protobuf::Control::SetToolFrameRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetToolFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetToolFrameRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq* request, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSpeedRatio(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq* request, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetSpeedRatio(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetCommandSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq* request, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCommandSpeedRatio(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCommandSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq* request, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetCommandSpeedRatio(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Command
      // ---------------------------------------------------------------- //
      virtual void Reboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RebootReq* request, ::IndyFramework::Protobuf::Control::RebootRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Reboot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::RebootRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Reboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RebootReq* request, ::IndyFramework::Protobuf::Control::RebootRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Reboot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::RebootRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Recover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RecoverReq* request, ::IndyFramework::Protobuf::Control::RecoverRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Recover(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::RecoverRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Recover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RecoverReq* request, ::IndyFramework::Protobuf::Control::RecoverRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Recover(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::RecoverRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Stop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::StopReq* request, ::IndyFramework::Protobuf::Control::StopRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::StopRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Stop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::StopReq* request, ::IndyFramework::Protobuf::Control::StopRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::StopRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Pause(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::PauseReq* request, ::IndyFramework::Protobuf::Control::PauseRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Pause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::PauseRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Pause(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::PauseReq* request, ::IndyFramework::Protobuf::Control::PauseRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Pause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::PauseRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Resume(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ResumeReq* request, ::IndyFramework::Protobuf::Control::ResumeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Resume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::ResumeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Resume(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ResumeReq* request, ::IndyFramework::Protobuf::Control::ResumeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Resume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::ResumeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Brake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::BrakeReq* request, ::IndyFramework::Protobuf::Control::BrakeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Brake(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::BrakeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Brake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::BrakeReq* request, ::IndyFramework::Protobuf::Control::BrakeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Brake(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::BrakeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Servo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ServoReq* request, ::IndyFramework::Protobuf::Control::ServoRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Servo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::ServoRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Servo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ServoReq* request, ::IndyFramework::Protobuf::Control::ServoRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Servo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::ServoRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq* request, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAutoServoOff(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq* request, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetAutoServoOff(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq* request, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAutoServoOff(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq* request, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAutoServoOff(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SimulationModeReq* request, ::IndyFramework::Protobuf::Control::SimulationModeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SimulationMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SimulationModeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SimulationModeReq* request, ::IndyFramework::Protobuf::Control::SimulationModeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SimulationMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SimulationModeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq* request, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DirectTeachingMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq* request, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DirectTeachingMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Data
      // ---------------------------------------------------------------- //
      virtual void GetRTControlData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq* request, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRTControlData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRTControlData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq* request, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetRTControlData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetIOData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetIODataReq* request, ::IndyFramework::Protobuf::Control::GetIODataRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIOData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetIODataRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIOData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetIODataReq* request, ::IndyFramework::Protobuf::Control::GetIODataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetIOData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetIODataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetCoreData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCoreDataReq* request, ::IndyFramework::Protobuf::Control::GetCoreDataRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCoreData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCoreDataRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCoreData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCoreDataReq* request, ::IndyFramework::Protobuf::Control::GetCoreDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetCoreData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCoreDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetSystemInfoData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq* request, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSystemInfoData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSystemInfoData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq* request, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetSystemInfoData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMotionData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMotionDataReq* request, ::IndyFramework::Protobuf::Control::GetMotionDataRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMotionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetMotionDataRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMotionData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMotionDataReq* request, ::IndyFramework::Protobuf::Control::GetMotionDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMotionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetMotionDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetStateData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetStateDataReq* request, ::IndyFramework::Protobuf::Control::GetStateDataRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetStateData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetStateDataRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetStateData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetStateDataReq* request, ::IndyFramework::Protobuf::Control::GetStateDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetStateData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetStateDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetViolationData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetViolationDataReq* request, ::IndyFramework::Protobuf::Control::GetViolationDataRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetViolationData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetViolationDataRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetViolationData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetViolationDataReq* request, ::IndyFramework::Protobuf::Control::GetViolationDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetViolationData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetViolationDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetProgramState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetProgramStateReq* request, ::IndyFramework::Protobuf::Control::SetProgramStateRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetProgramState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetProgramStateRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetProgramState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetProgramStateReq* request, ::IndyFramework::Protobuf::Control::SetProgramStateRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetProgramState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetProgramStateRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Utility
      // ---------------------------------------------------------------- //
      virtual void InverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq* request, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void InverseKinematics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void InverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq* request, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void InverseKinematics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq* request, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckAproachRetractValid(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq* request, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CheckAproachRetractValid(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq* request, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPalletPointList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq* request, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetPalletPointList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq* request, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CalculateRelativePose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq* request, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CalculateRelativePose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq* request, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq* request, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // DIO
      // ---------------------------------------------------------------- //
      virtual void GetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDIReq* request, ::IndyFramework::Protobuf::Control::GetDIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetDIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDIReq* request, ::IndyFramework::Protobuf::Control::GetDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDIReq* request, ::IndyFramework::Protobuf::Control::SetDIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetDIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDIReq* request, ::IndyFramework::Protobuf::Control::SetDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDOReq* request, ::IndyFramework::Protobuf::Control::SetDORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetDORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDOReq* request, ::IndyFramework::Protobuf::Control::SetDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDOReq* request, ::IndyFramework::Protobuf::Control::GetDORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetDORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDOReq* request, ::IndyFramework::Protobuf::Control::GetDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAIReq* request, ::IndyFramework::Protobuf::Control::GetAIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetAIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAIReq* request, ::IndyFramework::Protobuf::Control::GetAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAIReq* request, ::IndyFramework::Protobuf::Control::SetAIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetAIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAIReq* request, ::IndyFramework::Protobuf::Control::SetAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAOReq* request, ::IndyFramework::Protobuf::Control::GetAORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetAORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAOReq* request, ::IndyFramework::Protobuf::Control::GetAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAOReq* request, ::IndyFramework::Protobuf::Control::SetAORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetAORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAOReq* request, ::IndyFramework::Protobuf::Control::SetAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDIReq* request, ::IndyFramework::Protobuf::Control::GetEndDIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndDIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDIReq* request, ::IndyFramework::Protobuf::Control::GetEndDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDIReq* request, ::IndyFramework::Protobuf::Control::SetEndDIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndDIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDIReq* request, ::IndyFramework::Protobuf::Control::SetEndDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDOReq* request, ::IndyFramework::Protobuf::Control::SetEndDORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndDORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDOReq* request, ::IndyFramework::Protobuf::Control::SetEndDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDOReq* request, ::IndyFramework::Protobuf::Control::GetEndDORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndDORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDOReq* request, ::IndyFramework::Protobuf::Control::GetEndDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAIReq* request, ::IndyFramework::Protobuf::Control::GetEndAIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndAIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAIReq* request, ::IndyFramework::Protobuf::Control::GetEndAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAIReq* request, ::IndyFramework::Protobuf::Control::SetEndAIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndAIRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAIReq* request, ::IndyFramework::Protobuf::Control::SetEndAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAOReq* request, ::IndyFramework::Protobuf::Control::GetEndAORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndAORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAOReq* request, ::IndyFramework::Protobuf::Control::GetEndAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAOReq* request, ::IndyFramework::Protobuf::Control::SetEndAORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndAORes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAOReq* request, ::IndyFramework::Protobuf::Control::SetEndAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Config Setting
      // ---------------------------------------------------------------- //
      virtual void SetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq* request, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetJointControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq* request, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetJointControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq* request, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetJointControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq* request, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetJointControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq* request, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetTaskControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq* request, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetTaskControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq* request, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTaskControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq* request, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetTaskControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetImpedanceControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetImpedanceControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetImpedanceControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetImpedanceControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetFricCompReq* request, ::IndyFramework::Protobuf::Control::SetFricCompRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetFricComp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetFricCompRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetFricCompReq* request, ::IndyFramework::Protobuf::Control::SetFricCompRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetFricComp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetFricCompRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetFricCompReq* request, ::IndyFramework::Protobuf::Control::GetFricCompRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFricComp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetFricCompRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetFricCompReq* request, ::IndyFramework::Protobuf::Control::GetFricCompRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetFricComp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetFricCompRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetMountPosReq* request, ::IndyFramework::Protobuf::Control::SetMountPosRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetMountPos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetMountPosRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetMountPosReq* request, ::IndyFramework::Protobuf::Control::SetMountPosRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetMountPos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetMountPosRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMountPosReq* request, ::IndyFramework::Protobuf::Control::GetMountPosRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMountPos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetMountPosRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMountPosReq* request, ::IndyFramework::Protobuf::Control::GetMountPosRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMountPos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetMountPosRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq* request, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetToolProperty(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq* request, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetToolProperty(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq* request, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetToolProperty(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq* request, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetToolProperty(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq* request, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCollSensLevel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq* request, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetCollSensLevel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq* request, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCollSensLevel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq* request, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetCollSensLevel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq* request, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCollSensParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq* request, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetCollSensParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq* request, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCollSensParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq* request, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetCollSensParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq* request, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCollPolicy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq* request, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetCollPolicy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq* request, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCollPolicy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq* request, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetCollPolicy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetCollTuningParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq* request, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCollTuningParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCollTuningParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq* request, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetCollTuningParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSafetyLimitConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetSafetyLimitConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSafetyLimitConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetSafetyLimitConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSafetyStopConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetSafetyStopConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSafetyStopConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetSafetyStopConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // beckhoff_conv
      virtual void GetEL5001(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5001Req* request, ::IndyFramework::Protobuf::Control::GetEL5001Res* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEL5001(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEL5001Res* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEL5001(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5001Req* request, ::IndyFramework::Protobuf::Control::GetEL5001Res* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetEL5001(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEL5001Res* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetEL5101(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5101Req* request, ::IndyFramework::Protobuf::Control::GetEL5101Res* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEL5101(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEL5101Res* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEL5101(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5101Req* request, ::IndyFramework::Protobuf::Control::GetEL5101Res* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetEL5101(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEL5101Res* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveJRes>* AsyncAMoveJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveJRes>* PrepareAsyncAMoveJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveJTRes>* AsyncAMoveJTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveJTRes>* PrepareAsyncAMoveJTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveLRes>* AsyncAMoveLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveLRes>* PrepareAsyncAMoveLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveLTRes>* AsyncAMoveLTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveLTRes>* PrepareAsyncAMoveLTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveCRes>* AsyncAMoveCRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveCRes>* PrepareAsyncAMoveCRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveCTRes>* AsyncAMoveCTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMoveCTRes>* PrepareAsyncAMoveCTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitIORes>* AsyncAWaitIORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitIOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitIORes>* PrepareAsyncAWaitIORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitIOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitTimeRes>* AsyncAWaitTimeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTimeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitTimeRes>* PrepareAsyncAWaitTimeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTimeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitProgressRes>* AsyncAWaitProgressRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitProgressReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitProgressRes>* PrepareAsyncAWaitProgressRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitProgressReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitTrajRes>* AsyncAWaitTrajRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTrajReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitTrajRes>* PrepareAsyncAWaitTrajRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTrajReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitRadiusRes>* AsyncAWaitRadiusRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AWaitRadiusRes>* PrepareAsyncAWaitRadiusRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMotionStopRes>* AsyncAMotionStopRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMotionStopReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::AMotionStopRes>* PrepareAsyncAMotionStopRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMotionStopReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSJRes>* AsyncMoveSJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSJRes>* PrepareAsyncMoveSJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSJTRes>* AsyncMoveSJTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSJTRes>* PrepareAsyncMoveSJTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSLRes>* AsyncMoveSLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSLRes>* PrepareAsyncMoveSLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSLTRes>* AsyncMoveSLTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSLTRes>* PrepareAsyncMoveSLTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSpiralRes>* AsyncMoveSpiralRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSpiralReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::MoveSpiralRes>* PrepareAsyncMoveSpiralRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSpiralReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetRefFrameRes>* AsyncSetRefFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetRefFrameRes>* PrepareAsyncSetRefFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>* AsyncSetRefFramePlanarRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>* PrepareAsyncSetRefFramePlanarRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetToolFrameRes>* AsyncSetToolFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetToolFrameRes>* PrepareAsyncSetToolFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>* AsyncSetSpeedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>* PrepareAsyncSetSpeedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>* AsyncSetCommandSpeedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>* PrepareAsyncSetCommandSpeedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::RebootRes>* AsyncRebootRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RebootReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::RebootRes>* PrepareAsyncRebootRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RebootReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::RecoverRes>* AsyncRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RecoverReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::RecoverRes>* PrepareAsyncRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RecoverReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::StopRes>* AsyncStopRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::StopReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::StopRes>* PrepareAsyncStopRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::StopReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::PauseRes>* AsyncPauseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::PauseReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::PauseRes>* PrepareAsyncPauseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::PauseReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::ResumeRes>* AsyncResumeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ResumeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::ResumeRes>* PrepareAsyncResumeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ResumeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::BrakeRes>* AsyncBrakeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::BrakeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::BrakeRes>* PrepareAsyncBrakeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::BrakeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::ServoRes>* AsyncServoRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ServoReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::ServoRes>* PrepareAsyncServoRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ServoReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>* AsyncSetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>* PrepareAsyncSetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>* AsyncGetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>* PrepareAsyncGetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SimulationModeRes>* AsyncSimulationModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SimulationModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SimulationModeRes>* PrepareAsyncSimulationModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SimulationModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>* AsyncDirectTeachingModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>* PrepareAsyncDirectTeachingModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetRTControlDataRes>* AsyncGetRTControlDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetRTControlDataRes>* PrepareAsyncGetRTControlDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetIODataRes>* AsyncGetIODataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetIODataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetIODataRes>* PrepareAsyncGetIODataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetIODataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCoreDataRes>* AsyncGetCoreDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCoreDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCoreDataRes>* PrepareAsyncGetCoreDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCoreDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>* AsyncGetSystemInfoDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>* PrepareAsyncGetSystemInfoDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetMotionDataRes>* AsyncGetMotionDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMotionDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetMotionDataRes>* PrepareAsyncGetMotionDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMotionDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetStateDataRes>* AsyncGetStateDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetStateDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetStateDataRes>* PrepareAsyncGetStateDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetStateDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetViolationDataRes>* AsyncGetViolationDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetViolationDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetViolationDataRes>* PrepareAsyncGetViolationDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetViolationDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetProgramStateRes>* AsyncSetProgramStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetProgramStateReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetProgramStateRes>* PrepareAsyncSetProgramStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetProgramStateReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::InverseKinematicsRes>* AsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::InverseKinematicsRes>* PrepareAsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>* AsyncCheckAproachRetractValidRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>* PrepareAsyncCheckAproachRetractValidRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetPalletPointListRes>* AsyncGetPalletPointListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetPalletPointListRes>* PrepareAsyncGetPalletPointListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>* AsyncCalculateRelativePoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>* PrepareAsyncCalculateRelativePoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>* AsyncCalculateCurrentPoseRelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>* PrepareAsyncCalculateCurrentPoseRelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetDIRes>* AsyncGetDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetDIRes>* PrepareAsyncGetDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetDIRes>* AsyncSetDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetDIRes>* PrepareAsyncSetDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetDORes>* AsyncSetDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetDORes>* PrepareAsyncSetDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetDORes>* AsyncGetDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetDORes>* PrepareAsyncGetDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAIRes>* AsyncGetAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAIRes>* PrepareAsyncGetAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAIRes>* AsyncSetAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAIRes>* PrepareAsyncSetAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAORes>* AsyncGetAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetAORes>* PrepareAsyncGetAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAORes>* AsyncSetAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetAORes>* PrepareAsyncSetAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndDIRes>* AsyncGetEndDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndDIRes>* PrepareAsyncGetEndDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndDIRes>* AsyncSetEndDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndDIRes>* PrepareAsyncSetEndDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndDORes>* AsyncSetEndDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndDORes>* PrepareAsyncSetEndDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndDORes>* AsyncGetEndDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndDORes>* PrepareAsyncGetEndDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndAIRes>* AsyncGetEndAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndAIRes>* PrepareAsyncGetEndAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndAIRes>* AsyncSetEndAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndAIRes>* PrepareAsyncSetEndAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAIReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndAORes>* AsyncGetEndAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEndAORes>* PrepareAsyncGetEndAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndAORes>* AsyncSetEndAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetEndAORes>* PrepareAsyncSetEndAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetJointControlGainRes>* AsyncSetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetJointControlGainRes>* PrepareAsyncSetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetJointControlGainRes>* AsyncGetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetJointControlGainRes>* PrepareAsyncGetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>* AsyncSetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>* PrepareAsyncSetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>* AsyncGetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>* PrepareAsyncGetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>* AsyncSetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>* PrepareAsyncSetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>* AsyncGetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>* PrepareAsyncGetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetFricCompRes>* AsyncSetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetFricCompReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetFricCompRes>* PrepareAsyncSetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetFricCompReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetFricCompRes>* AsyncGetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetFricCompReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetFricCompRes>* PrepareAsyncGetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetFricCompReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetMountPosRes>* AsyncSetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetMountPosReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetMountPosRes>* PrepareAsyncSetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetMountPosReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetMountPosRes>* AsyncGetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMountPosReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetMountPosRes>* PrepareAsyncGetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMountPosReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetToolPropertyRes>* AsyncSetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetToolPropertyRes>* PrepareAsyncSetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetToolPropertyRes>* AsyncGetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetToolPropertyRes>* PrepareAsyncGetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>* AsyncSetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>* PrepareAsyncSetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>* AsyncGetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>* PrepareAsyncGetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollSensParamRes>* AsyncSetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollSensParamRes>* PrepareAsyncSetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollSensParamRes>* AsyncGetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollSensParamRes>* PrepareAsyncGetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollPolicyRes>* AsyncSetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetCollPolicyRes>* PrepareAsyncSetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollPolicyRes>* AsyncGetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollPolicyRes>* PrepareAsyncGetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>* AsyncGetCollTuningParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>* PrepareAsyncGetCollTuningParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>* AsyncGetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>* PrepareAsyncGetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>* AsyncSetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>* PrepareAsyncSetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>* AsyncGetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>* PrepareAsyncGetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>* AsyncSetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>* PrepareAsyncSetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEL5001Res>* AsyncGetEL5001Raw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5001Req& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEL5001Res>* PrepareAsyncGetEL5001Raw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5001Req& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEL5101Res>* AsyncGetEL5101Raw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5101Req& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::Control::GetEL5101Res>* PrepareAsyncGetEL5101Raw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5101Req& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status AMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJReq& request, ::IndyFramework::Protobuf::Control::AMoveJRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveJRes>> AsyncAMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveJRes>>(AsyncAMoveJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveJRes>> PrepareAsyncAMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveJRes>>(PrepareAsyncAMoveJRaw(context, request, cq));
    }
    ::grpc::Status AMoveJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJTReq& request, ::IndyFramework::Protobuf::Control::AMoveJTRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveJTRes>> AsyncAMoveJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveJTRes>>(AsyncAMoveJTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveJTRes>> PrepareAsyncAMoveJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveJTRes>>(PrepareAsyncAMoveJTRaw(context, request, cq));
    }
    ::grpc::Status AMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLReq& request, ::IndyFramework::Protobuf::Control::AMoveLRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveLRes>> AsyncAMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveLRes>>(AsyncAMoveLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveLRes>> PrepareAsyncAMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveLRes>>(PrepareAsyncAMoveLRaw(context, request, cq));
    }
    ::grpc::Status AMoveLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLTReq& request, ::IndyFramework::Protobuf::Control::AMoveLTRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveLTRes>> AsyncAMoveLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveLTRes>>(AsyncAMoveLTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveLTRes>> PrepareAsyncAMoveLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveLTRes>>(PrepareAsyncAMoveLTRaw(context, request, cq));
    }
    ::grpc::Status AMoveC(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCReq& request, ::IndyFramework::Protobuf::Control::AMoveCRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveCRes>> AsyncAMoveC(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveCRes>>(AsyncAMoveCRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveCRes>> PrepareAsyncAMoveC(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveCRes>>(PrepareAsyncAMoveCRaw(context, request, cq));
    }
    ::grpc::Status AMoveCT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCTReq& request, ::IndyFramework::Protobuf::Control::AMoveCTRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveCTRes>> AsyncAMoveCT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveCTRes>>(AsyncAMoveCTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveCTRes>> PrepareAsyncAMoveCT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveCTRes>>(PrepareAsyncAMoveCTRaw(context, request, cq));
    }
    ::grpc::Status AWaitIO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitIOReq& request, ::IndyFramework::Protobuf::Control::AWaitIORes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitIORes>> AsyncAWaitIO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitIOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitIORes>>(AsyncAWaitIORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitIORes>> PrepareAsyncAWaitIO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitIOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitIORes>>(PrepareAsyncAWaitIORaw(context, request, cq));
    }
    ::grpc::Status AWaitTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTimeReq& request, ::IndyFramework::Protobuf::Control::AWaitTimeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitTimeRes>> AsyncAWaitTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitTimeRes>>(AsyncAWaitTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitTimeRes>> PrepareAsyncAWaitTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitTimeRes>>(PrepareAsyncAWaitTimeRaw(context, request, cq));
    }
    ::grpc::Status AWaitProgress(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitProgressReq& request, ::IndyFramework::Protobuf::Control::AWaitProgressRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitProgressRes>> AsyncAWaitProgress(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitProgressReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitProgressRes>>(AsyncAWaitProgressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitProgressRes>> PrepareAsyncAWaitProgress(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitProgressReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitProgressRes>>(PrepareAsyncAWaitProgressRaw(context, request, cq));
    }
    ::grpc::Status AWaitTraj(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTrajReq& request, ::IndyFramework::Protobuf::Control::AWaitTrajRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitTrajRes>> AsyncAWaitTraj(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTrajReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitTrajRes>>(AsyncAWaitTrajRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitTrajRes>> PrepareAsyncAWaitTraj(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTrajReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitTrajRes>>(PrepareAsyncAWaitTrajRaw(context, request, cq));
    }
    ::grpc::Status AWaitRadius(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq& request, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitRadiusRes>> AsyncAWaitRadius(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitRadiusRes>>(AsyncAWaitRadiusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitRadiusRes>> PrepareAsyncAWaitRadius(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitRadiusRes>>(PrepareAsyncAWaitRadiusRaw(context, request, cq));
    }
    ::grpc::Status AMotionStop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMotionStopReq& request, ::IndyFramework::Protobuf::Control::AMotionStopRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMotionStopRes>> AsyncAMotionStop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMotionStopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMotionStopRes>>(AsyncAMotionStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMotionStopRes>> PrepareAsyncAMotionStop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMotionStopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMotionStopRes>>(PrepareAsyncAMotionStopRaw(context, request, cq));
    }
    ::grpc::Status MoveSJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJReq& request, ::IndyFramework::Protobuf::Control::MoveSJRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSJRes>> AsyncMoveSJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSJRes>>(AsyncMoveSJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSJRes>> PrepareAsyncMoveSJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSJRes>>(PrepareAsyncMoveSJRaw(context, request, cq));
    }
    ::grpc::Status MoveSJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJTReq& request, ::IndyFramework::Protobuf::Control::MoveSJTRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSJTRes>> AsyncMoveSJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSJTRes>>(AsyncMoveSJTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSJTRes>> PrepareAsyncMoveSJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSJTRes>>(PrepareAsyncMoveSJTRaw(context, request, cq));
    }
    ::grpc::Status MoveSL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLReq& request, ::IndyFramework::Protobuf::Control::MoveSLRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSLRes>> AsyncMoveSL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSLRes>>(AsyncMoveSLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSLRes>> PrepareAsyncMoveSL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSLRes>>(PrepareAsyncMoveSLRaw(context, request, cq));
    }
    ::grpc::Status MoveSLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLTReq& request, ::IndyFramework::Protobuf::Control::MoveSLTRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSLTRes>> AsyncMoveSLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSLTRes>>(AsyncMoveSLTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSLTRes>> PrepareAsyncMoveSLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSLTRes>>(PrepareAsyncMoveSLTRaw(context, request, cq));
    }
    ::grpc::Status MoveSpiral(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSpiralReq& request, ::IndyFramework::Protobuf::Control::MoveSpiralRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSpiralRes>> AsyncMoveSpiral(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSpiralReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSpiralRes>>(AsyncMoveSpiralRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSpiralRes>> PrepareAsyncMoveSpiral(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSpiralReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSpiralRes>>(PrepareAsyncMoveSpiralRaw(context, request, cq));
    }
    ::grpc::Status SetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFrameReq& request, ::IndyFramework::Protobuf::Control::SetRefFrameRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetRefFrameRes>> AsyncSetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetRefFrameRes>>(AsyncSetRefFrameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetRefFrameRes>> PrepareAsyncSetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetRefFrameRes>>(PrepareAsyncSetRefFrameRaw(context, request, cq));
    }
    ::grpc::Status SetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq& request, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>> AsyncSetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>>(AsyncSetRefFramePlanarRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>> PrepareAsyncSetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>>(PrepareAsyncSetRefFramePlanarRaw(context, request, cq));
    }
    ::grpc::Status SetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolFrameReq& request, ::IndyFramework::Protobuf::Control::SetToolFrameRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetToolFrameRes>> AsyncSetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetToolFrameRes>>(AsyncSetToolFrameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetToolFrameRes>> PrepareAsyncSetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetToolFrameRes>>(PrepareAsyncSetToolFrameRaw(context, request, cq));
    }
    ::grpc::Status SetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq& request, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>> AsyncSetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>>(AsyncSetSpeedRatioRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>> PrepareAsyncSetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>>(PrepareAsyncSetSpeedRatioRaw(context, request, cq));
    }
    ::grpc::Status SetCommandSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq& request, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>> AsyncSetCommandSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>>(AsyncSetCommandSpeedRatioRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>> PrepareAsyncSetCommandSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>>(PrepareAsyncSetCommandSpeedRatioRaw(context, request, cq));
    }
    ::grpc::Status Reboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RebootReq& request, ::IndyFramework::Protobuf::Control::RebootRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::RebootRes>> AsyncReboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RebootReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::RebootRes>>(AsyncRebootRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::RebootRes>> PrepareAsyncReboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RebootReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::RebootRes>>(PrepareAsyncRebootRaw(context, request, cq));
    }
    ::grpc::Status Recover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RecoverReq& request, ::IndyFramework::Protobuf::Control::RecoverRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::RecoverRes>> AsyncRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RecoverReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::RecoverRes>>(AsyncRecoverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::RecoverRes>> PrepareAsyncRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RecoverReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::RecoverRes>>(PrepareAsyncRecoverRaw(context, request, cq));
    }
    ::grpc::Status Stop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::StopReq& request, ::IndyFramework::Protobuf::Control::StopRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::StopRes>> AsyncStop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::StopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::StopRes>>(AsyncStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::StopRes>> PrepareAsyncStop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::StopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::StopRes>>(PrepareAsyncStopRaw(context, request, cq));
    }
    ::grpc::Status Pause(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::PauseReq& request, ::IndyFramework::Protobuf::Control::PauseRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::PauseRes>> AsyncPause(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::PauseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::PauseRes>>(AsyncPauseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::PauseRes>> PrepareAsyncPause(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::PauseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::PauseRes>>(PrepareAsyncPauseRaw(context, request, cq));
    }
    ::grpc::Status Resume(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ResumeReq& request, ::IndyFramework::Protobuf::Control::ResumeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::ResumeRes>> AsyncResume(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ResumeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::ResumeRes>>(AsyncResumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::ResumeRes>> PrepareAsyncResume(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ResumeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::ResumeRes>>(PrepareAsyncResumeRaw(context, request, cq));
    }
    ::grpc::Status Brake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::BrakeReq& request, ::IndyFramework::Protobuf::Control::BrakeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::BrakeRes>> AsyncBrake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::BrakeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::BrakeRes>>(AsyncBrakeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::BrakeRes>> PrepareAsyncBrake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::BrakeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::BrakeRes>>(PrepareAsyncBrakeRaw(context, request, cq));
    }
    ::grpc::Status Servo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ServoReq& request, ::IndyFramework::Protobuf::Control::ServoRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::ServoRes>> AsyncServo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ServoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::ServoRes>>(AsyncServoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::ServoRes>> PrepareAsyncServo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ServoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::ServoRes>>(PrepareAsyncServoRaw(context, request, cq));
    }
    ::grpc::Status SetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq& request, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>> AsyncSetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>>(AsyncSetAutoServoOffRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>> PrepareAsyncSetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>>(PrepareAsyncSetAutoServoOffRaw(context, request, cq));
    }
    ::grpc::Status GetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq& request, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>> AsyncGetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>>(AsyncGetAutoServoOffRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>> PrepareAsyncGetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>>(PrepareAsyncGetAutoServoOffRaw(context, request, cq));
    }
    ::grpc::Status SimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SimulationModeReq& request, ::IndyFramework::Protobuf::Control::SimulationModeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SimulationModeRes>> AsyncSimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SimulationModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SimulationModeRes>>(AsyncSimulationModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SimulationModeRes>> PrepareAsyncSimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SimulationModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SimulationModeRes>>(PrepareAsyncSimulationModeRaw(context, request, cq));
    }
    ::grpc::Status DirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq& request, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>> AsyncDirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>>(AsyncDirectTeachingModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>> PrepareAsyncDirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>>(PrepareAsyncDirectTeachingModeRaw(context, request, cq));
    }
    ::grpc::Status GetRTControlData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq& request, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetRTControlDataRes>> AsyncGetRTControlData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetRTControlDataRes>>(AsyncGetRTControlDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetRTControlDataRes>> PrepareAsyncGetRTControlData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetRTControlDataRes>>(PrepareAsyncGetRTControlDataRaw(context, request, cq));
    }
    ::grpc::Status GetIOData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetIODataReq& request, ::IndyFramework::Protobuf::Control::GetIODataRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetIODataRes>> AsyncGetIOData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetIODataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetIODataRes>>(AsyncGetIODataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetIODataRes>> PrepareAsyncGetIOData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetIODataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetIODataRes>>(PrepareAsyncGetIODataRaw(context, request, cq));
    }
    ::grpc::Status GetCoreData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCoreDataReq& request, ::IndyFramework::Protobuf::Control::GetCoreDataRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCoreDataRes>> AsyncGetCoreData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCoreDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCoreDataRes>>(AsyncGetCoreDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCoreDataRes>> PrepareAsyncGetCoreData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCoreDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCoreDataRes>>(PrepareAsyncGetCoreDataRaw(context, request, cq));
    }
    ::grpc::Status GetSystemInfoData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq& request, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>> AsyncGetSystemInfoData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>>(AsyncGetSystemInfoDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>> PrepareAsyncGetSystemInfoData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>>(PrepareAsyncGetSystemInfoDataRaw(context, request, cq));
    }
    ::grpc::Status GetMotionData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMotionDataReq& request, ::IndyFramework::Protobuf::Control::GetMotionDataRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetMotionDataRes>> AsyncGetMotionData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMotionDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetMotionDataRes>>(AsyncGetMotionDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetMotionDataRes>> PrepareAsyncGetMotionData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMotionDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetMotionDataRes>>(PrepareAsyncGetMotionDataRaw(context, request, cq));
    }
    ::grpc::Status GetStateData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetStateDataReq& request, ::IndyFramework::Protobuf::Control::GetStateDataRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetStateDataRes>> AsyncGetStateData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetStateDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetStateDataRes>>(AsyncGetStateDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetStateDataRes>> PrepareAsyncGetStateData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetStateDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetStateDataRes>>(PrepareAsyncGetStateDataRaw(context, request, cq));
    }
    ::grpc::Status GetViolationData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetViolationDataReq& request, ::IndyFramework::Protobuf::Control::GetViolationDataRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetViolationDataRes>> AsyncGetViolationData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetViolationDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetViolationDataRes>>(AsyncGetViolationDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetViolationDataRes>> PrepareAsyncGetViolationData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetViolationDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetViolationDataRes>>(PrepareAsyncGetViolationDataRaw(context, request, cq));
    }
    ::grpc::Status SetProgramState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetProgramStateReq& request, ::IndyFramework::Protobuf::Control::SetProgramStateRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetProgramStateRes>> AsyncSetProgramState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetProgramStateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetProgramStateRes>>(AsyncSetProgramStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetProgramStateRes>> PrepareAsyncSetProgramState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetProgramStateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetProgramStateRes>>(PrepareAsyncSetProgramStateRaw(context, request, cq));
    }
    ::grpc::Status InverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq& request, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::InverseKinematicsRes>> AsyncInverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::InverseKinematicsRes>>(AsyncInverseKinematicsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::InverseKinematicsRes>> PrepareAsyncInverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::InverseKinematicsRes>>(PrepareAsyncInverseKinematicsRaw(context, request, cq));
    }
    ::grpc::Status CheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq& request, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>> AsyncCheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>>(AsyncCheckAproachRetractValidRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>> PrepareAsyncCheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>>(PrepareAsyncCheckAproachRetractValidRaw(context, request, cq));
    }
    ::grpc::Status GetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq& request, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetPalletPointListRes>> AsyncGetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetPalletPointListRes>>(AsyncGetPalletPointListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetPalletPointListRes>> PrepareAsyncGetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetPalletPointListRes>>(PrepareAsyncGetPalletPointListRaw(context, request, cq));
    }
    ::grpc::Status CalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq& request, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>> AsyncCalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>>(AsyncCalculateRelativePoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>> PrepareAsyncCalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>>(PrepareAsyncCalculateRelativePoseRaw(context, request, cq));
    }
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq& request, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>> AsyncCalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>>(AsyncCalculateCurrentPoseRelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>> PrepareAsyncCalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>>(PrepareAsyncCalculateCurrentPoseRelRaw(context, request, cq));
    }
    ::grpc::Status GetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDIReq& request, ::IndyFramework::Protobuf::Control::GetDIRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetDIRes>> AsyncGetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetDIRes>>(AsyncGetDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetDIRes>> PrepareAsyncGetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetDIRes>>(PrepareAsyncGetDIRaw(context, request, cq));
    }
    ::grpc::Status SetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDIReq& request, ::IndyFramework::Protobuf::Control::SetDIRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetDIRes>> AsyncSetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetDIRes>>(AsyncSetDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetDIRes>> PrepareAsyncSetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetDIRes>>(PrepareAsyncSetDIRaw(context, request, cq));
    }
    ::grpc::Status SetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDOReq& request, ::IndyFramework::Protobuf::Control::SetDORes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetDORes>> AsyncSetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetDORes>>(AsyncSetDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetDORes>> PrepareAsyncSetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetDORes>>(PrepareAsyncSetDORaw(context, request, cq));
    }
    ::grpc::Status GetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDOReq& request, ::IndyFramework::Protobuf::Control::GetDORes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetDORes>> AsyncGetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetDORes>>(AsyncGetDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetDORes>> PrepareAsyncGetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetDORes>>(PrepareAsyncGetDORaw(context, request, cq));
    }
    ::grpc::Status GetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAIReq& request, ::IndyFramework::Protobuf::Control::GetAIRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAIRes>> AsyncGetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAIRes>>(AsyncGetAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAIRes>> PrepareAsyncGetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAIRes>>(PrepareAsyncGetAIRaw(context, request, cq));
    }
    ::grpc::Status SetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAIReq& request, ::IndyFramework::Protobuf::Control::SetAIRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAIRes>> AsyncSetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAIRes>>(AsyncSetAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAIRes>> PrepareAsyncSetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAIRes>>(PrepareAsyncSetAIRaw(context, request, cq));
    }
    ::grpc::Status GetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAOReq& request, ::IndyFramework::Protobuf::Control::GetAORes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAORes>> AsyncGetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAORes>>(AsyncGetAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAORes>> PrepareAsyncGetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAORes>>(PrepareAsyncGetAORaw(context, request, cq));
    }
    ::grpc::Status SetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAOReq& request, ::IndyFramework::Protobuf::Control::SetAORes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAORes>> AsyncSetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAORes>>(AsyncSetAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAORes>> PrepareAsyncSetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAORes>>(PrepareAsyncSetAORaw(context, request, cq));
    }
    ::grpc::Status GetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDIReq& request, ::IndyFramework::Protobuf::Control::GetEndDIRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndDIRes>> AsyncGetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndDIRes>>(AsyncGetEndDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndDIRes>> PrepareAsyncGetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndDIRes>>(PrepareAsyncGetEndDIRaw(context, request, cq));
    }
    ::grpc::Status SetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDIReq& request, ::IndyFramework::Protobuf::Control::SetEndDIRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndDIRes>> AsyncSetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndDIRes>>(AsyncSetEndDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndDIRes>> PrepareAsyncSetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndDIRes>>(PrepareAsyncSetEndDIRaw(context, request, cq));
    }
    ::grpc::Status SetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDOReq& request, ::IndyFramework::Protobuf::Control::SetEndDORes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndDORes>> AsyncSetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndDORes>>(AsyncSetEndDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndDORes>> PrepareAsyncSetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndDORes>>(PrepareAsyncSetEndDORaw(context, request, cq));
    }
    ::grpc::Status GetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDOReq& request, ::IndyFramework::Protobuf::Control::GetEndDORes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndDORes>> AsyncGetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndDORes>>(AsyncGetEndDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndDORes>> PrepareAsyncGetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndDORes>>(PrepareAsyncGetEndDORaw(context, request, cq));
    }
    ::grpc::Status GetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAIReq& request, ::IndyFramework::Protobuf::Control::GetEndAIRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndAIRes>> AsyncGetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndAIRes>>(AsyncGetEndAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndAIRes>> PrepareAsyncGetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndAIRes>>(PrepareAsyncGetEndAIRaw(context, request, cq));
    }
    ::grpc::Status SetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAIReq& request, ::IndyFramework::Protobuf::Control::SetEndAIRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndAIRes>> AsyncSetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndAIRes>>(AsyncSetEndAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndAIRes>> PrepareAsyncSetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAIReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndAIRes>>(PrepareAsyncSetEndAIRaw(context, request, cq));
    }
    ::grpc::Status GetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAOReq& request, ::IndyFramework::Protobuf::Control::GetEndAORes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndAORes>> AsyncGetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndAORes>>(AsyncGetEndAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndAORes>> PrepareAsyncGetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndAORes>>(PrepareAsyncGetEndAORaw(context, request, cq));
    }
    ::grpc::Status SetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAOReq& request, ::IndyFramework::Protobuf::Control::SetEndAORes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndAORes>> AsyncSetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndAORes>>(AsyncSetEndAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndAORes>> PrepareAsyncSetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndAORes>>(PrepareAsyncSetEndAORaw(context, request, cq));
    }
    ::grpc::Status SetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq& request, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetJointControlGainRes>> AsyncSetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetJointControlGainRes>>(AsyncSetJointControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetJointControlGainRes>> PrepareAsyncSetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetJointControlGainRes>>(PrepareAsyncSetJointControlGainRaw(context, request, cq));
    }
    ::grpc::Status GetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq& request, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetJointControlGainRes>> AsyncGetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetJointControlGainRes>>(AsyncGetJointControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetJointControlGainRes>> PrepareAsyncGetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetJointControlGainRes>>(PrepareAsyncGetJointControlGainRaw(context, request, cq));
    }
    ::grpc::Status SetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq& request, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>> AsyncSetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>>(AsyncSetTaskControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>> PrepareAsyncSetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>>(PrepareAsyncSetTaskControlGainRaw(context, request, cq));
    }
    ::grpc::Status GetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq& request, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>> AsyncGetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>>(AsyncGetTaskControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>> PrepareAsyncGetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>>(PrepareAsyncGetTaskControlGainRaw(context, request, cq));
    }
    ::grpc::Status SetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq& request, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>> AsyncSetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>>(AsyncSetImpedanceControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>> PrepareAsyncSetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>>(PrepareAsyncSetImpedanceControlGainRaw(context, request, cq));
    }
    ::grpc::Status GetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq& request, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>> AsyncGetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>>(AsyncGetImpedanceControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>> PrepareAsyncGetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>>(PrepareAsyncGetImpedanceControlGainRaw(context, request, cq));
    }
    ::grpc::Status SetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetFricCompReq& request, ::IndyFramework::Protobuf::Control::SetFricCompRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetFricCompRes>> AsyncSetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetFricCompRes>>(AsyncSetFricCompRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetFricCompRes>> PrepareAsyncSetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetFricCompRes>>(PrepareAsyncSetFricCompRaw(context, request, cq));
    }
    ::grpc::Status GetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetFricCompReq& request, ::IndyFramework::Protobuf::Control::GetFricCompRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetFricCompRes>> AsyncGetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetFricCompRes>>(AsyncGetFricCompRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetFricCompRes>> PrepareAsyncGetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetFricCompRes>>(PrepareAsyncGetFricCompRaw(context, request, cq));
    }
    ::grpc::Status SetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetMountPosReq& request, ::IndyFramework::Protobuf::Control::SetMountPosRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetMountPosRes>> AsyncSetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetMountPosRes>>(AsyncSetMountPosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetMountPosRes>> PrepareAsyncSetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetMountPosRes>>(PrepareAsyncSetMountPosRaw(context, request, cq));
    }
    ::grpc::Status GetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMountPosReq& request, ::IndyFramework::Protobuf::Control::GetMountPosRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetMountPosRes>> AsyncGetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetMountPosRes>>(AsyncGetMountPosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetMountPosRes>> PrepareAsyncGetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetMountPosRes>>(PrepareAsyncGetMountPosRaw(context, request, cq));
    }
    ::grpc::Status SetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq& request, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetToolPropertyRes>> AsyncSetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetToolPropertyRes>>(AsyncSetToolPropertyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetToolPropertyRes>> PrepareAsyncSetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetToolPropertyRes>>(PrepareAsyncSetToolPropertyRaw(context, request, cq));
    }
    ::grpc::Status GetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq& request, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetToolPropertyRes>> AsyncGetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetToolPropertyRes>>(AsyncGetToolPropertyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetToolPropertyRes>> PrepareAsyncGetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetToolPropertyRes>>(PrepareAsyncGetToolPropertyRaw(context, request, cq));
    }
    ::grpc::Status SetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq& request, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>> AsyncSetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>>(AsyncSetCollSensLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>> PrepareAsyncSetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>>(PrepareAsyncSetCollSensLevelRaw(context, request, cq));
    }
    ::grpc::Status GetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq& request, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>> AsyncGetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>>(AsyncGetCollSensLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>> PrepareAsyncGetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>>(PrepareAsyncGetCollSensLevelRaw(context, request, cq));
    }
    ::grpc::Status SetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq& request, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollSensParamRes>> AsyncSetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollSensParamRes>>(AsyncSetCollSensParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollSensParamRes>> PrepareAsyncSetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollSensParamRes>>(PrepareAsyncSetCollSensParamRaw(context, request, cq));
    }
    ::grpc::Status GetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq& request, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollSensParamRes>> AsyncGetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollSensParamRes>>(AsyncGetCollSensParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollSensParamRes>> PrepareAsyncGetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollSensParamRes>>(PrepareAsyncGetCollSensParamRaw(context, request, cq));
    }
    ::grpc::Status SetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq& request, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollPolicyRes>> AsyncSetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollPolicyRes>>(AsyncSetCollPolicyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollPolicyRes>> PrepareAsyncSetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollPolicyRes>>(PrepareAsyncSetCollPolicyRaw(context, request, cq));
    }
    ::grpc::Status GetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq& request, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollPolicyRes>> AsyncGetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollPolicyRes>>(AsyncGetCollPolicyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollPolicyRes>> PrepareAsyncGetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollPolicyRes>>(PrepareAsyncGetCollPolicyRaw(context, request, cq));
    }
    ::grpc::Status GetCollTuningParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq& request, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>> AsyncGetCollTuningParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>>(AsyncGetCollTuningParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>> PrepareAsyncGetCollTuningParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>>(PrepareAsyncGetCollTuningParamRaw(context, request, cq));
    }
    ::grpc::Status GetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq& request, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>> AsyncGetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>>(AsyncGetSafetyLimitConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>> PrepareAsyncGetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>>(PrepareAsyncGetSafetyLimitConfigRaw(context, request, cq));
    }
    ::grpc::Status SetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq& request, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>> AsyncSetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>>(AsyncSetSafetyLimitConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>> PrepareAsyncSetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>>(PrepareAsyncSetSafetyLimitConfigRaw(context, request, cq));
    }
    ::grpc::Status GetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq& request, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>> AsyncGetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>>(AsyncGetSafetyStopConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>> PrepareAsyncGetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>>(PrepareAsyncGetSafetyStopConfigRaw(context, request, cq));
    }
    ::grpc::Status SetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq& request, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>> AsyncSetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>>(AsyncSetSafetyStopConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>> PrepareAsyncSetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>>(PrepareAsyncSetSafetyStopConfigRaw(context, request, cq));
    }
    ::grpc::Status GetEL5001(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5001Req& request, ::IndyFramework::Protobuf::Control::GetEL5001Res* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEL5001Res>> AsyncGetEL5001(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5001Req& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEL5001Res>>(AsyncGetEL5001Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEL5001Res>> PrepareAsyncGetEL5001(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5001Req& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEL5001Res>>(PrepareAsyncGetEL5001Raw(context, request, cq));
    }
    ::grpc::Status GetEL5101(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5101Req& request, ::IndyFramework::Protobuf::Control::GetEL5101Res* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEL5101Res>> AsyncGetEL5101(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5101Req& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEL5101Res>>(AsyncGetEL5101Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEL5101Res>> PrepareAsyncGetEL5101(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5101Req& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEL5101Res>>(PrepareAsyncGetEL5101Raw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void AMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJReq* request, ::IndyFramework::Protobuf::Control::AMoveJRes* response, std::function<void(::grpc::Status)>) override;
      void AMoveJ(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveJRes* response, std::function<void(::grpc::Status)>) override;
      void AMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJReq* request, ::IndyFramework::Protobuf::Control::AMoveJRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AMoveJ(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveJRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AMoveJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJTReq* request, ::IndyFramework::Protobuf::Control::AMoveJTRes* response, std::function<void(::grpc::Status)>) override;
      void AMoveJT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveJTRes* response, std::function<void(::grpc::Status)>) override;
      void AMoveJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJTReq* request, ::IndyFramework::Protobuf::Control::AMoveJTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AMoveJT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveJTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLReq* request, ::IndyFramework::Protobuf::Control::AMoveLRes* response, std::function<void(::grpc::Status)>) override;
      void AMoveL(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveLRes* response, std::function<void(::grpc::Status)>) override;
      void AMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLReq* request, ::IndyFramework::Protobuf::Control::AMoveLRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AMoveL(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveLRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AMoveLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLTReq* request, ::IndyFramework::Protobuf::Control::AMoveLTRes* response, std::function<void(::grpc::Status)>) override;
      void AMoveLT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveLTRes* response, std::function<void(::grpc::Status)>) override;
      void AMoveLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLTReq* request, ::IndyFramework::Protobuf::Control::AMoveLTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AMoveLT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveLTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AMoveC(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCReq* request, ::IndyFramework::Protobuf::Control::AMoveCRes* response, std::function<void(::grpc::Status)>) override;
      void AMoveC(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveCRes* response, std::function<void(::grpc::Status)>) override;
      void AMoveC(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCReq* request, ::IndyFramework::Protobuf::Control::AMoveCRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AMoveC(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveCRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AMoveCT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCTReq* request, ::IndyFramework::Protobuf::Control::AMoveCTRes* response, std::function<void(::grpc::Status)>) override;
      void AMoveCT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveCTRes* response, std::function<void(::grpc::Status)>) override;
      void AMoveCT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCTReq* request, ::IndyFramework::Protobuf::Control::AMoveCTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AMoveCT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMoveCTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AWaitIO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitIOReq* request, ::IndyFramework::Protobuf::Control::AWaitIORes* response, std::function<void(::grpc::Status)>) override;
      void AWaitIO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitIORes* response, std::function<void(::grpc::Status)>) override;
      void AWaitIO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitIOReq* request, ::IndyFramework::Protobuf::Control::AWaitIORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AWaitIO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitIORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AWaitTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTimeReq* request, ::IndyFramework::Protobuf::Control::AWaitTimeRes* response, std::function<void(::grpc::Status)>) override;
      void AWaitTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitTimeRes* response, std::function<void(::grpc::Status)>) override;
      void AWaitTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTimeReq* request, ::IndyFramework::Protobuf::Control::AWaitTimeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AWaitTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitTimeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AWaitProgress(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitProgressReq* request, ::IndyFramework::Protobuf::Control::AWaitProgressRes* response, std::function<void(::grpc::Status)>) override;
      void AWaitProgress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitProgressRes* response, std::function<void(::grpc::Status)>) override;
      void AWaitProgress(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitProgressReq* request, ::IndyFramework::Protobuf::Control::AWaitProgressRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AWaitProgress(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitProgressRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AWaitTraj(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTrajReq* request, ::IndyFramework::Protobuf::Control::AWaitTrajRes* response, std::function<void(::grpc::Status)>) override;
      void AWaitTraj(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitTrajRes* response, std::function<void(::grpc::Status)>) override;
      void AWaitTraj(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTrajReq* request, ::IndyFramework::Protobuf::Control::AWaitTrajRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AWaitTraj(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitTrajRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AWaitRadius(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq* request, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* response, std::function<void(::grpc::Status)>) override;
      void AWaitRadius(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* response, std::function<void(::grpc::Status)>) override;
      void AWaitRadius(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq* request, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AWaitRadius(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AMotionStop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMotionStopReq* request, ::IndyFramework::Protobuf::Control::AMotionStopRes* response, std::function<void(::grpc::Status)>) override;
      void AMotionStop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMotionStopRes* response, std::function<void(::grpc::Status)>) override;
      void AMotionStop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMotionStopReq* request, ::IndyFramework::Protobuf::Control::AMotionStopRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AMotionStop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::AMotionStopRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void MoveSJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJReq* request, ::IndyFramework::Protobuf::Control::MoveSJRes* response, std::function<void(::grpc::Status)>) override;
      void MoveSJ(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSJRes* response, std::function<void(::grpc::Status)>) override;
      void MoveSJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJReq* request, ::IndyFramework::Protobuf::Control::MoveSJRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void MoveSJ(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSJRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void MoveSJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJTReq* request, ::IndyFramework::Protobuf::Control::MoveSJTRes* response, std::function<void(::grpc::Status)>) override;
      void MoveSJT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSJTRes* response, std::function<void(::grpc::Status)>) override;
      void MoveSJT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJTReq* request, ::IndyFramework::Protobuf::Control::MoveSJTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void MoveSJT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSJTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void MoveSL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLReq* request, ::IndyFramework::Protobuf::Control::MoveSLRes* response, std::function<void(::grpc::Status)>) override;
      void MoveSL(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSLRes* response, std::function<void(::grpc::Status)>) override;
      void MoveSL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLReq* request, ::IndyFramework::Protobuf::Control::MoveSLRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void MoveSL(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSLRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void MoveSLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLTReq* request, ::IndyFramework::Protobuf::Control::MoveSLTRes* response, std::function<void(::grpc::Status)>) override;
      void MoveSLT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSLTRes* response, std::function<void(::grpc::Status)>) override;
      void MoveSLT(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLTReq* request, ::IndyFramework::Protobuf::Control::MoveSLTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void MoveSLT(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSLTRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void MoveSpiral(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSpiralReq* request, ::IndyFramework::Protobuf::Control::MoveSpiralRes* response, std::function<void(::grpc::Status)>) override;
      void MoveSpiral(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSpiralRes* response, std::function<void(::grpc::Status)>) override;
      void MoveSpiral(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSpiralReq* request, ::IndyFramework::Protobuf::Control::MoveSpiralRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void MoveSpiral(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::MoveSpiralRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFrameReq* request, ::IndyFramework::Protobuf::Control::SetRefFrameRes* response, std::function<void(::grpc::Status)>) override;
      void SetRefFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetRefFrameRes* response, std::function<void(::grpc::Status)>) override;
      void SetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFrameReq* request, ::IndyFramework::Protobuf::Control::SetRefFrameRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRefFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetRefFrameRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq* request, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* response, std::function<void(::grpc::Status)>) override;
      void SetRefFramePlanar(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* response, std::function<void(::grpc::Status)>) override;
      void SetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq* request, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRefFramePlanar(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolFrameReq* request, ::IndyFramework::Protobuf::Control::SetToolFrameRes* response, std::function<void(::grpc::Status)>) override;
      void SetToolFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetToolFrameRes* response, std::function<void(::grpc::Status)>) override;
      void SetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolFrameReq* request, ::IndyFramework::Protobuf::Control::SetToolFrameRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetToolFrame(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetToolFrameRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq* request, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* response, std::function<void(::grpc::Status)>) override;
      void SetSpeedRatio(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* response, std::function<void(::grpc::Status)>) override;
      void SetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq* request, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetSpeedRatio(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetCommandSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq* request, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* response, std::function<void(::grpc::Status)>) override;
      void SetCommandSpeedRatio(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* response, std::function<void(::grpc::Status)>) override;
      void SetCommandSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq* request, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetCommandSpeedRatio(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Reboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RebootReq* request, ::IndyFramework::Protobuf::Control::RebootRes* response, std::function<void(::grpc::Status)>) override;
      void Reboot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::RebootRes* response, std::function<void(::grpc::Status)>) override;
      void Reboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RebootReq* request, ::IndyFramework::Protobuf::Control::RebootRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Reboot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::RebootRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Recover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RecoverReq* request, ::IndyFramework::Protobuf::Control::RecoverRes* response, std::function<void(::grpc::Status)>) override;
      void Recover(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::RecoverRes* response, std::function<void(::grpc::Status)>) override;
      void Recover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RecoverReq* request, ::IndyFramework::Protobuf::Control::RecoverRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Recover(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::RecoverRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Stop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::StopReq* request, ::IndyFramework::Protobuf::Control::StopRes* response, std::function<void(::grpc::Status)>) override;
      void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::StopRes* response, std::function<void(::grpc::Status)>) override;
      void Stop(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::StopReq* request, ::IndyFramework::Protobuf::Control::StopRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::StopRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Pause(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::PauseReq* request, ::IndyFramework::Protobuf::Control::PauseRes* response, std::function<void(::grpc::Status)>) override;
      void Pause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::PauseRes* response, std::function<void(::grpc::Status)>) override;
      void Pause(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::PauseReq* request, ::IndyFramework::Protobuf::Control::PauseRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Pause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::PauseRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Resume(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ResumeReq* request, ::IndyFramework::Protobuf::Control::ResumeRes* response, std::function<void(::grpc::Status)>) override;
      void Resume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::ResumeRes* response, std::function<void(::grpc::Status)>) override;
      void Resume(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ResumeReq* request, ::IndyFramework::Protobuf::Control::ResumeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Resume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::ResumeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Brake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::BrakeReq* request, ::IndyFramework::Protobuf::Control::BrakeRes* response, std::function<void(::grpc::Status)>) override;
      void Brake(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::BrakeRes* response, std::function<void(::grpc::Status)>) override;
      void Brake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::BrakeReq* request, ::IndyFramework::Protobuf::Control::BrakeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Brake(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::BrakeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Servo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ServoReq* request, ::IndyFramework::Protobuf::Control::ServoRes* response, std::function<void(::grpc::Status)>) override;
      void Servo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::ServoRes* response, std::function<void(::grpc::Status)>) override;
      void Servo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ServoReq* request, ::IndyFramework::Protobuf::Control::ServoRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Servo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::ServoRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq* request, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* response, std::function<void(::grpc::Status)>) override;
      void SetAutoServoOff(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* response, std::function<void(::grpc::Status)>) override;
      void SetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq* request, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetAutoServoOff(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq* request, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* response, std::function<void(::grpc::Status)>) override;
      void GetAutoServoOff(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* response, std::function<void(::grpc::Status)>) override;
      void GetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq* request, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAutoServoOff(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SimulationModeReq* request, ::IndyFramework::Protobuf::Control::SimulationModeRes* response, std::function<void(::grpc::Status)>) override;
      void SimulationMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SimulationModeRes* response, std::function<void(::grpc::Status)>) override;
      void SimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SimulationModeReq* request, ::IndyFramework::Protobuf::Control::SimulationModeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SimulationMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SimulationModeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq* request, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* response, std::function<void(::grpc::Status)>) override;
      void DirectTeachingMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* response, std::function<void(::grpc::Status)>) override;
      void DirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq* request, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DirectTeachingMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetRTControlData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq* request, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* response, std::function<void(::grpc::Status)>) override;
      void GetRTControlData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* response, std::function<void(::grpc::Status)>) override;
      void GetRTControlData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq* request, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetRTControlData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetIOData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetIODataReq* request, ::IndyFramework::Protobuf::Control::GetIODataRes* response, std::function<void(::grpc::Status)>) override;
      void GetIOData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetIODataRes* response, std::function<void(::grpc::Status)>) override;
      void GetIOData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetIODataReq* request, ::IndyFramework::Protobuf::Control::GetIODataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetIOData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetIODataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCoreData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCoreDataReq* request, ::IndyFramework::Protobuf::Control::GetCoreDataRes* response, std::function<void(::grpc::Status)>) override;
      void GetCoreData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCoreDataRes* response, std::function<void(::grpc::Status)>) override;
      void GetCoreData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCoreDataReq* request, ::IndyFramework::Protobuf::Control::GetCoreDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCoreData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCoreDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetSystemInfoData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq* request, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* response, std::function<void(::grpc::Status)>) override;
      void GetSystemInfoData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* response, std::function<void(::grpc::Status)>) override;
      void GetSystemInfoData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq* request, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetSystemInfoData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMotionData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMotionDataReq* request, ::IndyFramework::Protobuf::Control::GetMotionDataRes* response, std::function<void(::grpc::Status)>) override;
      void GetMotionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetMotionDataRes* response, std::function<void(::grpc::Status)>) override;
      void GetMotionData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMotionDataReq* request, ::IndyFramework::Protobuf::Control::GetMotionDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMotionData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetMotionDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetStateData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetStateDataReq* request, ::IndyFramework::Protobuf::Control::GetStateDataRes* response, std::function<void(::grpc::Status)>) override;
      void GetStateData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetStateDataRes* response, std::function<void(::grpc::Status)>) override;
      void GetStateData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetStateDataReq* request, ::IndyFramework::Protobuf::Control::GetStateDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetStateData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetStateDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetViolationData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetViolationDataReq* request, ::IndyFramework::Protobuf::Control::GetViolationDataRes* response, std::function<void(::grpc::Status)>) override;
      void GetViolationData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetViolationDataRes* response, std::function<void(::grpc::Status)>) override;
      void GetViolationData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetViolationDataReq* request, ::IndyFramework::Protobuf::Control::GetViolationDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetViolationData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetViolationDataRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetProgramState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetProgramStateReq* request, ::IndyFramework::Protobuf::Control::SetProgramStateRes* response, std::function<void(::grpc::Status)>) override;
      void SetProgramState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetProgramStateRes* response, std::function<void(::grpc::Status)>) override;
      void SetProgramState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetProgramStateReq* request, ::IndyFramework::Protobuf::Control::SetProgramStateRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetProgramState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetProgramStateRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void InverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq* request, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* response, std::function<void(::grpc::Status)>) override;
      void InverseKinematics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* response, std::function<void(::grpc::Status)>) override;
      void InverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq* request, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void InverseKinematics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq* request, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* response, std::function<void(::grpc::Status)>) override;
      void CheckAproachRetractValid(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* response, std::function<void(::grpc::Status)>) override;
      void CheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq* request, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CheckAproachRetractValid(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq* request, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* response, std::function<void(::grpc::Status)>) override;
      void GetPalletPointList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* response, std::function<void(::grpc::Status)>) override;
      void GetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq* request, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetPalletPointList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq* request, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* response, std::function<void(::grpc::Status)>) override;
      void CalculateRelativePose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* response, std::function<void(::grpc::Status)>) override;
      void CalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq* request, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CalculateRelativePose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq* request, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* response, std::function<void(::grpc::Status)>) override;
      void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* response, std::function<void(::grpc::Status)>) override;
      void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq* request, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDIReq* request, ::IndyFramework::Protobuf::Control::GetDIRes* response, std::function<void(::grpc::Status)>) override;
      void GetDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetDIRes* response, std::function<void(::grpc::Status)>) override;
      void GetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDIReq* request, ::IndyFramework::Protobuf::Control::GetDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDIReq* request, ::IndyFramework::Protobuf::Control::SetDIRes* response, std::function<void(::grpc::Status)>) override;
      void SetDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetDIRes* response, std::function<void(::grpc::Status)>) override;
      void SetDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDIReq* request, ::IndyFramework::Protobuf::Control::SetDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDOReq* request, ::IndyFramework::Protobuf::Control::SetDORes* response, std::function<void(::grpc::Status)>) override;
      void SetDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetDORes* response, std::function<void(::grpc::Status)>) override;
      void SetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDOReq* request, ::IndyFramework::Protobuf::Control::SetDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDOReq* request, ::IndyFramework::Protobuf::Control::GetDORes* response, std::function<void(::grpc::Status)>) override;
      void GetDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetDORes* response, std::function<void(::grpc::Status)>) override;
      void GetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDOReq* request, ::IndyFramework::Protobuf::Control::GetDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAIReq* request, ::IndyFramework::Protobuf::Control::GetAIRes* response, std::function<void(::grpc::Status)>) override;
      void GetAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetAIRes* response, std::function<void(::grpc::Status)>) override;
      void GetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAIReq* request, ::IndyFramework::Protobuf::Control::GetAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAIReq* request, ::IndyFramework::Protobuf::Control::SetAIRes* response, std::function<void(::grpc::Status)>) override;
      void SetAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetAIRes* response, std::function<void(::grpc::Status)>) override;
      void SetAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAIReq* request, ::IndyFramework::Protobuf::Control::SetAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAOReq* request, ::IndyFramework::Protobuf::Control::GetAORes* response, std::function<void(::grpc::Status)>) override;
      void GetAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetAORes* response, std::function<void(::grpc::Status)>) override;
      void GetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAOReq* request, ::IndyFramework::Protobuf::Control::GetAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAOReq* request, ::IndyFramework::Protobuf::Control::SetAORes* response, std::function<void(::grpc::Status)>) override;
      void SetAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetAORes* response, std::function<void(::grpc::Status)>) override;
      void SetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAOReq* request, ::IndyFramework::Protobuf::Control::SetAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDIReq* request, ::IndyFramework::Protobuf::Control::GetEndDIRes* response, std::function<void(::grpc::Status)>) override;
      void GetEndDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndDIRes* response, std::function<void(::grpc::Status)>) override;
      void GetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDIReq* request, ::IndyFramework::Protobuf::Control::GetEndDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetEndDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDIReq* request, ::IndyFramework::Protobuf::Control::SetEndDIRes* response, std::function<void(::grpc::Status)>) override;
      void SetEndDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndDIRes* response, std::function<void(::grpc::Status)>) override;
      void SetEndDI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDIReq* request, ::IndyFramework::Protobuf::Control::SetEndDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetEndDI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndDIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDOReq* request, ::IndyFramework::Protobuf::Control::SetEndDORes* response, std::function<void(::grpc::Status)>) override;
      void SetEndDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndDORes* response, std::function<void(::grpc::Status)>) override;
      void SetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDOReq* request, ::IndyFramework::Protobuf::Control::SetEndDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetEndDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDOReq* request, ::IndyFramework::Protobuf::Control::GetEndDORes* response, std::function<void(::grpc::Status)>) override;
      void GetEndDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndDORes* response, std::function<void(::grpc::Status)>) override;
      void GetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDOReq* request, ::IndyFramework::Protobuf::Control::GetEndDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetEndDO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndDORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAIReq* request, ::IndyFramework::Protobuf::Control::GetEndAIRes* response, std::function<void(::grpc::Status)>) override;
      void GetEndAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndAIRes* response, std::function<void(::grpc::Status)>) override;
      void GetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAIReq* request, ::IndyFramework::Protobuf::Control::GetEndAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetEndAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAIReq* request, ::IndyFramework::Protobuf::Control::SetEndAIRes* response, std::function<void(::grpc::Status)>) override;
      void SetEndAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndAIRes* response, std::function<void(::grpc::Status)>) override;
      void SetEndAI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAIReq* request, ::IndyFramework::Protobuf::Control::SetEndAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetEndAI(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndAIRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAOReq* request, ::IndyFramework::Protobuf::Control::GetEndAORes* response, std::function<void(::grpc::Status)>) override;
      void GetEndAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndAORes* response, std::function<void(::grpc::Status)>) override;
      void GetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAOReq* request, ::IndyFramework::Protobuf::Control::GetEndAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetEndAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEndAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAOReq* request, ::IndyFramework::Protobuf::Control::SetEndAORes* response, std::function<void(::grpc::Status)>) override;
      void SetEndAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndAORes* response, std::function<void(::grpc::Status)>) override;
      void SetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAOReq* request, ::IndyFramework::Protobuf::Control::SetEndAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetEndAO(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetEndAORes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq* request, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void SetJointControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void SetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq* request, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetJointControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq* request, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void GetJointControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void GetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq* request, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetJointControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq* request, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void SetTaskControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void SetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq* request, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetTaskControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq* request, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void GetTaskControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void GetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq* request, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetTaskControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void SetImpedanceControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void SetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetImpedanceControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void GetImpedanceControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void GetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetImpedanceControlGain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetFricCompReq* request, ::IndyFramework::Protobuf::Control::SetFricCompRes* response, std::function<void(::grpc::Status)>) override;
      void SetFricComp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetFricCompRes* response, std::function<void(::grpc::Status)>) override;
      void SetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetFricCompReq* request, ::IndyFramework::Protobuf::Control::SetFricCompRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetFricComp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetFricCompRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetFricCompReq* request, ::IndyFramework::Protobuf::Control::GetFricCompRes* response, std::function<void(::grpc::Status)>) override;
      void GetFricComp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetFricCompRes* response, std::function<void(::grpc::Status)>) override;
      void GetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetFricCompReq* request, ::IndyFramework::Protobuf::Control::GetFricCompRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetFricComp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetFricCompRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetMountPosReq* request, ::IndyFramework::Protobuf::Control::SetMountPosRes* response, std::function<void(::grpc::Status)>) override;
      void SetMountPos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetMountPosRes* response, std::function<void(::grpc::Status)>) override;
      void SetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetMountPosReq* request, ::IndyFramework::Protobuf::Control::SetMountPosRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetMountPos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetMountPosRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMountPosReq* request, ::IndyFramework::Protobuf::Control::GetMountPosRes* response, std::function<void(::grpc::Status)>) override;
      void GetMountPos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetMountPosRes* response, std::function<void(::grpc::Status)>) override;
      void GetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMountPosReq* request, ::IndyFramework::Protobuf::Control::GetMountPosRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMountPos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetMountPosRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq* request, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* response, std::function<void(::grpc::Status)>) override;
      void SetToolProperty(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* response, std::function<void(::grpc::Status)>) override;
      void SetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq* request, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetToolProperty(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq* request, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* response, std::function<void(::grpc::Status)>) override;
      void GetToolProperty(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* response, std::function<void(::grpc::Status)>) override;
      void GetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq* request, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetToolProperty(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq* request, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* response, std::function<void(::grpc::Status)>) override;
      void SetCollSensLevel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* response, std::function<void(::grpc::Status)>) override;
      void SetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq* request, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetCollSensLevel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq* request, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* response, std::function<void(::grpc::Status)>) override;
      void GetCollSensLevel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* response, std::function<void(::grpc::Status)>) override;
      void GetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq* request, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCollSensLevel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq* request, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* response, std::function<void(::grpc::Status)>) override;
      void SetCollSensParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* response, std::function<void(::grpc::Status)>) override;
      void SetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq* request, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetCollSensParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq* request, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* response, std::function<void(::grpc::Status)>) override;
      void GetCollSensParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* response, std::function<void(::grpc::Status)>) override;
      void GetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq* request, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCollSensParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq* request, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* response, std::function<void(::grpc::Status)>) override;
      void SetCollPolicy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* response, std::function<void(::grpc::Status)>) override;
      void SetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq* request, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetCollPolicy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq* request, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* response, std::function<void(::grpc::Status)>) override;
      void GetCollPolicy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* response, std::function<void(::grpc::Status)>) override;
      void GetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq* request, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCollPolicy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCollTuningParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq* request, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* response, std::function<void(::grpc::Status)>) override;
      void GetCollTuningParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* response, std::function<void(::grpc::Status)>) override;
      void GetCollTuningParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq* request, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCollTuningParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* response, std::function<void(::grpc::Status)>) override;
      void GetSafetyLimitConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* response, std::function<void(::grpc::Status)>) override;
      void GetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetSafetyLimitConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* response, std::function<void(::grpc::Status)>) override;
      void SetSafetyLimitConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* response, std::function<void(::grpc::Status)>) override;
      void SetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetSafetyLimitConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* response, std::function<void(::grpc::Status)>) override;
      void GetSafetyStopConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* response, std::function<void(::grpc::Status)>) override;
      void GetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetSafetyStopConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* response, std::function<void(::grpc::Status)>) override;
      void SetSafetyStopConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* response, std::function<void(::grpc::Status)>) override;
      void SetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetSafetyStopConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetEL5001(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5001Req* request, ::IndyFramework::Protobuf::Control::GetEL5001Res* response, std::function<void(::grpc::Status)>) override;
      void GetEL5001(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEL5001Res* response, std::function<void(::grpc::Status)>) override;
      void GetEL5001(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5001Req* request, ::IndyFramework::Protobuf::Control::GetEL5001Res* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetEL5001(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEL5001Res* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetEL5101(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5101Req* request, ::IndyFramework::Protobuf::Control::GetEL5101Res* response, std::function<void(::grpc::Status)>) override;
      void GetEL5101(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEL5101Res* response, std::function<void(::grpc::Status)>) override;
      void GetEL5101(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5101Req* request, ::IndyFramework::Protobuf::Control::GetEL5101Res* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetEL5101(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::IndyFramework::Protobuf::Control::GetEL5101Res* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveJRes>* AsyncAMoveJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveJRes>* PrepareAsyncAMoveJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveJTRes>* AsyncAMoveJTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveJTRes>* PrepareAsyncAMoveJTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveJTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveLRes>* AsyncAMoveLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveLRes>* PrepareAsyncAMoveLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveLTRes>* AsyncAMoveLTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveLTRes>* PrepareAsyncAMoveLTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveLTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveCRes>* AsyncAMoveCRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveCRes>* PrepareAsyncAMoveCRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveCTRes>* AsyncAMoveCTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMoveCTRes>* PrepareAsyncAMoveCTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMoveCTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitIORes>* AsyncAWaitIORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitIOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitIORes>* PrepareAsyncAWaitIORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitIOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitTimeRes>* AsyncAWaitTimeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTimeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitTimeRes>* PrepareAsyncAWaitTimeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTimeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitProgressRes>* AsyncAWaitProgressRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitProgressReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitProgressRes>* PrepareAsyncAWaitProgressRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitProgressReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitTrajRes>* AsyncAWaitTrajRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTrajReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitTrajRes>* PrepareAsyncAWaitTrajRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitTrajReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitRadiusRes>* AsyncAWaitRadiusRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AWaitRadiusRes>* PrepareAsyncAWaitRadiusRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMotionStopRes>* AsyncAMotionStopRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMotionStopReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::AMotionStopRes>* PrepareAsyncAMotionStopRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::AMotionStopReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSJRes>* AsyncMoveSJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSJRes>* PrepareAsyncMoveSJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSJTRes>* AsyncMoveSJTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSJTRes>* PrepareAsyncMoveSJTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSJTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSLRes>* AsyncMoveSLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSLRes>* PrepareAsyncMoveSLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSLTRes>* AsyncMoveSLTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSLTRes>* PrepareAsyncMoveSLTRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSLTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSpiralRes>* AsyncMoveSpiralRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSpiralReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::MoveSpiralRes>* PrepareAsyncMoveSpiralRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::MoveSpiralReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetRefFrameRes>* AsyncSetRefFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetRefFrameRes>* PrepareAsyncSetRefFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>* AsyncSetRefFramePlanarRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>* PrepareAsyncSetRefFramePlanarRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetToolFrameRes>* AsyncSetToolFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetToolFrameRes>* PrepareAsyncSetToolFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>* AsyncSetSpeedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>* PrepareAsyncSetSpeedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>* AsyncSetCommandSpeedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>* PrepareAsyncSetCommandSpeedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::RebootRes>* AsyncRebootRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RebootReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::RebootRes>* PrepareAsyncRebootRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RebootReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::RecoverRes>* AsyncRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RecoverReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::RecoverRes>* PrepareAsyncRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::RecoverReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::StopRes>* AsyncStopRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::StopReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::StopRes>* PrepareAsyncStopRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::StopReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::PauseRes>* AsyncPauseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::PauseReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::PauseRes>* PrepareAsyncPauseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::PauseReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::ResumeRes>* AsyncResumeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ResumeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::ResumeRes>* PrepareAsyncResumeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ResumeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::BrakeRes>* AsyncBrakeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::BrakeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::BrakeRes>* PrepareAsyncBrakeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::BrakeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::ServoRes>* AsyncServoRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ServoReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::ServoRes>* PrepareAsyncServoRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::ServoReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>* AsyncSetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>* PrepareAsyncSetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>* AsyncGetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>* PrepareAsyncGetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SimulationModeRes>* AsyncSimulationModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SimulationModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SimulationModeRes>* PrepareAsyncSimulationModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SimulationModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>* AsyncDirectTeachingModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>* PrepareAsyncDirectTeachingModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetRTControlDataRes>* AsyncGetRTControlDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetRTControlDataRes>* PrepareAsyncGetRTControlDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetIODataRes>* AsyncGetIODataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetIODataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetIODataRes>* PrepareAsyncGetIODataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetIODataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCoreDataRes>* AsyncGetCoreDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCoreDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCoreDataRes>* PrepareAsyncGetCoreDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCoreDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>* AsyncGetSystemInfoDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>* PrepareAsyncGetSystemInfoDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetMotionDataRes>* AsyncGetMotionDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMotionDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetMotionDataRes>* PrepareAsyncGetMotionDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMotionDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetStateDataRes>* AsyncGetStateDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetStateDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetStateDataRes>* PrepareAsyncGetStateDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetStateDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetViolationDataRes>* AsyncGetViolationDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetViolationDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetViolationDataRes>* PrepareAsyncGetViolationDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetViolationDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetProgramStateRes>* AsyncSetProgramStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetProgramStateReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetProgramStateRes>* PrepareAsyncSetProgramStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetProgramStateReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::InverseKinematicsRes>* AsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::InverseKinematicsRes>* PrepareAsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>* AsyncCheckAproachRetractValidRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>* PrepareAsyncCheckAproachRetractValidRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetPalletPointListRes>* AsyncGetPalletPointListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetPalletPointListRes>* PrepareAsyncGetPalletPointListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>* AsyncCalculateRelativePoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>* PrepareAsyncCalculateRelativePoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>* AsyncCalculateCurrentPoseRelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>* PrepareAsyncCalculateCurrentPoseRelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetDIRes>* AsyncGetDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetDIRes>* PrepareAsyncGetDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetDIRes>* AsyncSetDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetDIRes>* PrepareAsyncSetDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetDORes>* AsyncSetDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetDORes>* PrepareAsyncSetDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetDOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetDORes>* AsyncGetDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetDORes>* PrepareAsyncGetDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetDOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAIRes>* AsyncGetAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAIRes>* PrepareAsyncGetAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAIRes>* AsyncSetAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAIRes>* PrepareAsyncSetAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAORes>* AsyncGetAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetAORes>* PrepareAsyncGetAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetAOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAORes>* AsyncSetAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetAORes>* PrepareAsyncSetAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetAOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndDIRes>* AsyncGetEndDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndDIRes>* PrepareAsyncGetEndDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndDIRes>* AsyncSetEndDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndDIRes>* PrepareAsyncSetEndDIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndDORes>* AsyncSetEndDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndDORes>* PrepareAsyncSetEndDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndDOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndDORes>* AsyncGetEndDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndDORes>* PrepareAsyncGetEndDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndDOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndAIRes>* AsyncGetEndAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndAIRes>* PrepareAsyncGetEndAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndAIRes>* AsyncSetEndAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndAIRes>* PrepareAsyncSetEndAIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAIReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndAORes>* AsyncGetEndAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEndAORes>* PrepareAsyncGetEndAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEndAOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndAORes>* AsyncSetEndAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetEndAORes>* PrepareAsyncSetEndAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetEndAOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetJointControlGainRes>* AsyncSetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetJointControlGainRes>* PrepareAsyncSetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetJointControlGainRes>* AsyncGetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetJointControlGainRes>* PrepareAsyncGetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>* AsyncSetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>* PrepareAsyncSetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>* AsyncGetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>* PrepareAsyncGetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>* AsyncSetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>* PrepareAsyncSetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>* AsyncGetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>* PrepareAsyncGetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetFricCompRes>* AsyncSetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetFricCompReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetFricCompRes>* PrepareAsyncSetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetFricCompReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetFricCompRes>* AsyncGetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetFricCompReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetFricCompRes>* PrepareAsyncGetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetFricCompReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetMountPosRes>* AsyncSetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetMountPosReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetMountPosRes>* PrepareAsyncSetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetMountPosReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetMountPosRes>* AsyncGetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMountPosReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetMountPosRes>* PrepareAsyncGetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetMountPosReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetToolPropertyRes>* AsyncSetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetToolPropertyRes>* PrepareAsyncSetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetToolPropertyRes>* AsyncGetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetToolPropertyRes>* PrepareAsyncGetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>* AsyncSetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>* PrepareAsyncSetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>* AsyncGetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>* PrepareAsyncGetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollSensParamRes>* AsyncSetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollSensParamRes>* PrepareAsyncSetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollSensParamRes>* AsyncGetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollSensParamRes>* PrepareAsyncGetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollPolicyRes>* AsyncSetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetCollPolicyRes>* PrepareAsyncSetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollPolicyRes>* AsyncGetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollPolicyRes>* PrepareAsyncGetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>* AsyncGetCollTuningParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>* PrepareAsyncGetCollTuningParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>* AsyncGetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>* PrepareAsyncGetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>* AsyncSetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>* PrepareAsyncSetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>* AsyncGetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>* PrepareAsyncGetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>* AsyncSetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>* PrepareAsyncSetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEL5001Res>* AsyncGetEL5001Raw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5001Req& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEL5001Res>* PrepareAsyncGetEL5001Raw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5001Req& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEL5101Res>* AsyncGetEL5101Raw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5101Req& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::Control::GetEL5101Res>* PrepareAsyncGetEL5101Raw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::Control::GetEL5101Req& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_AMoveJ_;
    const ::grpc::internal::RpcMethod rpcmethod_AMoveJT_;
    const ::grpc::internal::RpcMethod rpcmethod_AMoveL_;
    const ::grpc::internal::RpcMethod rpcmethod_AMoveLT_;
    const ::grpc::internal::RpcMethod rpcmethod_AMoveC_;
    const ::grpc::internal::RpcMethod rpcmethod_AMoveCT_;
    const ::grpc::internal::RpcMethod rpcmethod_AWaitIO_;
    const ::grpc::internal::RpcMethod rpcmethod_AWaitTime_;
    const ::grpc::internal::RpcMethod rpcmethod_AWaitProgress_;
    const ::grpc::internal::RpcMethod rpcmethod_AWaitTraj_;
    const ::grpc::internal::RpcMethod rpcmethod_AWaitRadius_;
    const ::grpc::internal::RpcMethod rpcmethod_AMotionStop_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveSJ_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveSJT_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveSL_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveSLT_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveSpiral_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRefFrame_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRefFramePlanar_;
    const ::grpc::internal::RpcMethod rpcmethod_SetToolFrame_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSpeedRatio_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCommandSpeedRatio_;
    const ::grpc::internal::RpcMethod rpcmethod_Reboot_;
    const ::grpc::internal::RpcMethod rpcmethod_Recover_;
    const ::grpc::internal::RpcMethod rpcmethod_Stop_;
    const ::grpc::internal::RpcMethod rpcmethod_Pause_;
    const ::grpc::internal::RpcMethod rpcmethod_Resume_;
    const ::grpc::internal::RpcMethod rpcmethod_Brake_;
    const ::grpc::internal::RpcMethod rpcmethod_Servo_;
    const ::grpc::internal::RpcMethod rpcmethod_SetAutoServoOff_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAutoServoOff_;
    const ::grpc::internal::RpcMethod rpcmethod_SimulationMode_;
    const ::grpc::internal::RpcMethod rpcmethod_DirectTeachingMode_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRTControlData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetIOData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCoreData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSystemInfoData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMotionData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStateData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetViolationData_;
    const ::grpc::internal::RpcMethod rpcmethod_SetProgramState_;
    const ::grpc::internal::RpcMethod rpcmethod_InverseKinematics_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckAproachRetractValid_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPalletPointList_;
    const ::grpc::internal::RpcMethod rpcmethod_CalculateRelativePose_;
    const ::grpc::internal::RpcMethod rpcmethod_CalculateCurrentPoseRel_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDI_;
    const ::grpc::internal::RpcMethod rpcmethod_SetDI_;
    const ::grpc::internal::RpcMethod rpcmethod_SetDO_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDO_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAI_;
    const ::grpc::internal::RpcMethod rpcmethod_SetAI_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAO_;
    const ::grpc::internal::RpcMethod rpcmethod_SetAO_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEndDI_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEndDI_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEndDO_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEndDO_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEndAI_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEndAI_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEndAO_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEndAO_;
    const ::grpc::internal::RpcMethod rpcmethod_SetJointControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_GetJointControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_SetTaskControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTaskControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_SetImpedanceControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_GetImpedanceControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_SetFricComp_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFricComp_;
    const ::grpc::internal::RpcMethod rpcmethod_SetMountPos_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMountPos_;
    const ::grpc::internal::RpcMethod rpcmethod_SetToolProperty_;
    const ::grpc::internal::RpcMethod rpcmethod_GetToolProperty_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCollSensLevel_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCollSensLevel_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCollSensParam_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCollSensParam_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCollPolicy_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCollPolicy_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCollTuningParam_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSafetyLimitConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSafetyLimitConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSafetyStopConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSafetyStopConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEL5001_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEL5101_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Default Motion
    virtual ::grpc::Status AMoveJ(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::AMoveJReq* request, ::IndyFramework::Protobuf::Control::AMoveJRes* response);
    virtual ::grpc::Status AMoveJT(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::AMoveJTReq* request, ::IndyFramework::Protobuf::Control::AMoveJTRes* response);
    virtual ::grpc::Status AMoveL(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::AMoveLReq* request, ::IndyFramework::Protobuf::Control::AMoveLRes* response);
    virtual ::grpc::Status AMoveLT(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::AMoveLTReq* request, ::IndyFramework::Protobuf::Control::AMoveLTRes* response);
    virtual ::grpc::Status AMoveC(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::AMoveCReq* request, ::IndyFramework::Protobuf::Control::AMoveCRes* response);
    virtual ::grpc::Status AMoveCT(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::AMoveCTReq* request, ::IndyFramework::Protobuf::Control::AMoveCTRes* response);
    virtual ::grpc::Status AWaitIO(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::AWaitIOReq* request, ::IndyFramework::Protobuf::Control::AWaitIORes* response);
    virtual ::grpc::Status AWaitTime(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::AWaitTimeReq* request, ::IndyFramework::Protobuf::Control::AWaitTimeRes* response);
    virtual ::grpc::Status AWaitProgress(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::AWaitProgressReq* request, ::IndyFramework::Protobuf::Control::AWaitProgressRes* response);
    virtual ::grpc::Status AWaitTraj(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::AWaitTrajReq* request, ::IndyFramework::Protobuf::Control::AWaitTrajRes* response);
    virtual ::grpc::Status AWaitRadius(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq* request, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* response);
    virtual ::grpc::Status AMotionStop(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::AMotionStopReq* request, ::IndyFramework::Protobuf::Control::AMotionStopRes* response);
    // Advanced Motion
    virtual ::grpc::Status MoveSJ(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::MoveSJReq* request, ::IndyFramework::Protobuf::Control::MoveSJRes* response);
    virtual ::grpc::Status MoveSJT(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::MoveSJTReq* request, ::IndyFramework::Protobuf::Control::MoveSJTRes* response);
    virtual ::grpc::Status MoveSL(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::MoveSLReq* request, ::IndyFramework::Protobuf::Control::MoveSLRes* response);
    virtual ::grpc::Status MoveSLT(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::MoveSLTReq* request, ::IndyFramework::Protobuf::Control::MoveSLTRes* response);
    virtual ::grpc::Status MoveSpiral(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::MoveSpiralReq* request, ::IndyFramework::Protobuf::Control::MoveSpiralRes* response);
    // Motion Config
    virtual ::grpc::Status SetRefFrame(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetRefFrameReq* request, ::IndyFramework::Protobuf::Control::SetRefFrameRes* response);
    virtual ::grpc::Status SetRefFramePlanar(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq* request, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* response);
    virtual ::grpc::Status SetToolFrame(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetToolFrameReq* request, ::IndyFramework::Protobuf::Control::SetToolFrameRes* response);
    virtual ::grpc::Status SetSpeedRatio(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq* request, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* response);
    virtual ::grpc::Status SetCommandSpeedRatio(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq* request, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* response);
    // ---------------------------------------------------------------- //
    // Command
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status Reboot(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::RebootReq* request, ::IndyFramework::Protobuf::Control::RebootRes* response);
    virtual ::grpc::Status Recover(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::RecoverReq* request, ::IndyFramework::Protobuf::Control::RecoverRes* response);
    virtual ::grpc::Status Stop(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::StopReq* request, ::IndyFramework::Protobuf::Control::StopRes* response);
    virtual ::grpc::Status Pause(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::PauseReq* request, ::IndyFramework::Protobuf::Control::PauseRes* response);
    virtual ::grpc::Status Resume(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::ResumeReq* request, ::IndyFramework::Protobuf::Control::ResumeRes* response);
    virtual ::grpc::Status Brake(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::BrakeReq* request, ::IndyFramework::Protobuf::Control::BrakeRes* response);
    virtual ::grpc::Status Servo(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::ServoReq* request, ::IndyFramework::Protobuf::Control::ServoRes* response);
    virtual ::grpc::Status SetAutoServoOff(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq* request, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* response);
    virtual ::grpc::Status GetAutoServoOff(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq* request, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* response);
    virtual ::grpc::Status SimulationMode(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SimulationModeReq* request, ::IndyFramework::Protobuf::Control::SimulationModeRes* response);
    virtual ::grpc::Status DirectTeachingMode(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq* request, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* response);
    // ---------------------------------------------------------------- //
    // Data
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status GetRTControlData(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq* request, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* response);
    virtual ::grpc::Status GetIOData(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetIODataReq* request, ::IndyFramework::Protobuf::Control::GetIODataRes* response);
    virtual ::grpc::Status GetCoreData(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetCoreDataReq* request, ::IndyFramework::Protobuf::Control::GetCoreDataRes* response);
    virtual ::grpc::Status GetSystemInfoData(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq* request, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* response);
    virtual ::grpc::Status GetMotionData(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetMotionDataReq* request, ::IndyFramework::Protobuf::Control::GetMotionDataRes* response);
    virtual ::grpc::Status GetStateData(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetStateDataReq* request, ::IndyFramework::Protobuf::Control::GetStateDataRes* response);
    virtual ::grpc::Status GetViolationData(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetViolationDataReq* request, ::IndyFramework::Protobuf::Control::GetViolationDataRes* response);
    virtual ::grpc::Status SetProgramState(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetProgramStateReq* request, ::IndyFramework::Protobuf::Control::SetProgramStateRes* response);
    // ---------------------------------------------------------------- //
    // Utility
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status InverseKinematics(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq* request, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* response);
    virtual ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq* request, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* response);
    virtual ::grpc::Status GetPalletPointList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq* request, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* response);
    virtual ::grpc::Status CalculateRelativePose(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq* request, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* response);
    virtual ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq* request, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* response);
    // ---------------------------------------------------------------- //
    // DIO
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status GetDI(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetDIReq* request, ::IndyFramework::Protobuf::Control::GetDIRes* response);
    virtual ::grpc::Status SetDI(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetDIReq* request, ::IndyFramework::Protobuf::Control::SetDIRes* response);
    virtual ::grpc::Status SetDO(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetDOReq* request, ::IndyFramework::Protobuf::Control::SetDORes* response);
    virtual ::grpc::Status GetDO(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetDOReq* request, ::IndyFramework::Protobuf::Control::GetDORes* response);
    virtual ::grpc::Status GetAI(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetAIReq* request, ::IndyFramework::Protobuf::Control::GetAIRes* response);
    virtual ::grpc::Status SetAI(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetAIReq* request, ::IndyFramework::Protobuf::Control::SetAIRes* response);
    virtual ::grpc::Status GetAO(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetAOReq* request, ::IndyFramework::Protobuf::Control::GetAORes* response);
    virtual ::grpc::Status SetAO(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetAOReq* request, ::IndyFramework::Protobuf::Control::SetAORes* response);
    virtual ::grpc::Status GetEndDI(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetEndDIReq* request, ::IndyFramework::Protobuf::Control::GetEndDIRes* response);
    virtual ::grpc::Status SetEndDI(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetEndDIReq* request, ::IndyFramework::Protobuf::Control::SetEndDIRes* response);
    virtual ::grpc::Status SetEndDO(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetEndDOReq* request, ::IndyFramework::Protobuf::Control::SetEndDORes* response);
    virtual ::grpc::Status GetEndDO(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetEndDOReq* request, ::IndyFramework::Protobuf::Control::GetEndDORes* response);
    virtual ::grpc::Status GetEndAI(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetEndAIReq* request, ::IndyFramework::Protobuf::Control::GetEndAIRes* response);
    virtual ::grpc::Status SetEndAI(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetEndAIReq* request, ::IndyFramework::Protobuf::Control::SetEndAIRes* response);
    virtual ::grpc::Status GetEndAO(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetEndAOReq* request, ::IndyFramework::Protobuf::Control::GetEndAORes* response);
    virtual ::grpc::Status SetEndAO(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetEndAOReq* request, ::IndyFramework::Protobuf::Control::SetEndAORes* response);
    // ---------------------------------------------------------------- //
    // Config Setting
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetJointControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq* request, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* response);
    virtual ::grpc::Status GetJointControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq* request, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* response);
    virtual ::grpc::Status SetTaskControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq* request, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* response);
    virtual ::grpc::Status GetTaskControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq* request, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* response);
    virtual ::grpc::Status SetImpedanceControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* response);
    virtual ::grpc::Status GetImpedanceControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* response);
    virtual ::grpc::Status SetFricComp(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetFricCompReq* request, ::IndyFramework::Protobuf::Control::SetFricCompRes* response);
    virtual ::grpc::Status GetFricComp(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetFricCompReq* request, ::IndyFramework::Protobuf::Control::GetFricCompRes* response);
    virtual ::grpc::Status SetMountPos(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetMountPosReq* request, ::IndyFramework::Protobuf::Control::SetMountPosRes* response);
    virtual ::grpc::Status GetMountPos(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetMountPosReq* request, ::IndyFramework::Protobuf::Control::GetMountPosRes* response);
    virtual ::grpc::Status SetToolProperty(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq* request, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* response);
    virtual ::grpc::Status GetToolProperty(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq* request, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* response);
    virtual ::grpc::Status SetCollSensLevel(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq* request, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* response);
    virtual ::grpc::Status GetCollSensLevel(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq* request, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* response);
    virtual ::grpc::Status SetCollSensParam(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq* request, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* response);
    virtual ::grpc::Status GetCollSensParam(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq* request, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* response);
    virtual ::grpc::Status SetCollPolicy(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq* request, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* response);
    virtual ::grpc::Status GetCollPolicy(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq* request, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* response);
    virtual ::grpc::Status GetCollTuningParam(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq* request, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* response);
    virtual ::grpc::Status GetSafetyLimitConfig(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* response);
    virtual ::grpc::Status SetSafetyLimitConfig(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* response);
    virtual ::grpc::Status GetSafetyStopConfig(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* response);
    virtual ::grpc::Status SetSafetyStopConfig(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* response);
    // beckhoff_conv
    virtual ::grpc::Status GetEL5001(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetEL5001Req* request, ::IndyFramework::Protobuf::Control::GetEL5001Res* response);
    virtual ::grpc::Status GetEL5101(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::Control::GetEL5101Req* request, ::IndyFramework::Protobuf::Control::GetEL5101Res* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_AMoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AMoveJ() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_AMoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveJReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveJRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAMoveJ(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::AMoveJReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::AMoveJRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AMoveJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AMoveJT() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_AMoveJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveJT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveJTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveJTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAMoveJT(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::AMoveJTReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::AMoveJTRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AMoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AMoveL() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_AMoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveLReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAMoveL(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::AMoveLReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::AMoveLRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AMoveLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AMoveLT() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_AMoveLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveLT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveLTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveLTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAMoveLT(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::AMoveLTReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::AMoveLTRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AMoveC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AMoveC() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_AMoveC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveC(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveCReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveCRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAMoveC(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::AMoveCReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::AMoveCRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AMoveCT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AMoveCT() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_AMoveCT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveCT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveCTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveCTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAMoveCT(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::AMoveCTReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::AMoveCTRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AWaitIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AWaitIO() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_AWaitIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitIO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitIOReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitIORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAWaitIO(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::AWaitIOReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::AWaitIORes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AWaitTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AWaitTime() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_AWaitTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitTime(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitTimeReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAWaitTime(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::AWaitTimeReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::AWaitTimeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AWaitProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AWaitProgress() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_AWaitProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitProgress(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitProgressReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitProgressRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAWaitProgress(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::AWaitProgressReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::AWaitProgressRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AWaitTraj : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AWaitTraj() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_AWaitTraj() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitTraj(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitTrajReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitTrajRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAWaitTraj(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::AWaitTrajReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::AWaitTrajRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AWaitRadius : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AWaitRadius() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_AWaitRadius() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitRadius(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAWaitRadius(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::AWaitRadiusReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::AWaitRadiusRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AMotionStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AMotionStop() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_AMotionStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMotionStop(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMotionStopReq* /*request*/, ::IndyFramework::Protobuf::Control::AMotionStopRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAMotionStop(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::AMotionStopReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::AMotionStopRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveSJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveSJ() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_MoveSJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSJReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSJRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveSJ(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::MoveSJReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::MoveSJRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveSJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveSJT() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_MoveSJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSJT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSJTReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSJTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveSJT(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::MoveSJTReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::MoveSJTRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveSL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveSL() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_MoveSL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSLReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveSL(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::MoveSLReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::MoveSLRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveSLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveSLT() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_MoveSLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSLT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSLTReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSLTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveSLT(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::MoveSLTReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::MoveSLTRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveSpiral : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveSpiral() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_MoveSpiral() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSpiral(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSpiralReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSpiralRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveSpiral(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::MoveSpiralReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::MoveSpiralRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRefFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetRefFrame() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_SetRefFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetRefFrameReq* /*request*/, ::IndyFramework::Protobuf::Control::SetRefFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRefFrame(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetRefFrameReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetRefFrameRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRefFramePlanar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetRefFramePlanar() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_SetRefFramePlanar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFramePlanar(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq* /*request*/, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRefFramePlanar(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetToolFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetToolFrame() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_SetToolFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetToolFrameReq* /*request*/, ::IndyFramework::Protobuf::Control::SetToolFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetToolFrame(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetToolFrameReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetToolFrameRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSpeedRatio() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_SetSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSpeedRatio(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetSpeedRatioReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCommandSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCommandSpeedRatio() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_SetCommandSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCommandSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCommandSpeedRatio(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Reboot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Reboot() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_Reboot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reboot(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::RebootReq* /*request*/, ::IndyFramework::Protobuf::Control::RebootRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReboot(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::RebootReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::RebootRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Recover() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::RecoverReq* /*request*/, ::IndyFramework::Protobuf::Control::RecoverRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecover(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::RecoverReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::RecoverRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Stop() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::StopReq* /*request*/, ::IndyFramework::Protobuf::Control::StopRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStop(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::StopReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::StopRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Pause() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_Pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pause(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::PauseReq* /*request*/, ::IndyFramework::Protobuf::Control::PauseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPause(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::PauseReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::PauseRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Resume() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_Resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resume(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::ResumeReq* /*request*/, ::IndyFramework::Protobuf::Control::ResumeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResume(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::ResumeReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::ResumeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Brake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Brake() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_Brake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Brake(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::BrakeReq* /*request*/, ::IndyFramework::Protobuf::Control::BrakeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBrake(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::BrakeReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::BrakeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Servo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Servo() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_Servo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Servo(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::ServoReq* /*request*/, ::IndyFramework::Protobuf::Control::ServoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServo(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::ServoReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::ServoRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetAutoServoOff() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_SetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAutoServoOff(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetAutoServoOffReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAutoServoOff() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_GetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAutoServoOff(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetAutoServoOffReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SimulationMode() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_SimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SimulationMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SimulationModeReq* /*request*/, ::IndyFramework::Protobuf::Control::SimulationModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSimulationMode(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SimulationModeReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SimulationModeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DirectTeachingMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DirectTeachingMode() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_DirectTeachingMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DirectTeachingMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDirectTeachingMode(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::DirectTeachingModeReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRTControlData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRTControlData() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_GetRTControlData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRTControlData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRTControlData(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetRTControlDataReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetRTControlDataRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetIOData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetIOData() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_GetIOData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetIODataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetIODataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIOData(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetIODataReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetIODataRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCoreData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCoreData() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_GetCoreData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCoreData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCoreDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCoreDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCoreData(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetCoreDataReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetCoreDataRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSystemInfoData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSystemInfoData() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_GetSystemInfoData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSystemInfoData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSystemInfoData(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMotionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMotionData() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_GetMotionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMotionData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetMotionDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetMotionDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMotionData(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetMotionDataReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetMotionDataRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStateData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStateData() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_GetStateData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetStateDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetStateDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateData(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetStateDataReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetStateDataRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetViolationData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetViolationData() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_GetViolationData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetViolationData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetViolationDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetViolationDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetViolationData(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetViolationDataReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetViolationDataRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetProgramState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetProgramState() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_SetProgramState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProgramState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetProgramStateReq* /*request*/, ::IndyFramework::Protobuf::Control::SetProgramStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetProgramState(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetProgramStateReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetProgramStateRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq* /*request*/, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInverseKinematics(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::InverseKinematicsReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::InverseKinematicsRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq* /*request*/, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckAproachRetractValid(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPalletPointList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetPalletPointListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetPalletPointListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq* /*request*/, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateRelativePose(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq* /*request*/, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateCurrentPoseRel(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDI() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetDIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDI(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetDIReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetDIRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetDI() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_SetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetDIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDI(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetDIReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetDIRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetDO() {
      ::grpc::Service::MarkMethodAsync(48);
    }
    ~WithAsyncMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetDOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDO(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetDOReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetDORes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDO() {
      ::grpc::Service::MarkMethodAsync(49);
    }
    ~WithAsyncMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetDOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDO(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetDOReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetDORes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAI() {
      ::grpc::Service::MarkMethodAsync(50);
    }
    ~WithAsyncMethod_GetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAI(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetAIReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetAIRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetAI() {
      ::grpc::Service::MarkMethodAsync(51);
    }
    ~WithAsyncMethod_SetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAI(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetAIReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetAIRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAO() {
      ::grpc::Service::MarkMethodAsync(52);
    }
    ~WithAsyncMethod_GetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAO(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetAOReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetAORes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetAO() {
      ::grpc::Service::MarkMethodAsync(53);
    }
    ~WithAsyncMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAO(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetAOReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetAORes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEndDI() {
      ::grpc::Service::MarkMethodAsync(54);
    }
    ~WithAsyncMethod_GetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndDIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndDI(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetEndDIReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetEndDIRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEndDI() {
      ::grpc::Service::MarkMethodAsync(55);
    }
    ~WithAsyncMethod_SetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndDIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndDI(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetEndDIReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetEndDIRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEndDO() {
      ::grpc::Service::MarkMethodAsync(56);
    }
    ~WithAsyncMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndDOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndDO(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetEndDOReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetEndDORes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEndDO() {
      ::grpc::Service::MarkMethodAsync(57);
    }
    ~WithAsyncMethod_GetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndDOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndDO(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetEndDOReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetEndDORes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEndAI() {
      ::grpc::Service::MarkMethodAsync(58);
    }
    ~WithAsyncMethod_GetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndAIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndAI(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetEndAIReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetEndAIRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEndAI() {
      ::grpc::Service::MarkMethodAsync(59);
    }
    ~WithAsyncMethod_SetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndAIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndAI(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetEndAIReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetEndAIRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEndAO() {
      ::grpc::Service::MarkMethodAsync(60);
    }
    ~WithAsyncMethod_GetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndAOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndAO(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetEndAOReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetEndAORes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEndAO() {
      ::grpc::Service::MarkMethodAsync(61);
    }
    ~WithAsyncMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndAOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndAO(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetEndAOReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetEndAORes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetJointControlGain() {
      ::grpc::Service::MarkMethodAsync(62);
    }
    ~WithAsyncMethod_SetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetJointControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetJointControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetJointControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetJointControlGain() {
      ::grpc::Service::MarkMethodAsync(63);
    }
    ~WithAsyncMethod_GetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetJointControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetJointControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetTaskControlGain() {
      ::grpc::Service::MarkMethodAsync(64);
    }
    ~WithAsyncMethod_SetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTaskControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetTaskControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTaskControlGain() {
      ::grpc::Service::MarkMethodAsync(65);
    }
    ~WithAsyncMethod_GetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTaskControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetTaskControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetImpedanceControlGain() {
      ::grpc::Service::MarkMethodAsync(66);
    }
    ~WithAsyncMethod_SetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetImpedanceControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetImpedanceControlGain() {
      ::grpc::Service::MarkMethodAsync(67);
    }
    ~WithAsyncMethod_GetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetImpedanceControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(67, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetFricComp() {
      ::grpc::Service::MarkMethodAsync(68);
    }
    ~WithAsyncMethod_SetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetFricCompReq* /*request*/, ::IndyFramework::Protobuf::Control::SetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetFricComp(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetFricCompReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetFricCompRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(68, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFricComp() {
      ::grpc::Service::MarkMethodAsync(69);
    }
    ~WithAsyncMethod_GetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetFricCompReq* /*request*/, ::IndyFramework::Protobuf::Control::GetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFricComp(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetFricCompReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetFricCompRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(69, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetMountPos() {
      ::grpc::Service::MarkMethodAsync(70);
    }
    ~WithAsyncMethod_SetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetMountPosReq* /*request*/, ::IndyFramework::Protobuf::Control::SetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMountPos(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetMountPosReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetMountPosRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(70, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMountPos() {
      ::grpc::Service::MarkMethodAsync(71);
    }
    ~WithAsyncMethod_GetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetMountPosReq* /*request*/, ::IndyFramework::Protobuf::Control::GetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMountPos(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetMountPosReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetMountPosRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(71, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetToolProperty() {
      ::grpc::Service::MarkMethodAsync(72);
    }
    ~WithAsyncMethod_SetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetToolProperty(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetToolPropertyReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetToolPropertyRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(72, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetToolProperty() {
      ::grpc::Service::MarkMethodAsync(73);
    }
    ~WithAsyncMethod_GetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetToolProperty(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetToolPropertyReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetToolPropertyRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(73, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCollSensLevel() {
      ::grpc::Service::MarkMethodAsync(74);
    }
    ~WithAsyncMethod_SetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCollSensLevel(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetCollSensLevelReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(74, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCollSensLevel() {
      ::grpc::Service::MarkMethodAsync(75);
    }
    ~WithAsyncMethod_GetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollSensLevel(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetCollSensLevelReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(75, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCollSensParam() {
      ::grpc::Service::MarkMethodAsync(76);
    }
    ~WithAsyncMethod_SetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCollSensParam(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetCollSensParamReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetCollSensParamRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(76, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCollSensParam() {
      ::grpc::Service::MarkMethodAsync(77);
    }
    ~WithAsyncMethod_GetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollSensParam(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetCollSensParamReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetCollSensParamRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(77, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCollPolicy() {
      ::grpc::Service::MarkMethodAsync(78);
    }
    ~WithAsyncMethod_SetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCollPolicy(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetCollPolicyReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetCollPolicyRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(78, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCollPolicy() {
      ::grpc::Service::MarkMethodAsync(79);
    }
    ~WithAsyncMethod_GetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollPolicy(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetCollPolicyReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetCollPolicyRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(79, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCollTuningParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCollTuningParam() {
      ::grpc::Service::MarkMethodAsync(80);
    }
    ~WithAsyncMethod_GetCollTuningParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollTuningParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollTuningParam(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetCollTuningParamReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(80, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodAsync(81);
    }
    ~WithAsyncMethod_GetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyLimitConfig(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(81, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodAsync(82);
    }
    ~WithAsyncMethod_SetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSafetyLimitConfig(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(82, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSafetyStopConfig() {
      ::grpc::Service::MarkMethodAsync(83);
    }
    ~WithAsyncMethod_GetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyStopConfig(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(83, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSafetyStopConfig() {
      ::grpc::Service::MarkMethodAsync(84);
    }
    ~WithAsyncMethod_SetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSafetyStopConfig(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(84, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEL5001 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEL5001() {
      ::grpc::Service::MarkMethodAsync(85);
    }
    ~WithAsyncMethod_GetEL5001() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5001(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEL5001Req* /*request*/, ::IndyFramework::Protobuf::Control::GetEL5001Res* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEL5001(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetEL5001Req* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetEL5001Res>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(85, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEL5101 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEL5101() {
      ::grpc::Service::MarkMethodAsync(86);
    }
    ~WithAsyncMethod_GetEL5101() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5101(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEL5101Req* /*request*/, ::IndyFramework::Protobuf::Control::GetEL5101Res* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEL5101(::grpc::ServerContext* context, ::IndyFramework::Protobuf::Control::GetEL5101Req* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::Control::GetEL5101Res>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(86, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_AMoveJ<WithAsyncMethod_AMoveJT<WithAsyncMethod_AMoveL<WithAsyncMethod_AMoveLT<WithAsyncMethod_AMoveC<WithAsyncMethod_AMoveCT<WithAsyncMethod_AWaitIO<WithAsyncMethod_AWaitTime<WithAsyncMethod_AWaitProgress<WithAsyncMethod_AWaitTraj<WithAsyncMethod_AWaitRadius<WithAsyncMethod_AMotionStop<WithAsyncMethod_MoveSJ<WithAsyncMethod_MoveSJT<WithAsyncMethod_MoveSL<WithAsyncMethod_MoveSLT<WithAsyncMethod_MoveSpiral<WithAsyncMethod_SetRefFrame<WithAsyncMethod_SetRefFramePlanar<WithAsyncMethod_SetToolFrame<WithAsyncMethod_SetSpeedRatio<WithAsyncMethod_SetCommandSpeedRatio<WithAsyncMethod_Reboot<WithAsyncMethod_Recover<WithAsyncMethod_Stop<WithAsyncMethod_Pause<WithAsyncMethod_Resume<WithAsyncMethod_Brake<WithAsyncMethod_Servo<WithAsyncMethod_SetAutoServoOff<WithAsyncMethod_GetAutoServoOff<WithAsyncMethod_SimulationMode<WithAsyncMethod_DirectTeachingMode<WithAsyncMethod_GetRTControlData<WithAsyncMethod_GetIOData<WithAsyncMethod_GetCoreData<WithAsyncMethod_GetSystemInfoData<WithAsyncMethod_GetMotionData<WithAsyncMethod_GetStateData<WithAsyncMethod_GetViolationData<WithAsyncMethod_SetProgramState<WithAsyncMethod_InverseKinematics<WithAsyncMethod_CheckAproachRetractValid<WithAsyncMethod_GetPalletPointList<WithAsyncMethod_CalculateRelativePose<WithAsyncMethod_CalculateCurrentPoseRel<WithAsyncMethod_GetDI<WithAsyncMethod_SetDI<WithAsyncMethod_SetDO<WithAsyncMethod_GetDO<WithAsyncMethod_GetAI<WithAsyncMethod_SetAI<WithAsyncMethod_GetAO<WithAsyncMethod_SetAO<WithAsyncMethod_GetEndDI<WithAsyncMethod_SetEndDI<WithAsyncMethod_SetEndDO<WithAsyncMethod_GetEndDO<WithAsyncMethod_GetEndAI<WithAsyncMethod_SetEndAI<WithAsyncMethod_GetEndAO<WithAsyncMethod_SetEndAO<WithAsyncMethod_SetJointControlGain<WithAsyncMethod_GetJointControlGain<WithAsyncMethod_SetTaskControlGain<WithAsyncMethod_GetTaskControlGain<WithAsyncMethod_SetImpedanceControlGain<WithAsyncMethod_GetImpedanceControlGain<WithAsyncMethod_SetFricComp<WithAsyncMethod_GetFricComp<WithAsyncMethod_SetMountPos<WithAsyncMethod_GetMountPos<WithAsyncMethod_SetToolProperty<WithAsyncMethod_GetToolProperty<WithAsyncMethod_SetCollSensLevel<WithAsyncMethod_GetCollSensLevel<WithAsyncMethod_SetCollSensParam<WithAsyncMethod_GetCollSensParam<WithAsyncMethod_SetCollPolicy<WithAsyncMethod_GetCollPolicy<WithAsyncMethod_GetCollTuningParam<WithAsyncMethod_GetSafetyLimitConfig<WithAsyncMethod_SetSafetyLimitConfig<WithAsyncMethod_GetSafetyStopConfig<WithAsyncMethod_SetSafetyStopConfig<WithAsyncMethod_GetEL5001<WithAsyncMethod_GetEL5101<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AMoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AMoveJ() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveJReq, ::IndyFramework::Protobuf::Control::AMoveJRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::AMoveJReq* request,
                 ::IndyFramework::Protobuf::Control::AMoveJRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->AMoveJ(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_AMoveJ(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::AMoveJReq, ::IndyFramework::Protobuf::Control::AMoveJRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveJReq, ::IndyFramework::Protobuf::Control::AMoveJRes>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AMoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveJReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveJRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AMoveJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveJReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveJRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AMoveJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AMoveJT() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveJTReq, ::IndyFramework::Protobuf::Control::AMoveJTRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::AMoveJTReq* request,
                 ::IndyFramework::Protobuf::Control::AMoveJTRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->AMoveJT(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_AMoveJT(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::AMoveJTReq, ::IndyFramework::Protobuf::Control::AMoveJTRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveJTReq, ::IndyFramework::Protobuf::Control::AMoveJTRes>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AMoveJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveJT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveJTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveJTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AMoveJT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveJTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveJTRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AMoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AMoveL() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveLReq, ::IndyFramework::Protobuf::Control::AMoveLRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::AMoveLReq* request,
                 ::IndyFramework::Protobuf::Control::AMoveLRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->AMoveL(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_AMoveL(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::AMoveLReq, ::IndyFramework::Protobuf::Control::AMoveLRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveLReq, ::IndyFramework::Protobuf::Control::AMoveLRes>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AMoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveLReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AMoveL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveLReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveLRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AMoveLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AMoveLT() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveLTReq, ::IndyFramework::Protobuf::Control::AMoveLTRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::AMoveLTReq* request,
                 ::IndyFramework::Protobuf::Control::AMoveLTRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->AMoveLT(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_AMoveLT(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::AMoveLTReq, ::IndyFramework::Protobuf::Control::AMoveLTRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveLTReq, ::IndyFramework::Protobuf::Control::AMoveLTRes>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AMoveLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveLT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveLTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveLTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AMoveLT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveLTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveLTRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AMoveC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AMoveC() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveCReq, ::IndyFramework::Protobuf::Control::AMoveCRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::AMoveCReq* request,
                 ::IndyFramework::Protobuf::Control::AMoveCRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->AMoveC(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_AMoveC(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::AMoveCReq, ::IndyFramework::Protobuf::Control::AMoveCRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveCReq, ::IndyFramework::Protobuf::Control::AMoveCRes>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AMoveC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveC(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveCReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveCRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AMoveC(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveCReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveCRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AMoveCT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AMoveCT() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveCTReq, ::IndyFramework::Protobuf::Control::AMoveCTRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::AMoveCTReq* request,
                 ::IndyFramework::Protobuf::Control::AMoveCTRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->AMoveCT(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_AMoveCT(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::AMoveCTReq, ::IndyFramework::Protobuf::Control::AMoveCTRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveCTReq, ::IndyFramework::Protobuf::Control::AMoveCTRes>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AMoveCT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveCT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveCTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveCTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AMoveCT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveCTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveCTRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AWaitIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AWaitIO() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AWaitIOReq, ::IndyFramework::Protobuf::Control::AWaitIORes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::AWaitIOReq* request,
                 ::IndyFramework::Protobuf::Control::AWaitIORes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->AWaitIO(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_AWaitIO(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::AWaitIOReq, ::IndyFramework::Protobuf::Control::AWaitIORes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AWaitIOReq, ::IndyFramework::Protobuf::Control::AWaitIORes>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AWaitIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitIO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitIOReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitIORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AWaitIO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitIOReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitIORes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AWaitTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AWaitTime() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AWaitTimeReq, ::IndyFramework::Protobuf::Control::AWaitTimeRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::AWaitTimeReq* request,
                 ::IndyFramework::Protobuf::Control::AWaitTimeRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->AWaitTime(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_AWaitTime(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::AWaitTimeReq, ::IndyFramework::Protobuf::Control::AWaitTimeRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AWaitTimeReq, ::IndyFramework::Protobuf::Control::AWaitTimeRes>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AWaitTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitTime(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitTimeReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AWaitTime(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitTimeReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitTimeRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AWaitProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AWaitProgress() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AWaitProgressReq, ::IndyFramework::Protobuf::Control::AWaitProgressRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::AWaitProgressReq* request,
                 ::IndyFramework::Protobuf::Control::AWaitProgressRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->AWaitProgress(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_AWaitProgress(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::AWaitProgressReq, ::IndyFramework::Protobuf::Control::AWaitProgressRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AWaitProgressReq, ::IndyFramework::Protobuf::Control::AWaitProgressRes>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AWaitProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitProgress(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitProgressReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitProgressRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AWaitProgress(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitProgressReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitProgressRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AWaitTraj : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AWaitTraj() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AWaitTrajReq, ::IndyFramework::Protobuf::Control::AWaitTrajRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::AWaitTrajReq* request,
                 ::IndyFramework::Protobuf::Control::AWaitTrajRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->AWaitTraj(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_AWaitTraj(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::AWaitTrajReq, ::IndyFramework::Protobuf::Control::AWaitTrajRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AWaitTrajReq, ::IndyFramework::Protobuf::Control::AWaitTrajRes>*>(
          ::grpc::Service::experimental().GetHandler(9))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AWaitTraj() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitTraj(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitTrajReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitTrajRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AWaitTraj(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitTrajReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitTrajRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AWaitRadius : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AWaitRadius() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AWaitRadiusReq, ::IndyFramework::Protobuf::Control::AWaitRadiusRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::AWaitRadiusReq* request,
                 ::IndyFramework::Protobuf::Control::AWaitRadiusRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->AWaitRadius(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_AWaitRadius(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::AWaitRadiusReq, ::IndyFramework::Protobuf::Control::AWaitRadiusRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AWaitRadiusReq, ::IndyFramework::Protobuf::Control::AWaitRadiusRes>*>(
          ::grpc::Service::experimental().GetHandler(10))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AWaitRadius() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitRadius(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AWaitRadius(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AMotionStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AMotionStop() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AMotionStopReq, ::IndyFramework::Protobuf::Control::AMotionStopRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::AMotionStopReq* request,
                 ::IndyFramework::Protobuf::Control::AMotionStopRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->AMotionStop(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_AMotionStop(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::AMotionStopReq, ::IndyFramework::Protobuf::Control::AMotionStopRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::AMotionStopReq, ::IndyFramework::Protobuf::Control::AMotionStopRes>*>(
          ::grpc::Service::experimental().GetHandler(11))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AMotionStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMotionStop(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMotionStopReq* /*request*/, ::IndyFramework::Protobuf::Control::AMotionStopRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AMotionStop(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMotionStopReq* /*request*/, ::IndyFramework::Protobuf::Control::AMotionStopRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MoveSJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MoveSJ() {
      ::grpc::Service::experimental().MarkMethodCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::MoveSJReq, ::IndyFramework::Protobuf::Control::MoveSJRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::MoveSJReq* request,
                 ::IndyFramework::Protobuf::Control::MoveSJRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->MoveSJ(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_MoveSJ(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::MoveSJReq, ::IndyFramework::Protobuf::Control::MoveSJRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::MoveSJReq, ::IndyFramework::Protobuf::Control::MoveSJRes>*>(
          ::grpc::Service::experimental().GetHandler(12))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MoveSJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSJReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSJRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void MoveSJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSJReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSJRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MoveSJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MoveSJT() {
      ::grpc::Service::experimental().MarkMethodCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::MoveSJTReq, ::IndyFramework::Protobuf::Control::MoveSJTRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::MoveSJTReq* request,
                 ::IndyFramework::Protobuf::Control::MoveSJTRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->MoveSJT(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_MoveSJT(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::MoveSJTReq, ::IndyFramework::Protobuf::Control::MoveSJTRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::MoveSJTReq, ::IndyFramework::Protobuf::Control::MoveSJTRes>*>(
          ::grpc::Service::experimental().GetHandler(13))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MoveSJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSJT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSJTReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSJTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void MoveSJT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSJTReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSJTRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MoveSL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MoveSL() {
      ::grpc::Service::experimental().MarkMethodCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::MoveSLReq, ::IndyFramework::Protobuf::Control::MoveSLRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::MoveSLReq* request,
                 ::IndyFramework::Protobuf::Control::MoveSLRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->MoveSL(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_MoveSL(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::MoveSLReq, ::IndyFramework::Protobuf::Control::MoveSLRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::MoveSLReq, ::IndyFramework::Protobuf::Control::MoveSLRes>*>(
          ::grpc::Service::experimental().GetHandler(14))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MoveSL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSLReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void MoveSL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSLReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSLRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MoveSLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MoveSLT() {
      ::grpc::Service::experimental().MarkMethodCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::MoveSLTReq, ::IndyFramework::Protobuf::Control::MoveSLTRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::MoveSLTReq* request,
                 ::IndyFramework::Protobuf::Control::MoveSLTRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->MoveSLT(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_MoveSLT(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::MoveSLTReq, ::IndyFramework::Protobuf::Control::MoveSLTRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::MoveSLTReq, ::IndyFramework::Protobuf::Control::MoveSLTRes>*>(
          ::grpc::Service::experimental().GetHandler(15))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MoveSLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSLT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSLTReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSLTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void MoveSLT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSLTReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSLTRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MoveSpiral : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MoveSpiral() {
      ::grpc::Service::experimental().MarkMethodCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::MoveSpiralReq, ::IndyFramework::Protobuf::Control::MoveSpiralRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::MoveSpiralReq* request,
                 ::IndyFramework::Protobuf::Control::MoveSpiralRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->MoveSpiral(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_MoveSpiral(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::MoveSpiralReq, ::IndyFramework::Protobuf::Control::MoveSpiralRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::MoveSpiralReq, ::IndyFramework::Protobuf::Control::MoveSpiralRes>*>(
          ::grpc::Service::experimental().GetHandler(16))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MoveSpiral() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSpiral(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSpiralReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSpiralRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void MoveSpiral(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSpiralReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSpiralRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetRefFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetRefFrame() {
      ::grpc::Service::experimental().MarkMethodCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetRefFrameReq, ::IndyFramework::Protobuf::Control::SetRefFrameRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetRefFrameReq* request,
                 ::IndyFramework::Protobuf::Control::SetRefFrameRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetRefFrame(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetRefFrame(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetRefFrameReq, ::IndyFramework::Protobuf::Control::SetRefFrameRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetRefFrameReq, ::IndyFramework::Protobuf::Control::SetRefFrameRes>*>(
          ::grpc::Service::experimental().GetHandler(17))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetRefFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetRefFrameReq* /*request*/, ::IndyFramework::Protobuf::Control::SetRefFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRefFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetRefFrameReq* /*request*/, ::IndyFramework::Protobuf::Control::SetRefFrameRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetRefFramePlanar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetRefFramePlanar() {
      ::grpc::Service::experimental().MarkMethodCallback(18,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq* request,
                 ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetRefFramePlanar(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetRefFramePlanar(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>*>(
          ::grpc::Service::experimental().GetHandler(18))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetRefFramePlanar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFramePlanar(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq* /*request*/, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRefFramePlanar(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq* /*request*/, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetToolFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetToolFrame() {
      ::grpc::Service::experimental().MarkMethodCallback(19,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetToolFrameReq, ::IndyFramework::Protobuf::Control::SetToolFrameRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetToolFrameReq* request,
                 ::IndyFramework::Protobuf::Control::SetToolFrameRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetToolFrame(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetToolFrame(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetToolFrameReq, ::IndyFramework::Protobuf::Control::SetToolFrameRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetToolFrameReq, ::IndyFramework::Protobuf::Control::SetToolFrameRes>*>(
          ::grpc::Service::experimental().GetHandler(19))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetToolFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetToolFrameReq* /*request*/, ::IndyFramework::Protobuf::Control::SetToolFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetToolFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetToolFrameReq* /*request*/, ::IndyFramework::Protobuf::Control::SetToolFrameRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetSpeedRatio() {
      ::grpc::Service::experimental().MarkMethodCallback(20,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetSpeedRatioReq, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq* request,
                 ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetSpeedRatio(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetSpeedRatio(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetSpeedRatioReq, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetSpeedRatioReq, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>*>(
          ::grpc::Service::experimental().GetHandler(20))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetCommandSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetCommandSpeedRatio() {
      ::grpc::Service::experimental().MarkMethodCallback(21,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq* request,
                 ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetCommandSpeedRatio(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetCommandSpeedRatio(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>*>(
          ::grpc::Service::experimental().GetHandler(21))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetCommandSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCommandSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetCommandSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Reboot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Reboot() {
      ::grpc::Service::experimental().MarkMethodCallback(22,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::RebootReq, ::IndyFramework::Protobuf::Control::RebootRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::RebootReq* request,
                 ::IndyFramework::Protobuf::Control::RebootRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Reboot(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Reboot(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::RebootReq, ::IndyFramework::Protobuf::Control::RebootRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::RebootReq, ::IndyFramework::Protobuf::Control::RebootRes>*>(
          ::grpc::Service::experimental().GetHandler(22))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Reboot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reboot(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::RebootReq* /*request*/, ::IndyFramework::Protobuf::Control::RebootRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Reboot(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::RebootReq* /*request*/, ::IndyFramework::Protobuf::Control::RebootRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Recover() {
      ::grpc::Service::experimental().MarkMethodCallback(23,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::RecoverReq, ::IndyFramework::Protobuf::Control::RecoverRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::RecoverReq* request,
                 ::IndyFramework::Protobuf::Control::RecoverRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Recover(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Recover(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::RecoverReq, ::IndyFramework::Protobuf::Control::RecoverRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::RecoverReq, ::IndyFramework::Protobuf::Control::RecoverRes>*>(
          ::grpc::Service::experimental().GetHandler(23))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::RecoverReq* /*request*/, ::IndyFramework::Protobuf::Control::RecoverRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Recover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::RecoverReq* /*request*/, ::IndyFramework::Protobuf::Control::RecoverRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Stop() {
      ::grpc::Service::experimental().MarkMethodCallback(24,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::StopReq, ::IndyFramework::Protobuf::Control::StopRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::StopReq* request,
                 ::IndyFramework::Protobuf::Control::StopRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Stop(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Stop(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::StopReq, ::IndyFramework::Protobuf::Control::StopRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::StopReq, ::IndyFramework::Protobuf::Control::StopRes>*>(
          ::grpc::Service::experimental().GetHandler(24))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::StopReq* /*request*/, ::IndyFramework::Protobuf::Control::StopRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Stop(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::StopReq* /*request*/, ::IndyFramework::Protobuf::Control::StopRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Pause() {
      ::grpc::Service::experimental().MarkMethodCallback(25,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::PauseReq, ::IndyFramework::Protobuf::Control::PauseRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::PauseReq* request,
                 ::IndyFramework::Protobuf::Control::PauseRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Pause(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Pause(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::PauseReq, ::IndyFramework::Protobuf::Control::PauseRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::PauseReq, ::IndyFramework::Protobuf::Control::PauseRes>*>(
          ::grpc::Service::experimental().GetHandler(25))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pause(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::PauseReq* /*request*/, ::IndyFramework::Protobuf::Control::PauseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Pause(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::PauseReq* /*request*/, ::IndyFramework::Protobuf::Control::PauseRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Resume() {
      ::grpc::Service::experimental().MarkMethodCallback(26,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::ResumeReq, ::IndyFramework::Protobuf::Control::ResumeRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::ResumeReq* request,
                 ::IndyFramework::Protobuf::Control::ResumeRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Resume(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Resume(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::ResumeReq, ::IndyFramework::Protobuf::Control::ResumeRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::ResumeReq, ::IndyFramework::Protobuf::Control::ResumeRes>*>(
          ::grpc::Service::experimental().GetHandler(26))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resume(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::ResumeReq* /*request*/, ::IndyFramework::Protobuf::Control::ResumeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Resume(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::ResumeReq* /*request*/, ::IndyFramework::Protobuf::Control::ResumeRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Brake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Brake() {
      ::grpc::Service::experimental().MarkMethodCallback(27,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::BrakeReq, ::IndyFramework::Protobuf::Control::BrakeRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::BrakeReq* request,
                 ::IndyFramework::Protobuf::Control::BrakeRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Brake(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Brake(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::BrakeReq, ::IndyFramework::Protobuf::Control::BrakeRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::BrakeReq, ::IndyFramework::Protobuf::Control::BrakeRes>*>(
          ::grpc::Service::experimental().GetHandler(27))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Brake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Brake(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::BrakeReq* /*request*/, ::IndyFramework::Protobuf::Control::BrakeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Brake(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::BrakeReq* /*request*/, ::IndyFramework::Protobuf::Control::BrakeRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Servo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Servo() {
      ::grpc::Service::experimental().MarkMethodCallback(28,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::ServoReq, ::IndyFramework::Protobuf::Control::ServoRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::ServoReq* request,
                 ::IndyFramework::Protobuf::Control::ServoRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Servo(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Servo(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::ServoReq, ::IndyFramework::Protobuf::Control::ServoRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::ServoReq, ::IndyFramework::Protobuf::Control::ServoRes>*>(
          ::grpc::Service::experimental().GetHandler(28))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Servo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Servo(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::ServoReq* /*request*/, ::IndyFramework::Protobuf::Control::ServoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Servo(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::ServoReq* /*request*/, ::IndyFramework::Protobuf::Control::ServoRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetAutoServoOff() {
      ::grpc::Service::experimental().MarkMethodCallback(29,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetAutoServoOffReq, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq* request,
                 ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetAutoServoOff(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetAutoServoOff(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetAutoServoOffReq, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetAutoServoOffReq, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>*>(
          ::grpc::Service::experimental().GetHandler(29))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetAutoServoOff() {
      ::grpc::Service::experimental().MarkMethodCallback(30,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetAutoServoOffReq, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq* request,
                 ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetAutoServoOff(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetAutoServoOff(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetAutoServoOffReq, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetAutoServoOffReq, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>*>(
          ::grpc::Service::experimental().GetHandler(30))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SimulationMode() {
      ::grpc::Service::experimental().MarkMethodCallback(31,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SimulationModeReq, ::IndyFramework::Protobuf::Control::SimulationModeRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SimulationModeReq* request,
                 ::IndyFramework::Protobuf::Control::SimulationModeRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SimulationMode(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SimulationMode(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SimulationModeReq, ::IndyFramework::Protobuf::Control::SimulationModeRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SimulationModeReq, ::IndyFramework::Protobuf::Control::SimulationModeRes>*>(
          ::grpc::Service::experimental().GetHandler(31))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SimulationMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SimulationModeReq* /*request*/, ::IndyFramework::Protobuf::Control::SimulationModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SimulationMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SimulationModeReq* /*request*/, ::IndyFramework::Protobuf::Control::SimulationModeRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DirectTeachingMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DirectTeachingMode() {
      ::grpc::Service::experimental().MarkMethodCallback(32,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::DirectTeachingModeReq, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq* request,
                 ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->DirectTeachingMode(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_DirectTeachingMode(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::DirectTeachingModeReq, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::DirectTeachingModeReq, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>*>(
          ::grpc::Service::experimental().GetHandler(32))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DirectTeachingMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DirectTeachingMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DirectTeachingMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRTControlData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRTControlData() {
      ::grpc::Service::experimental().MarkMethodCallback(33,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetRTControlDataReq, ::IndyFramework::Protobuf::Control::GetRTControlDataRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetRTControlDataReq* request,
                 ::IndyFramework::Protobuf::Control::GetRTControlDataRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetRTControlData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetRTControlData(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetRTControlDataReq, ::IndyFramework::Protobuf::Control::GetRTControlDataRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetRTControlDataReq, ::IndyFramework::Protobuf::Control::GetRTControlDataRes>*>(
          ::grpc::Service::experimental().GetHandler(33))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRTControlData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRTControlData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRTControlData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetIOData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetIOData() {
      ::grpc::Service::experimental().MarkMethodCallback(34,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetIODataReq, ::IndyFramework::Protobuf::Control::GetIODataRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetIODataReq* request,
                 ::IndyFramework::Protobuf::Control::GetIODataRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetIOData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetIOData(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetIODataReq, ::IndyFramework::Protobuf::Control::GetIODataRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetIODataReq, ::IndyFramework::Protobuf::Control::GetIODataRes>*>(
          ::grpc::Service::experimental().GetHandler(34))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetIOData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetIODataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetIODataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetIOData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetIODataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetIODataRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCoreData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetCoreData() {
      ::grpc::Service::experimental().MarkMethodCallback(35,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetCoreDataReq, ::IndyFramework::Protobuf::Control::GetCoreDataRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetCoreDataReq* request,
                 ::IndyFramework::Protobuf::Control::GetCoreDataRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetCoreData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetCoreData(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetCoreDataReq, ::IndyFramework::Protobuf::Control::GetCoreDataRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetCoreDataReq, ::IndyFramework::Protobuf::Control::GetCoreDataRes>*>(
          ::grpc::Service::experimental().GetHandler(35))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetCoreData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCoreData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCoreDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCoreDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCoreData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCoreDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCoreDataRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetSystemInfoData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetSystemInfoData() {
      ::grpc::Service::experimental().MarkMethodCallback(36,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq* request,
                 ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetSystemInfoData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetSystemInfoData(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>*>(
          ::grpc::Service::experimental().GetHandler(36))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetSystemInfoData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSystemInfoData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetSystemInfoData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetMotionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetMotionData() {
      ::grpc::Service::experimental().MarkMethodCallback(37,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetMotionDataReq, ::IndyFramework::Protobuf::Control::GetMotionDataRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetMotionDataReq* request,
                 ::IndyFramework::Protobuf::Control::GetMotionDataRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetMotionData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetMotionData(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetMotionDataReq, ::IndyFramework::Protobuf::Control::GetMotionDataRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetMotionDataReq, ::IndyFramework::Protobuf::Control::GetMotionDataRes>*>(
          ::grpc::Service::experimental().GetHandler(37))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetMotionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMotionData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetMotionDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetMotionDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMotionData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetMotionDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetMotionDataRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetStateData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetStateData() {
      ::grpc::Service::experimental().MarkMethodCallback(38,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetStateDataReq, ::IndyFramework::Protobuf::Control::GetStateDataRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetStateDataReq* request,
                 ::IndyFramework::Protobuf::Control::GetStateDataRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetStateData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetStateData(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetStateDataReq, ::IndyFramework::Protobuf::Control::GetStateDataRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetStateDataReq, ::IndyFramework::Protobuf::Control::GetStateDataRes>*>(
          ::grpc::Service::experimental().GetHandler(38))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetStateData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetStateDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetStateDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetStateData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetStateDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetStateDataRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetViolationData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetViolationData() {
      ::grpc::Service::experimental().MarkMethodCallback(39,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetViolationDataReq, ::IndyFramework::Protobuf::Control::GetViolationDataRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetViolationDataReq* request,
                 ::IndyFramework::Protobuf::Control::GetViolationDataRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetViolationData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetViolationData(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetViolationDataReq, ::IndyFramework::Protobuf::Control::GetViolationDataRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetViolationDataReq, ::IndyFramework::Protobuf::Control::GetViolationDataRes>*>(
          ::grpc::Service::experimental().GetHandler(39))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetViolationData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetViolationData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetViolationDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetViolationDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetViolationData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetViolationDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetViolationDataRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetProgramState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetProgramState() {
      ::grpc::Service::experimental().MarkMethodCallback(40,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetProgramStateReq, ::IndyFramework::Protobuf::Control::SetProgramStateRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetProgramStateReq* request,
                 ::IndyFramework::Protobuf::Control::SetProgramStateRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetProgramState(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetProgramState(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetProgramStateReq, ::IndyFramework::Protobuf::Control::SetProgramStateRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetProgramStateReq, ::IndyFramework::Protobuf::Control::SetProgramStateRes>*>(
          ::grpc::Service::experimental().GetHandler(40))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetProgramState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProgramState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetProgramStateReq* /*request*/, ::IndyFramework::Protobuf::Control::SetProgramStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetProgramState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetProgramStateReq* /*request*/, ::IndyFramework::Protobuf::Control::SetProgramStateRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_InverseKinematics() {
      ::grpc::Service::experimental().MarkMethodCallback(41,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::InverseKinematicsReq, ::IndyFramework::Protobuf::Control::InverseKinematicsRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::InverseKinematicsReq* request,
                 ::IndyFramework::Protobuf::Control::InverseKinematicsRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->InverseKinematics(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_InverseKinematics(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::InverseKinematicsReq, ::IndyFramework::Protobuf::Control::InverseKinematicsRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::InverseKinematicsReq, ::IndyFramework::Protobuf::Control::InverseKinematicsRes>*>(
          ::grpc::Service::experimental().GetHandler(41))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq* /*request*/, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void InverseKinematics(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq* /*request*/, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CheckAproachRetractValid() {
      ::grpc::Service::experimental().MarkMethodCallback(42,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq* request,
                 ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CheckAproachRetractValid(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CheckAproachRetractValid(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>*>(
          ::grpc::Service::experimental().GetHandler(42))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq* /*request*/, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq* /*request*/, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetPalletPointList() {
      ::grpc::Service::experimental().MarkMethodCallback(43,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetPalletPointListReq, ::IndyFramework::Protobuf::Control::GetPalletPointListRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetPalletPointListReq* request,
                 ::IndyFramework::Protobuf::Control::GetPalletPointListRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetPalletPointList(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetPalletPointList(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetPalletPointListReq, ::IndyFramework::Protobuf::Control::GetPalletPointListRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetPalletPointListReq, ::IndyFramework::Protobuf::Control::GetPalletPointListRes>*>(
          ::grpc::Service::experimental().GetHandler(43))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CalculateRelativePose() {
      ::grpc::Service::experimental().MarkMethodCallback(44,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq* request,
                 ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CalculateRelativePose(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CalculateRelativePose(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>*>(
          ::grpc::Service::experimental().GetHandler(44))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq* /*request*/, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq* /*request*/, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::experimental().MarkMethodCallback(45,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq* request,
                 ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CalculateCurrentPoseRel(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CalculateCurrentPoseRel(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>*>(
          ::grpc::Service::experimental().GetHandler(45))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq* /*request*/, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq* /*request*/, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetDI() {
      ::grpc::Service::experimental().MarkMethodCallback(46,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetDIReq, ::IndyFramework::Protobuf::Control::GetDIRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetDIReq* request,
                 ::IndyFramework::Protobuf::Control::GetDIRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetDI(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetDI(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetDIReq, ::IndyFramework::Protobuf::Control::GetDIRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetDIReq, ::IndyFramework::Protobuf::Control::GetDIRes>*>(
          ::grpc::Service::experimental().GetHandler(46))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetDIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetDIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetDIRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetDI() {
      ::grpc::Service::experimental().MarkMethodCallback(47,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetDIReq, ::IndyFramework::Protobuf::Control::SetDIRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetDIReq* request,
                 ::IndyFramework::Protobuf::Control::SetDIRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetDI(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetDI(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetDIReq, ::IndyFramework::Protobuf::Control::SetDIRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetDIReq, ::IndyFramework::Protobuf::Control::SetDIRes>*>(
          ::grpc::Service::experimental().GetHandler(47))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetDIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetDIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetDIRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetDO() {
      ::grpc::Service::experimental().MarkMethodCallback(48,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetDOReq, ::IndyFramework::Protobuf::Control::SetDORes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetDOReq* request,
                 ::IndyFramework::Protobuf::Control::SetDORes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetDO(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetDO(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetDOReq, ::IndyFramework::Protobuf::Control::SetDORes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetDOReq, ::IndyFramework::Protobuf::Control::SetDORes>*>(
          ::grpc::Service::experimental().GetHandler(48))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetDOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetDOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetDORes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetDO() {
      ::grpc::Service::experimental().MarkMethodCallback(49,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetDOReq, ::IndyFramework::Protobuf::Control::GetDORes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetDOReq* request,
                 ::IndyFramework::Protobuf::Control::GetDORes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetDO(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetDO(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetDOReq, ::IndyFramework::Protobuf::Control::GetDORes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetDOReq, ::IndyFramework::Protobuf::Control::GetDORes>*>(
          ::grpc::Service::experimental().GetHandler(49))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetDOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetDOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetDORes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetAI() {
      ::grpc::Service::experimental().MarkMethodCallback(50,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetAIReq, ::IndyFramework::Protobuf::Control::GetAIRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetAIReq* request,
                 ::IndyFramework::Protobuf::Control::GetAIRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetAI(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetAI(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetAIReq, ::IndyFramework::Protobuf::Control::GetAIRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetAIReq, ::IndyFramework::Protobuf::Control::GetAIRes>*>(
          ::grpc::Service::experimental().GetHandler(50))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAIRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetAI() {
      ::grpc::Service::experimental().MarkMethodCallback(51,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetAIReq, ::IndyFramework::Protobuf::Control::SetAIRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetAIReq* request,
                 ::IndyFramework::Protobuf::Control::SetAIRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetAI(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetAI(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetAIReq, ::IndyFramework::Protobuf::Control::SetAIRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetAIReq, ::IndyFramework::Protobuf::Control::SetAIRes>*>(
          ::grpc::Service::experimental().GetHandler(51))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAIRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetAO() {
      ::grpc::Service::experimental().MarkMethodCallback(52,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetAOReq, ::IndyFramework::Protobuf::Control::GetAORes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetAOReq* request,
                 ::IndyFramework::Protobuf::Control::GetAORes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetAO(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetAO(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetAOReq, ::IndyFramework::Protobuf::Control::GetAORes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetAOReq, ::IndyFramework::Protobuf::Control::GetAORes>*>(
          ::grpc::Service::experimental().GetHandler(52))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAORes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetAO() {
      ::grpc::Service::experimental().MarkMethodCallback(53,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetAOReq, ::IndyFramework::Protobuf::Control::SetAORes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetAOReq* request,
                 ::IndyFramework::Protobuf::Control::SetAORes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetAO(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetAO(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetAOReq, ::IndyFramework::Protobuf::Control::SetAORes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetAOReq, ::IndyFramework::Protobuf::Control::SetAORes>*>(
          ::grpc::Service::experimental().GetHandler(53))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAORes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetEndDI() {
      ::grpc::Service::experimental().MarkMethodCallback(54,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetEndDIReq, ::IndyFramework::Protobuf::Control::GetEndDIRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetEndDIReq* request,
                 ::IndyFramework::Protobuf::Control::GetEndDIRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetEndDI(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetEndDI(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetEndDIReq, ::IndyFramework::Protobuf::Control::GetEndDIRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetEndDIReq, ::IndyFramework::Protobuf::Control::GetEndDIRes>*>(
          ::grpc::Service::experimental().GetHandler(54))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndDIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetEndDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndDIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndDIRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetEndDI() {
      ::grpc::Service::experimental().MarkMethodCallback(55,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetEndDIReq, ::IndyFramework::Protobuf::Control::SetEndDIRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetEndDIReq* request,
                 ::IndyFramework::Protobuf::Control::SetEndDIRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetEndDI(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetEndDI(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetEndDIReq, ::IndyFramework::Protobuf::Control::SetEndDIRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetEndDIReq, ::IndyFramework::Protobuf::Control::SetEndDIRes>*>(
          ::grpc::Service::experimental().GetHandler(55))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndDIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetEndDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndDIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndDIRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetEndDO() {
      ::grpc::Service::experimental().MarkMethodCallback(56,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetEndDOReq, ::IndyFramework::Protobuf::Control::SetEndDORes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetEndDOReq* request,
                 ::IndyFramework::Protobuf::Control::SetEndDORes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetEndDO(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetEndDO(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetEndDOReq, ::IndyFramework::Protobuf::Control::SetEndDORes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetEndDOReq, ::IndyFramework::Protobuf::Control::SetEndDORes>*>(
          ::grpc::Service::experimental().GetHandler(56))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndDOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndDOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndDORes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetEndDO() {
      ::grpc::Service::experimental().MarkMethodCallback(57,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetEndDOReq, ::IndyFramework::Protobuf::Control::GetEndDORes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetEndDOReq* request,
                 ::IndyFramework::Protobuf::Control::GetEndDORes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetEndDO(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetEndDO(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetEndDOReq, ::IndyFramework::Protobuf::Control::GetEndDORes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetEndDOReq, ::IndyFramework::Protobuf::Control::GetEndDORes>*>(
          ::grpc::Service::experimental().GetHandler(57))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndDOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndDOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndDORes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetEndAI() {
      ::grpc::Service::experimental().MarkMethodCallback(58,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetEndAIReq, ::IndyFramework::Protobuf::Control::GetEndAIRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetEndAIReq* request,
                 ::IndyFramework::Protobuf::Control::GetEndAIRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetEndAI(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetEndAI(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetEndAIReq, ::IndyFramework::Protobuf::Control::GetEndAIRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetEndAIReq, ::IndyFramework::Protobuf::Control::GetEndAIRes>*>(
          ::grpc::Service::experimental().GetHandler(58))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndAIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetEndAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndAIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndAIRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetEndAI() {
      ::grpc::Service::experimental().MarkMethodCallback(59,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetEndAIReq, ::IndyFramework::Protobuf::Control::SetEndAIRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetEndAIReq* request,
                 ::IndyFramework::Protobuf::Control::SetEndAIRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetEndAI(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetEndAI(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetEndAIReq, ::IndyFramework::Protobuf::Control::SetEndAIRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetEndAIReq, ::IndyFramework::Protobuf::Control::SetEndAIRes>*>(
          ::grpc::Service::experimental().GetHandler(59))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndAIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetEndAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndAIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndAIRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetEndAO() {
      ::grpc::Service::experimental().MarkMethodCallback(60,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetEndAOReq, ::IndyFramework::Protobuf::Control::GetEndAORes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetEndAOReq* request,
                 ::IndyFramework::Protobuf::Control::GetEndAORes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetEndAO(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetEndAO(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetEndAOReq, ::IndyFramework::Protobuf::Control::GetEndAORes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetEndAOReq, ::IndyFramework::Protobuf::Control::GetEndAORes>*>(
          ::grpc::Service::experimental().GetHandler(60))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndAOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndAOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndAORes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetEndAO() {
      ::grpc::Service::experimental().MarkMethodCallback(61,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetEndAOReq, ::IndyFramework::Protobuf::Control::SetEndAORes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetEndAOReq* request,
                 ::IndyFramework::Protobuf::Control::SetEndAORes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetEndAO(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetEndAO(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetEndAOReq, ::IndyFramework::Protobuf::Control::SetEndAORes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetEndAOReq, ::IndyFramework::Protobuf::Control::SetEndAORes>*>(
          ::grpc::Service::experimental().GetHandler(61))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndAOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndAOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndAORes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetJointControlGain() {
      ::grpc::Service::experimental().MarkMethodCallback(62,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetJointControlGainReq, ::IndyFramework::Protobuf::Control::SetJointControlGainRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetJointControlGainReq* request,
                 ::IndyFramework::Protobuf::Control::SetJointControlGainRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetJointControlGain(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetJointControlGain(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetJointControlGainReq, ::IndyFramework::Protobuf::Control::SetJointControlGainRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetJointControlGainReq, ::IndyFramework::Protobuf::Control::SetJointControlGainRes>*>(
          ::grpc::Service::experimental().GetHandler(62))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetJointControlGain() {
      ::grpc::Service::experimental().MarkMethodCallback(63,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetJointControlGainReq, ::IndyFramework::Protobuf::Control::GetJointControlGainRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetJointControlGainReq* request,
                 ::IndyFramework::Protobuf::Control::GetJointControlGainRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetJointControlGain(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetJointControlGain(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetJointControlGainReq, ::IndyFramework::Protobuf::Control::GetJointControlGainRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetJointControlGainReq, ::IndyFramework::Protobuf::Control::GetJointControlGainRes>*>(
          ::grpc::Service::experimental().GetHandler(63))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetTaskControlGain() {
      ::grpc::Service::experimental().MarkMethodCallback(64,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetTaskControlGainReq, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq* request,
                 ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetTaskControlGain(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetTaskControlGain(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetTaskControlGainReq, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetTaskControlGainReq, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>*>(
          ::grpc::Service::experimental().GetHandler(64))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetTaskControlGain() {
      ::grpc::Service::experimental().MarkMethodCallback(65,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetTaskControlGainReq, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq* request,
                 ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetTaskControlGain(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetTaskControlGain(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetTaskControlGainReq, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetTaskControlGainReq, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>*>(
          ::grpc::Service::experimental().GetHandler(65))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetImpedanceControlGain() {
      ::grpc::Service::experimental().MarkMethodCallback(66,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq* request,
                 ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetImpedanceControlGain(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetImpedanceControlGain(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>*>(
          ::grpc::Service::experimental().GetHandler(66))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetImpedanceControlGain() {
      ::grpc::Service::experimental().MarkMethodCallback(67,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq* request,
                 ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetImpedanceControlGain(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetImpedanceControlGain(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>*>(
          ::grpc::Service::experimental().GetHandler(67))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetFricComp() {
      ::grpc::Service::experimental().MarkMethodCallback(68,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetFricCompReq, ::IndyFramework::Protobuf::Control::SetFricCompRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetFricCompReq* request,
                 ::IndyFramework::Protobuf::Control::SetFricCompRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetFricComp(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetFricComp(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetFricCompReq, ::IndyFramework::Protobuf::Control::SetFricCompRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetFricCompReq, ::IndyFramework::Protobuf::Control::SetFricCompRes>*>(
          ::grpc::Service::experimental().GetHandler(68))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetFricCompReq* /*request*/, ::IndyFramework::Protobuf::Control::SetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetFricCompReq* /*request*/, ::IndyFramework::Protobuf::Control::SetFricCompRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetFricComp() {
      ::grpc::Service::experimental().MarkMethodCallback(69,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetFricCompReq, ::IndyFramework::Protobuf::Control::GetFricCompRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetFricCompReq* request,
                 ::IndyFramework::Protobuf::Control::GetFricCompRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetFricComp(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetFricComp(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetFricCompReq, ::IndyFramework::Protobuf::Control::GetFricCompRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetFricCompReq, ::IndyFramework::Protobuf::Control::GetFricCompRes>*>(
          ::grpc::Service::experimental().GetHandler(69))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetFricCompReq* /*request*/, ::IndyFramework::Protobuf::Control::GetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetFricCompReq* /*request*/, ::IndyFramework::Protobuf::Control::GetFricCompRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetMountPos() {
      ::grpc::Service::experimental().MarkMethodCallback(70,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetMountPosReq, ::IndyFramework::Protobuf::Control::SetMountPosRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetMountPosReq* request,
                 ::IndyFramework::Protobuf::Control::SetMountPosRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetMountPos(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetMountPos(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetMountPosReq, ::IndyFramework::Protobuf::Control::SetMountPosRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetMountPosReq, ::IndyFramework::Protobuf::Control::SetMountPosRes>*>(
          ::grpc::Service::experimental().GetHandler(70))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetMountPosReq* /*request*/, ::IndyFramework::Protobuf::Control::SetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetMountPosReq* /*request*/, ::IndyFramework::Protobuf::Control::SetMountPosRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetMountPos() {
      ::grpc::Service::experimental().MarkMethodCallback(71,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetMountPosReq, ::IndyFramework::Protobuf::Control::GetMountPosRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetMountPosReq* request,
                 ::IndyFramework::Protobuf::Control::GetMountPosRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetMountPos(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetMountPos(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetMountPosReq, ::IndyFramework::Protobuf::Control::GetMountPosRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetMountPosReq, ::IndyFramework::Protobuf::Control::GetMountPosRes>*>(
          ::grpc::Service::experimental().GetHandler(71))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetMountPosReq* /*request*/, ::IndyFramework::Protobuf::Control::GetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetMountPosReq* /*request*/, ::IndyFramework::Protobuf::Control::GetMountPosRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetToolProperty() {
      ::grpc::Service::experimental().MarkMethodCallback(72,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetToolPropertyReq, ::IndyFramework::Protobuf::Control::SetToolPropertyRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetToolPropertyReq* request,
                 ::IndyFramework::Protobuf::Control::SetToolPropertyRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetToolProperty(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetToolProperty(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetToolPropertyReq, ::IndyFramework::Protobuf::Control::SetToolPropertyRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetToolPropertyReq, ::IndyFramework::Protobuf::Control::SetToolPropertyRes>*>(
          ::grpc::Service::experimental().GetHandler(72))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetToolProperty() {
      ::grpc::Service::experimental().MarkMethodCallback(73,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetToolPropertyReq, ::IndyFramework::Protobuf::Control::GetToolPropertyRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetToolPropertyReq* request,
                 ::IndyFramework::Protobuf::Control::GetToolPropertyRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetToolProperty(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetToolProperty(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetToolPropertyReq, ::IndyFramework::Protobuf::Control::GetToolPropertyRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetToolPropertyReq, ::IndyFramework::Protobuf::Control::GetToolPropertyRes>*>(
          ::grpc::Service::experimental().GetHandler(73))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetCollSensLevel() {
      ::grpc::Service::experimental().MarkMethodCallback(74,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetCollSensLevelReq, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq* request,
                 ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetCollSensLevel(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetCollSensLevel(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetCollSensLevelReq, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetCollSensLevelReq, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>*>(
          ::grpc::Service::experimental().GetHandler(74))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetCollSensLevel() {
      ::grpc::Service::experimental().MarkMethodCallback(75,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetCollSensLevelReq, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq* request,
                 ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetCollSensLevel(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetCollSensLevel(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetCollSensLevelReq, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetCollSensLevelReq, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>*>(
          ::grpc::Service::experimental().GetHandler(75))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetCollSensParam() {
      ::grpc::Service::experimental().MarkMethodCallback(76,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetCollSensParamReq, ::IndyFramework::Protobuf::Control::SetCollSensParamRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetCollSensParamReq* request,
                 ::IndyFramework::Protobuf::Control::SetCollSensParamRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetCollSensParam(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetCollSensParam(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetCollSensParamReq, ::IndyFramework::Protobuf::Control::SetCollSensParamRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetCollSensParamReq, ::IndyFramework::Protobuf::Control::SetCollSensParamRes>*>(
          ::grpc::Service::experimental().GetHandler(76))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetCollSensParam() {
      ::grpc::Service::experimental().MarkMethodCallback(77,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetCollSensParamReq, ::IndyFramework::Protobuf::Control::GetCollSensParamRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetCollSensParamReq* request,
                 ::IndyFramework::Protobuf::Control::GetCollSensParamRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetCollSensParam(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetCollSensParam(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetCollSensParamReq, ::IndyFramework::Protobuf::Control::GetCollSensParamRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetCollSensParamReq, ::IndyFramework::Protobuf::Control::GetCollSensParamRes>*>(
          ::grpc::Service::experimental().GetHandler(77))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetCollPolicy() {
      ::grpc::Service::experimental().MarkMethodCallback(78,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetCollPolicyReq, ::IndyFramework::Protobuf::Control::SetCollPolicyRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetCollPolicyReq* request,
                 ::IndyFramework::Protobuf::Control::SetCollPolicyRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetCollPolicy(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetCollPolicy(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetCollPolicyReq, ::IndyFramework::Protobuf::Control::SetCollPolicyRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetCollPolicyReq, ::IndyFramework::Protobuf::Control::SetCollPolicyRes>*>(
          ::grpc::Service::experimental().GetHandler(78))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetCollPolicy() {
      ::grpc::Service::experimental().MarkMethodCallback(79,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetCollPolicyReq, ::IndyFramework::Protobuf::Control::GetCollPolicyRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetCollPolicyReq* request,
                 ::IndyFramework::Protobuf::Control::GetCollPolicyRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetCollPolicy(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetCollPolicy(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetCollPolicyReq, ::IndyFramework::Protobuf::Control::GetCollPolicyRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetCollPolicyReq, ::IndyFramework::Protobuf::Control::GetCollPolicyRes>*>(
          ::grpc::Service::experimental().GetHandler(79))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCollTuningParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetCollTuningParam() {
      ::grpc::Service::experimental().MarkMethodCallback(80,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetCollTuningParamReq, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq* request,
                 ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetCollTuningParam(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetCollTuningParam(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetCollTuningParamReq, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetCollTuningParamReq, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>*>(
          ::grpc::Service::experimental().GetHandler(80))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetCollTuningParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollTuningParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCollTuningParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetSafetyLimitConfig() {
      ::grpc::Service::experimental().MarkMethodCallback(81,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq* request,
                 ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetSafetyLimitConfig(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetSafetyLimitConfig(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>*>(
          ::grpc::Service::experimental().GetHandler(81))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetSafetyLimitConfig() {
      ::grpc::Service::experimental().MarkMethodCallback(82,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq* request,
                 ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetSafetyLimitConfig(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetSafetyLimitConfig(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>*>(
          ::grpc::Service::experimental().GetHandler(82))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetSafetyStopConfig() {
      ::grpc::Service::experimental().MarkMethodCallback(83,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq* request,
                 ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetSafetyStopConfig(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetSafetyStopConfig(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>*>(
          ::grpc::Service::experimental().GetHandler(83))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetSafetyStopConfig() {
      ::grpc::Service::experimental().MarkMethodCallback(84,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq* request,
                 ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetSafetyStopConfig(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetSafetyStopConfig(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>*>(
          ::grpc::Service::experimental().GetHandler(84))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetEL5001 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetEL5001() {
      ::grpc::Service::experimental().MarkMethodCallback(85,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetEL5001Req, ::IndyFramework::Protobuf::Control::GetEL5001Res>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetEL5001Req* request,
                 ::IndyFramework::Protobuf::Control::GetEL5001Res* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetEL5001(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetEL5001(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetEL5001Req, ::IndyFramework::Protobuf::Control::GetEL5001Res>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetEL5001Req, ::IndyFramework::Protobuf::Control::GetEL5001Res>*>(
          ::grpc::Service::experimental().GetHandler(85))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetEL5001() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5001(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEL5001Req* /*request*/, ::IndyFramework::Protobuf::Control::GetEL5001Res* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetEL5001(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEL5001Req* /*request*/, ::IndyFramework::Protobuf::Control::GetEL5001Res* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetEL5101 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetEL5101() {
      ::grpc::Service::experimental().MarkMethodCallback(86,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetEL5101Req, ::IndyFramework::Protobuf::Control::GetEL5101Res>(
          [this](::grpc::ServerContext* context,
                 const ::IndyFramework::Protobuf::Control::GetEL5101Req* request,
                 ::IndyFramework::Protobuf::Control::GetEL5101Res* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetEL5101(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetEL5101(
        ::grpc::experimental::MessageAllocator< ::IndyFramework::Protobuf::Control::GetEL5101Req, ::IndyFramework::Protobuf::Control::GetEL5101Res>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::Control::GetEL5101Req, ::IndyFramework::Protobuf::Control::GetEL5101Res>*>(
          ::grpc::Service::experimental().GetHandler(86))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetEL5101() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5101(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEL5101Req* /*request*/, ::IndyFramework::Protobuf::Control::GetEL5101Res* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetEL5101(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEL5101Req* /*request*/, ::IndyFramework::Protobuf::Control::GetEL5101Res* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_AMoveJ<ExperimentalWithCallbackMethod_AMoveJT<ExperimentalWithCallbackMethod_AMoveL<ExperimentalWithCallbackMethod_AMoveLT<ExperimentalWithCallbackMethod_AMoveC<ExperimentalWithCallbackMethod_AMoveCT<ExperimentalWithCallbackMethod_AWaitIO<ExperimentalWithCallbackMethod_AWaitTime<ExperimentalWithCallbackMethod_AWaitProgress<ExperimentalWithCallbackMethod_AWaitTraj<ExperimentalWithCallbackMethod_AWaitRadius<ExperimentalWithCallbackMethod_AMotionStop<ExperimentalWithCallbackMethod_MoveSJ<ExperimentalWithCallbackMethod_MoveSJT<ExperimentalWithCallbackMethod_MoveSL<ExperimentalWithCallbackMethod_MoveSLT<ExperimentalWithCallbackMethod_MoveSpiral<ExperimentalWithCallbackMethod_SetRefFrame<ExperimentalWithCallbackMethod_SetRefFramePlanar<ExperimentalWithCallbackMethod_SetToolFrame<ExperimentalWithCallbackMethod_SetSpeedRatio<ExperimentalWithCallbackMethod_SetCommandSpeedRatio<ExperimentalWithCallbackMethod_Reboot<ExperimentalWithCallbackMethod_Recover<ExperimentalWithCallbackMethod_Stop<ExperimentalWithCallbackMethod_Pause<ExperimentalWithCallbackMethod_Resume<ExperimentalWithCallbackMethod_Brake<ExperimentalWithCallbackMethod_Servo<ExperimentalWithCallbackMethod_SetAutoServoOff<ExperimentalWithCallbackMethod_GetAutoServoOff<ExperimentalWithCallbackMethod_SimulationMode<ExperimentalWithCallbackMethod_DirectTeachingMode<ExperimentalWithCallbackMethod_GetRTControlData<ExperimentalWithCallbackMethod_GetIOData<ExperimentalWithCallbackMethod_GetCoreData<ExperimentalWithCallbackMethod_GetSystemInfoData<ExperimentalWithCallbackMethod_GetMotionData<ExperimentalWithCallbackMethod_GetStateData<ExperimentalWithCallbackMethod_GetViolationData<ExperimentalWithCallbackMethod_SetProgramState<ExperimentalWithCallbackMethod_InverseKinematics<ExperimentalWithCallbackMethod_CheckAproachRetractValid<ExperimentalWithCallbackMethod_GetPalletPointList<ExperimentalWithCallbackMethod_CalculateRelativePose<ExperimentalWithCallbackMethod_CalculateCurrentPoseRel<ExperimentalWithCallbackMethod_GetDI<ExperimentalWithCallbackMethod_SetDI<ExperimentalWithCallbackMethod_SetDO<ExperimentalWithCallbackMethod_GetDO<ExperimentalWithCallbackMethod_GetAI<ExperimentalWithCallbackMethod_SetAI<ExperimentalWithCallbackMethod_GetAO<ExperimentalWithCallbackMethod_SetAO<ExperimentalWithCallbackMethod_GetEndDI<ExperimentalWithCallbackMethod_SetEndDI<ExperimentalWithCallbackMethod_SetEndDO<ExperimentalWithCallbackMethod_GetEndDO<ExperimentalWithCallbackMethod_GetEndAI<ExperimentalWithCallbackMethod_SetEndAI<ExperimentalWithCallbackMethod_GetEndAO<ExperimentalWithCallbackMethod_SetEndAO<ExperimentalWithCallbackMethod_SetJointControlGain<ExperimentalWithCallbackMethod_GetJointControlGain<ExperimentalWithCallbackMethod_SetTaskControlGain<ExperimentalWithCallbackMethod_GetTaskControlGain<ExperimentalWithCallbackMethod_SetImpedanceControlGain<ExperimentalWithCallbackMethod_GetImpedanceControlGain<ExperimentalWithCallbackMethod_SetFricComp<ExperimentalWithCallbackMethod_GetFricComp<ExperimentalWithCallbackMethod_SetMountPos<ExperimentalWithCallbackMethod_GetMountPos<ExperimentalWithCallbackMethod_SetToolProperty<ExperimentalWithCallbackMethod_GetToolProperty<ExperimentalWithCallbackMethod_SetCollSensLevel<ExperimentalWithCallbackMethod_GetCollSensLevel<ExperimentalWithCallbackMethod_SetCollSensParam<ExperimentalWithCallbackMethod_GetCollSensParam<ExperimentalWithCallbackMethod_SetCollPolicy<ExperimentalWithCallbackMethod_GetCollPolicy<ExperimentalWithCallbackMethod_GetCollTuningParam<ExperimentalWithCallbackMethod_GetSafetyLimitConfig<ExperimentalWithCallbackMethod_SetSafetyLimitConfig<ExperimentalWithCallbackMethod_GetSafetyStopConfig<ExperimentalWithCallbackMethod_SetSafetyStopConfig<ExperimentalWithCallbackMethod_GetEL5001<ExperimentalWithCallbackMethod_GetEL5101<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_AMoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AMoveJ() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_AMoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveJReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveJRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AMoveJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AMoveJT() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_AMoveJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveJT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveJTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveJTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AMoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AMoveL() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_AMoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveLReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AMoveLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AMoveLT() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_AMoveLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveLT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveLTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveLTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AMoveC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AMoveC() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_AMoveC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveC(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveCReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveCRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AMoveCT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AMoveCT() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_AMoveCT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveCT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveCTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveCTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AWaitIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AWaitIO() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_AWaitIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitIO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitIOReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitIORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AWaitTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AWaitTime() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_AWaitTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitTime(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitTimeReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AWaitProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AWaitProgress() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_AWaitProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitProgress(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitProgressReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitProgressRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AWaitTraj : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AWaitTraj() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_AWaitTraj() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitTraj(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitTrajReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitTrajRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AWaitRadius : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AWaitRadius() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_AWaitRadius() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitRadius(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AMotionStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AMotionStop() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_AMotionStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMotionStop(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMotionStopReq* /*request*/, ::IndyFramework::Protobuf::Control::AMotionStopRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveSJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveSJ() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_MoveSJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSJReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSJRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveSJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveSJT() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_MoveSJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSJT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSJTReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSJTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveSL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveSL() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_MoveSL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSLReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveSLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveSLT() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_MoveSLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSLT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSLTReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSLTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveSpiral : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveSpiral() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_MoveSpiral() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSpiral(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSpiralReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSpiralRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRefFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetRefFrame() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_SetRefFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetRefFrameReq* /*request*/, ::IndyFramework::Protobuf::Control::SetRefFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRefFramePlanar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetRefFramePlanar() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_SetRefFramePlanar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFramePlanar(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq* /*request*/, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetToolFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetToolFrame() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_SetToolFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetToolFrameReq* /*request*/, ::IndyFramework::Protobuf::Control::SetToolFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSpeedRatio() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_SetSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCommandSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCommandSpeedRatio() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_SetCommandSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCommandSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Reboot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Reboot() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_Reboot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reboot(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::RebootReq* /*request*/, ::IndyFramework::Protobuf::Control::RebootRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Recover() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::RecoverReq* /*request*/, ::IndyFramework::Protobuf::Control::RecoverRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Stop() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::StopReq* /*request*/, ::IndyFramework::Protobuf::Control::StopRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Pause() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_Pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pause(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::PauseReq* /*request*/, ::IndyFramework::Protobuf::Control::PauseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Resume() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_Resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resume(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::ResumeReq* /*request*/, ::IndyFramework::Protobuf::Control::ResumeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Brake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Brake() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_Brake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Brake(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::BrakeReq* /*request*/, ::IndyFramework::Protobuf::Control::BrakeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Servo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Servo() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_Servo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Servo(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::ServoReq* /*request*/, ::IndyFramework::Protobuf::Control::ServoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetAutoServoOff() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_SetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAutoServoOff() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_GetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SimulationMode() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_SimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SimulationMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SimulationModeReq* /*request*/, ::IndyFramework::Protobuf::Control::SimulationModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DirectTeachingMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DirectTeachingMode() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_DirectTeachingMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DirectTeachingMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRTControlData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRTControlData() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_GetRTControlData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRTControlData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetIOData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetIOData() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_GetIOData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetIODataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetIODataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCoreData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCoreData() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_GetCoreData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCoreData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCoreDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCoreDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSystemInfoData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSystemInfoData() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_GetSystemInfoData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSystemInfoData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMotionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMotionData() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_GetMotionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMotionData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetMotionDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetMotionDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStateData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStateData() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_GetStateData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetStateDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetStateDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetViolationData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetViolationData() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_GetViolationData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetViolationData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetViolationDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetViolationDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetProgramState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetProgramState() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_SetProgramState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProgramState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetProgramStateReq* /*request*/, ::IndyFramework::Protobuf::Control::SetProgramStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq* /*request*/, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq* /*request*/, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq* /*request*/, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq* /*request*/, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDI() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetDIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetDI() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_SetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetDIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetDO() {
      ::grpc::Service::MarkMethodGeneric(48);
    }
    ~WithGenericMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetDOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDO() {
      ::grpc::Service::MarkMethodGeneric(49);
    }
    ~WithGenericMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetDOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAI() {
      ::grpc::Service::MarkMethodGeneric(50);
    }
    ~WithGenericMethod_GetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetAI() {
      ::grpc::Service::MarkMethodGeneric(51);
    }
    ~WithGenericMethod_SetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAO() {
      ::grpc::Service::MarkMethodGeneric(52);
    }
    ~WithGenericMethod_GetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetAO() {
      ::grpc::Service::MarkMethodGeneric(53);
    }
    ~WithGenericMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEndDI() {
      ::grpc::Service::MarkMethodGeneric(54);
    }
    ~WithGenericMethod_GetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndDIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEndDI() {
      ::grpc::Service::MarkMethodGeneric(55);
    }
    ~WithGenericMethod_SetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndDIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEndDO() {
      ::grpc::Service::MarkMethodGeneric(56);
    }
    ~WithGenericMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndDOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEndDO() {
      ::grpc::Service::MarkMethodGeneric(57);
    }
    ~WithGenericMethod_GetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndDOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEndAI() {
      ::grpc::Service::MarkMethodGeneric(58);
    }
    ~WithGenericMethod_GetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndAIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEndAI() {
      ::grpc::Service::MarkMethodGeneric(59);
    }
    ~WithGenericMethod_SetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndAIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEndAO() {
      ::grpc::Service::MarkMethodGeneric(60);
    }
    ~WithGenericMethod_GetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndAOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEndAO() {
      ::grpc::Service::MarkMethodGeneric(61);
    }
    ~WithGenericMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndAOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetJointControlGain() {
      ::grpc::Service::MarkMethodGeneric(62);
    }
    ~WithGenericMethod_SetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetJointControlGain() {
      ::grpc::Service::MarkMethodGeneric(63);
    }
    ~WithGenericMethod_GetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetTaskControlGain() {
      ::grpc::Service::MarkMethodGeneric(64);
    }
    ~WithGenericMethod_SetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTaskControlGain() {
      ::grpc::Service::MarkMethodGeneric(65);
    }
    ~WithGenericMethod_GetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetImpedanceControlGain() {
      ::grpc::Service::MarkMethodGeneric(66);
    }
    ~WithGenericMethod_SetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetImpedanceControlGain() {
      ::grpc::Service::MarkMethodGeneric(67);
    }
    ~WithGenericMethod_GetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetFricComp() {
      ::grpc::Service::MarkMethodGeneric(68);
    }
    ~WithGenericMethod_SetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetFricCompReq* /*request*/, ::IndyFramework::Protobuf::Control::SetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFricComp() {
      ::grpc::Service::MarkMethodGeneric(69);
    }
    ~WithGenericMethod_GetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetFricCompReq* /*request*/, ::IndyFramework::Protobuf::Control::GetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetMountPos() {
      ::grpc::Service::MarkMethodGeneric(70);
    }
    ~WithGenericMethod_SetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetMountPosReq* /*request*/, ::IndyFramework::Protobuf::Control::SetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMountPos() {
      ::grpc::Service::MarkMethodGeneric(71);
    }
    ~WithGenericMethod_GetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetMountPosReq* /*request*/, ::IndyFramework::Protobuf::Control::GetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetToolProperty() {
      ::grpc::Service::MarkMethodGeneric(72);
    }
    ~WithGenericMethod_SetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetToolProperty() {
      ::grpc::Service::MarkMethodGeneric(73);
    }
    ~WithGenericMethod_GetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCollSensLevel() {
      ::grpc::Service::MarkMethodGeneric(74);
    }
    ~WithGenericMethod_SetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCollSensLevel() {
      ::grpc::Service::MarkMethodGeneric(75);
    }
    ~WithGenericMethod_GetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCollSensParam() {
      ::grpc::Service::MarkMethodGeneric(76);
    }
    ~WithGenericMethod_SetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCollSensParam() {
      ::grpc::Service::MarkMethodGeneric(77);
    }
    ~WithGenericMethod_GetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCollPolicy() {
      ::grpc::Service::MarkMethodGeneric(78);
    }
    ~WithGenericMethod_SetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCollPolicy() {
      ::grpc::Service::MarkMethodGeneric(79);
    }
    ~WithGenericMethod_GetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCollTuningParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCollTuningParam() {
      ::grpc::Service::MarkMethodGeneric(80);
    }
    ~WithGenericMethod_GetCollTuningParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollTuningParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodGeneric(81);
    }
    ~WithGenericMethod_GetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodGeneric(82);
    }
    ~WithGenericMethod_SetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSafetyStopConfig() {
      ::grpc::Service::MarkMethodGeneric(83);
    }
    ~WithGenericMethod_GetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSafetyStopConfig() {
      ::grpc::Service::MarkMethodGeneric(84);
    }
    ~WithGenericMethod_SetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEL5001 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEL5001() {
      ::grpc::Service::MarkMethodGeneric(85);
    }
    ~WithGenericMethod_GetEL5001() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5001(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEL5001Req* /*request*/, ::IndyFramework::Protobuf::Control::GetEL5001Res* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEL5101 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEL5101() {
      ::grpc::Service::MarkMethodGeneric(86);
    }
    ~WithGenericMethod_GetEL5101() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5101(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEL5101Req* /*request*/, ::IndyFramework::Protobuf::Control::GetEL5101Res* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_AMoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AMoveJ() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_AMoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveJReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveJRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAMoveJ(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AMoveJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AMoveJT() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_AMoveJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveJT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveJTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveJTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAMoveJT(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AMoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AMoveL() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_AMoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveLReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAMoveL(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AMoveLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AMoveLT() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_AMoveLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveLT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveLTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveLTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAMoveLT(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AMoveC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AMoveC() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_AMoveC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveC(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveCReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveCRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAMoveC(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AMoveCT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AMoveCT() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_AMoveCT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveCT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveCTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveCTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAMoveCT(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AWaitIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AWaitIO() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_AWaitIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitIO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitIOReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitIORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAWaitIO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AWaitTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AWaitTime() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_AWaitTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitTime(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitTimeReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAWaitTime(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AWaitProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AWaitProgress() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_AWaitProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitProgress(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitProgressReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitProgressRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAWaitProgress(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AWaitTraj : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AWaitTraj() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_AWaitTraj() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitTraj(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitTrajReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitTrajRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAWaitTraj(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AWaitRadius : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AWaitRadius() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_AWaitRadius() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitRadius(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAWaitRadius(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AMotionStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AMotionStop() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_AMotionStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMotionStop(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMotionStopReq* /*request*/, ::IndyFramework::Protobuf::Control::AMotionStopRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAMotionStop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveSJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveSJ() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_MoveSJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSJReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSJRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveSJ(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveSJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveSJT() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_MoveSJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSJT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSJTReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSJTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveSJT(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveSL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveSL() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_MoveSL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSLReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveSL(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveSLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveSLT() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_MoveSLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSLT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSLTReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSLTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveSLT(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveSpiral : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveSpiral() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_MoveSpiral() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSpiral(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSpiralReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSpiralRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveSpiral(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRefFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetRefFrame() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_SetRefFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetRefFrameReq* /*request*/, ::IndyFramework::Protobuf::Control::SetRefFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRefFrame(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRefFramePlanar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetRefFramePlanar() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_SetRefFramePlanar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFramePlanar(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq* /*request*/, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRefFramePlanar(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetToolFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetToolFrame() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_SetToolFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetToolFrameReq* /*request*/, ::IndyFramework::Protobuf::Control::SetToolFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetToolFrame(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSpeedRatio() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_SetSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSpeedRatio(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCommandSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCommandSpeedRatio() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_SetCommandSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCommandSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCommandSpeedRatio(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Reboot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Reboot() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_Reboot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reboot(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::RebootReq* /*request*/, ::IndyFramework::Protobuf::Control::RebootRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReboot(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Recover() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::RecoverReq* /*request*/, ::IndyFramework::Protobuf::Control::RecoverRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecover(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Stop() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::StopReq* /*request*/, ::IndyFramework::Protobuf::Control::StopRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Pause() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_Pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pause(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::PauseReq* /*request*/, ::IndyFramework::Protobuf::Control::PauseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPause(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Resume() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_Resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resume(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::ResumeReq* /*request*/, ::IndyFramework::Protobuf::Control::ResumeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Brake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Brake() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_Brake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Brake(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::BrakeReq* /*request*/, ::IndyFramework::Protobuf::Control::BrakeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBrake(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Servo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Servo() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_Servo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Servo(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::ServoReq* /*request*/, ::IndyFramework::Protobuf::Control::ServoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetAutoServoOff() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_SetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAutoServoOff(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAutoServoOff() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_GetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAutoServoOff(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SimulationMode() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_SimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SimulationMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SimulationModeReq* /*request*/, ::IndyFramework::Protobuf::Control::SimulationModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSimulationMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DirectTeachingMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DirectTeachingMode() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_DirectTeachingMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DirectTeachingMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDirectTeachingMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRTControlData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRTControlData() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_GetRTControlData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRTControlData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRTControlData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetIOData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetIOData() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_GetIOData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetIODataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetIODataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIOData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCoreData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCoreData() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_GetCoreData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCoreData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCoreDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCoreDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCoreData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSystemInfoData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSystemInfoData() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_GetSystemInfoData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSystemInfoData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSystemInfoData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMotionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMotionData() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_GetMotionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMotionData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetMotionDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetMotionDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMotionData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStateData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStateData() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_GetStateData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetStateDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetStateDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetViolationData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetViolationData() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_GetViolationData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetViolationData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetViolationDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetViolationDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetViolationData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetProgramState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetProgramState() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_SetProgramState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProgramState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetProgramStateReq* /*request*/, ::IndyFramework::Protobuf::Control::SetProgramStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetProgramState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq* /*request*/, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInverseKinematics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq* /*request*/, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckAproachRetractValid(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPalletPointList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq* /*request*/, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateRelativePose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq* /*request*/, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateCurrentPoseRel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDI() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetDIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetDI() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_SetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetDIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetDO() {
      ::grpc::Service::MarkMethodRaw(48);
    }
    ~WithRawMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetDOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDO() {
      ::grpc::Service::MarkMethodRaw(49);
    }
    ~WithRawMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetDOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAI() {
      ::grpc::Service::MarkMethodRaw(50);
    }
    ~WithRawMethod_GetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetAI() {
      ::grpc::Service::MarkMethodRaw(51);
    }
    ~WithRawMethod_SetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAO() {
      ::grpc::Service::MarkMethodRaw(52);
    }
    ~WithRawMethod_GetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetAO() {
      ::grpc::Service::MarkMethodRaw(53);
    }
    ~WithRawMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEndDI() {
      ::grpc::Service::MarkMethodRaw(54);
    }
    ~WithRawMethod_GetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndDIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndDI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEndDI() {
      ::grpc::Service::MarkMethodRaw(55);
    }
    ~WithRawMethod_SetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndDIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndDI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEndDO() {
      ::grpc::Service::MarkMethodRaw(56);
    }
    ~WithRawMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndDOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEndDO() {
      ::grpc::Service::MarkMethodRaw(57);
    }
    ~WithRawMethod_GetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndDOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEndAI() {
      ::grpc::Service::MarkMethodRaw(58);
    }
    ~WithRawMethod_GetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndAIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndAI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEndAI() {
      ::grpc::Service::MarkMethodRaw(59);
    }
    ~WithRawMethod_SetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndAIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndAI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEndAO() {
      ::grpc::Service::MarkMethodRaw(60);
    }
    ~WithRawMethod_GetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndAOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndAO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEndAO() {
      ::grpc::Service::MarkMethodRaw(61);
    }
    ~WithRawMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndAOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndAO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetJointControlGain() {
      ::grpc::Service::MarkMethodRaw(62);
    }
    ~WithRawMethod_SetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetJointControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetJointControlGain() {
      ::grpc::Service::MarkMethodRaw(63);
    }
    ~WithRawMethod_GetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetTaskControlGain() {
      ::grpc::Service::MarkMethodRaw(64);
    }
    ~WithRawMethod_SetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTaskControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTaskControlGain() {
      ::grpc::Service::MarkMethodRaw(65);
    }
    ~WithRawMethod_GetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTaskControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetImpedanceControlGain() {
      ::grpc::Service::MarkMethodRaw(66);
    }
    ~WithRawMethod_SetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetImpedanceControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetImpedanceControlGain() {
      ::grpc::Service::MarkMethodRaw(67);
    }
    ~WithRawMethod_GetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetImpedanceControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(67, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetFricComp() {
      ::grpc::Service::MarkMethodRaw(68);
    }
    ~WithRawMethod_SetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetFricCompReq* /*request*/, ::IndyFramework::Protobuf::Control::SetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetFricComp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(68, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFricComp() {
      ::grpc::Service::MarkMethodRaw(69);
    }
    ~WithRawMethod_GetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetFricCompReq* /*request*/, ::IndyFramework::Protobuf::Control::GetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFricComp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(69, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetMountPos() {
      ::grpc::Service::MarkMethodRaw(70);
    }
    ~WithRawMethod_SetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetMountPosReq* /*request*/, ::IndyFramework::Protobuf::Control::SetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMountPos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(70, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMountPos() {
      ::grpc::Service::MarkMethodRaw(71);
    }
    ~WithRawMethod_GetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetMountPosReq* /*request*/, ::IndyFramework::Protobuf::Control::GetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMountPos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(71, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetToolProperty() {
      ::grpc::Service::MarkMethodRaw(72);
    }
    ~WithRawMethod_SetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetToolProperty(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(72, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetToolProperty() {
      ::grpc::Service::MarkMethodRaw(73);
    }
    ~WithRawMethod_GetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetToolProperty(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(73, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCollSensLevel() {
      ::grpc::Service::MarkMethodRaw(74);
    }
    ~WithRawMethod_SetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCollSensLevel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(74, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCollSensLevel() {
      ::grpc::Service::MarkMethodRaw(75);
    }
    ~WithRawMethod_GetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollSensLevel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(75, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCollSensParam() {
      ::grpc::Service::MarkMethodRaw(76);
    }
    ~WithRawMethod_SetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCollSensParam(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(76, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCollSensParam() {
      ::grpc::Service::MarkMethodRaw(77);
    }
    ~WithRawMethod_GetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollSensParam(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(77, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCollPolicy() {
      ::grpc::Service::MarkMethodRaw(78);
    }
    ~WithRawMethod_SetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCollPolicy(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(78, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCollPolicy() {
      ::grpc::Service::MarkMethodRaw(79);
    }
    ~WithRawMethod_GetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollPolicy(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(79, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCollTuningParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCollTuningParam() {
      ::grpc::Service::MarkMethodRaw(80);
    }
    ~WithRawMethod_GetCollTuningParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollTuningParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollTuningParam(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(80, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodRaw(81);
    }
    ~WithRawMethod_GetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyLimitConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(81, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodRaw(82);
    }
    ~WithRawMethod_SetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSafetyLimitConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(82, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSafetyStopConfig() {
      ::grpc::Service::MarkMethodRaw(83);
    }
    ~WithRawMethod_GetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyStopConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(83, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSafetyStopConfig() {
      ::grpc::Service::MarkMethodRaw(84);
    }
    ~WithRawMethod_SetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSafetyStopConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(84, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEL5001 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEL5001() {
      ::grpc::Service::MarkMethodRaw(85);
    }
    ~WithRawMethod_GetEL5001() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5001(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEL5001Req* /*request*/, ::IndyFramework::Protobuf::Control::GetEL5001Res* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEL5001(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(85, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEL5101 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEL5101() {
      ::grpc::Service::MarkMethodRaw(86);
    }
    ~WithRawMethod_GetEL5101() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5101(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEL5101Req* /*request*/, ::IndyFramework::Protobuf::Control::GetEL5101Res* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEL5101(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(86, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AMoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AMoveJ() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->AMoveJ(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_AMoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveJReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveJRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AMoveJ(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AMoveJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AMoveJT() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->AMoveJT(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_AMoveJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveJT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveJTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveJTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AMoveJT(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AMoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AMoveL() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->AMoveL(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_AMoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveLReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AMoveL(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AMoveLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AMoveLT() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->AMoveLT(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_AMoveLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveLT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveLTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveLTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AMoveLT(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AMoveC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AMoveC() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->AMoveC(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_AMoveC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveC(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveCReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveCRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AMoveC(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AMoveCT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AMoveCT() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->AMoveCT(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_AMoveCT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMoveCT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveCTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveCTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AMoveCT(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AWaitIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AWaitIO() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->AWaitIO(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_AWaitIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitIO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitIOReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitIORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AWaitIO(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AWaitTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AWaitTime() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->AWaitTime(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_AWaitTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitTime(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitTimeReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AWaitTime(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AWaitProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AWaitProgress() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->AWaitProgress(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_AWaitProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitProgress(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitProgressReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitProgressRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AWaitProgress(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AWaitTraj : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AWaitTraj() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->AWaitTraj(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_AWaitTraj() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitTraj(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitTrajReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitTrajRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AWaitTraj(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AWaitRadius : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AWaitRadius() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->AWaitRadius(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_AWaitRadius() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AWaitRadius(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AWaitRadius(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AMotionStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AMotionStop() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->AMotionStop(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_AMotionStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AMotionStop(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMotionStopReq* /*request*/, ::IndyFramework::Protobuf::Control::AMotionStopRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AMotionStop(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MoveSJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MoveSJ() {
      ::grpc::Service::experimental().MarkMethodRawCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->MoveSJ(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_MoveSJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSJReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSJRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void MoveSJ(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MoveSJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MoveSJT() {
      ::grpc::Service::experimental().MarkMethodRawCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->MoveSJT(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_MoveSJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSJT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSJTReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSJTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void MoveSJT(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MoveSL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MoveSL() {
      ::grpc::Service::experimental().MarkMethodRawCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->MoveSL(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_MoveSL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSLReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void MoveSL(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MoveSLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MoveSLT() {
      ::grpc::Service::experimental().MarkMethodRawCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->MoveSLT(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_MoveSLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSLT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSLTReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSLTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void MoveSLT(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MoveSpiral : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MoveSpiral() {
      ::grpc::Service::experimental().MarkMethodRawCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->MoveSpiral(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_MoveSpiral() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveSpiral(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSpiralReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSpiralRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void MoveSpiral(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetRefFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetRefFrame() {
      ::grpc::Service::experimental().MarkMethodRawCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetRefFrame(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetRefFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetRefFrameReq* /*request*/, ::IndyFramework::Protobuf::Control::SetRefFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRefFrame(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetRefFramePlanar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetRefFramePlanar() {
      ::grpc::Service::experimental().MarkMethodRawCallback(18,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetRefFramePlanar(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetRefFramePlanar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFramePlanar(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq* /*request*/, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRefFramePlanar(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetToolFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetToolFrame() {
      ::grpc::Service::experimental().MarkMethodRawCallback(19,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetToolFrame(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetToolFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetToolFrameReq* /*request*/, ::IndyFramework::Protobuf::Control::SetToolFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetToolFrame(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetSpeedRatio() {
      ::grpc::Service::experimental().MarkMethodRawCallback(20,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetSpeedRatio(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetSpeedRatio(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetCommandSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetCommandSpeedRatio() {
      ::grpc::Service::experimental().MarkMethodRawCallback(21,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetCommandSpeedRatio(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetCommandSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCommandSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetCommandSpeedRatio(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Reboot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Reboot() {
      ::grpc::Service::experimental().MarkMethodRawCallback(22,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Reboot(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Reboot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reboot(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::RebootReq* /*request*/, ::IndyFramework::Protobuf::Control::RebootRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Reboot(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Recover() {
      ::grpc::Service::experimental().MarkMethodRawCallback(23,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Recover(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::RecoverReq* /*request*/, ::IndyFramework::Protobuf::Control::RecoverRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Recover(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Stop() {
      ::grpc::Service::experimental().MarkMethodRawCallback(24,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Stop(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::StopReq* /*request*/, ::IndyFramework::Protobuf::Control::StopRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Stop(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Pause() {
      ::grpc::Service::experimental().MarkMethodRawCallback(25,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Pause(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pause(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::PauseReq* /*request*/, ::IndyFramework::Protobuf::Control::PauseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Pause(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Resume() {
      ::grpc::Service::experimental().MarkMethodRawCallback(26,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Resume(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resume(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::ResumeReq* /*request*/, ::IndyFramework::Protobuf::Control::ResumeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Resume(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Brake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Brake() {
      ::grpc::Service::experimental().MarkMethodRawCallback(27,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Brake(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Brake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Brake(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::BrakeReq* /*request*/, ::IndyFramework::Protobuf::Control::BrakeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Brake(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Servo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Servo() {
      ::grpc::Service::experimental().MarkMethodRawCallback(28,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Servo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Servo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Servo(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::ServoReq* /*request*/, ::IndyFramework::Protobuf::Control::ServoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Servo(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetAutoServoOff() {
      ::grpc::Service::experimental().MarkMethodRawCallback(29,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetAutoServoOff(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetAutoServoOff(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAutoServoOff() {
      ::grpc::Service::experimental().MarkMethodRawCallback(30,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetAutoServoOff(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAutoServoOff(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SimulationMode() {
      ::grpc::Service::experimental().MarkMethodRawCallback(31,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SimulationMode(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SimulationMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SimulationModeReq* /*request*/, ::IndyFramework::Protobuf::Control::SimulationModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SimulationMode(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DirectTeachingMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DirectTeachingMode() {
      ::grpc::Service::experimental().MarkMethodRawCallback(32,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->DirectTeachingMode(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_DirectTeachingMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DirectTeachingMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DirectTeachingMode(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRTControlData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRTControlData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(33,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetRTControlData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRTControlData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRTControlData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRTControlData(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetIOData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetIOData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(34,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetIOData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetIOData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetIODataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetIODataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetIOData(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCoreData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCoreData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(35,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetCoreData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCoreData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCoreData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCoreDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCoreDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCoreData(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetSystemInfoData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetSystemInfoData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(36,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetSystemInfoData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetSystemInfoData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSystemInfoData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetSystemInfoData(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetMotionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetMotionData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(37,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetMotionData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetMotionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMotionData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetMotionDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetMotionDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMotionData(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetStateData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetStateData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(38,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetStateData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetStateData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetStateDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetStateDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetStateData(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetViolationData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetViolationData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(39,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetViolationData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetViolationData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetViolationData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetViolationDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetViolationDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetViolationData(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetProgramState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetProgramState() {
      ::grpc::Service::experimental().MarkMethodRawCallback(40,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetProgramState(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetProgramState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProgramState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetProgramStateReq* /*request*/, ::IndyFramework::Protobuf::Control::SetProgramStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetProgramState(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_InverseKinematics() {
      ::grpc::Service::experimental().MarkMethodRawCallback(41,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->InverseKinematics(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq* /*request*/, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void InverseKinematics(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CheckAproachRetractValid() {
      ::grpc::Service::experimental().MarkMethodRawCallback(42,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CheckAproachRetractValid(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq* /*request*/, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPalletPointList() {
      ::grpc::Service::experimental().MarkMethodRawCallback(43,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetPalletPointList(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPalletPointList(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CalculateRelativePose() {
      ::grpc::Service::experimental().MarkMethodRawCallback(44,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CalculateRelativePose(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq* /*request*/, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::experimental().MarkMethodRawCallback(45,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CalculateCurrentPoseRel(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq* /*request*/, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetDI() {
      ::grpc::Service::experimental().MarkMethodRawCallback(46,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetDI(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetDIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetDI(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetDI() {
      ::grpc::Service::experimental().MarkMethodRawCallback(47,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetDI(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetDIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetDI(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetDO() {
      ::grpc::Service::experimental().MarkMethodRawCallback(48,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetDO(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetDOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetDO(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetDO() {
      ::grpc::Service::experimental().MarkMethodRawCallback(49,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetDO(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetDOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetDO(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAI() {
      ::grpc::Service::experimental().MarkMethodRawCallback(50,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetAI(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAI(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetAI() {
      ::grpc::Service::experimental().MarkMethodRawCallback(51,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetAI(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetAI(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAO() {
      ::grpc::Service::experimental().MarkMethodRawCallback(52,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetAO(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAO(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetAO() {
      ::grpc::Service::experimental().MarkMethodRawCallback(53,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetAO(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetAO(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetEndDI() {
      ::grpc::Service::experimental().MarkMethodRawCallback(54,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetEndDI(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndDIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetEndDI(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetEndDI() {
      ::grpc::Service::experimental().MarkMethodRawCallback(55,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetEndDI(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndDIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetEndDI(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetEndDO() {
      ::grpc::Service::experimental().MarkMethodRawCallback(56,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetEndDO(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndDOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetEndDO(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetEndDO() {
      ::grpc::Service::experimental().MarkMethodRawCallback(57,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetEndDO(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndDOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetEndDO(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetEndAI() {
      ::grpc::Service::experimental().MarkMethodRawCallback(58,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetEndAI(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndAIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetEndAI(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetEndAI() {
      ::grpc::Service::experimental().MarkMethodRawCallback(59,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetEndAI(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndAIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetEndAI(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetEndAO() {
      ::grpc::Service::experimental().MarkMethodRawCallback(60,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetEndAO(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndAOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetEndAO(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetEndAO() {
      ::grpc::Service::experimental().MarkMethodRawCallback(61,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetEndAO(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndAOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetEndAO(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetJointControlGain() {
      ::grpc::Service::experimental().MarkMethodRawCallback(62,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetJointControlGain(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetJointControlGain(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetJointControlGain() {
      ::grpc::Service::experimental().MarkMethodRawCallback(63,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetJointControlGain(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetJointControlGain(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetTaskControlGain() {
      ::grpc::Service::experimental().MarkMethodRawCallback(64,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetTaskControlGain(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetTaskControlGain(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTaskControlGain() {
      ::grpc::Service::experimental().MarkMethodRawCallback(65,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetTaskControlGain(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetTaskControlGain(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetImpedanceControlGain() {
      ::grpc::Service::experimental().MarkMethodRawCallback(66,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetImpedanceControlGain(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetImpedanceControlGain() {
      ::grpc::Service::experimental().MarkMethodRawCallback(67,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetImpedanceControlGain(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetFricComp() {
      ::grpc::Service::experimental().MarkMethodRawCallback(68,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetFricComp(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetFricCompReq* /*request*/, ::IndyFramework::Protobuf::Control::SetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetFricComp(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetFricComp() {
      ::grpc::Service::experimental().MarkMethodRawCallback(69,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetFricComp(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetFricCompReq* /*request*/, ::IndyFramework::Protobuf::Control::GetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetFricComp(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetMountPos() {
      ::grpc::Service::experimental().MarkMethodRawCallback(70,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetMountPos(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetMountPosReq* /*request*/, ::IndyFramework::Protobuf::Control::SetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetMountPos(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetMountPos() {
      ::grpc::Service::experimental().MarkMethodRawCallback(71,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetMountPos(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetMountPosReq* /*request*/, ::IndyFramework::Protobuf::Control::GetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMountPos(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetToolProperty() {
      ::grpc::Service::experimental().MarkMethodRawCallback(72,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetToolProperty(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetToolProperty(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetToolProperty() {
      ::grpc::Service::experimental().MarkMethodRawCallback(73,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetToolProperty(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetToolProperty(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetCollSensLevel() {
      ::grpc::Service::experimental().MarkMethodRawCallback(74,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetCollSensLevel(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetCollSensLevel(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCollSensLevel() {
      ::grpc::Service::experimental().MarkMethodRawCallback(75,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetCollSensLevel(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCollSensLevel(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetCollSensParam() {
      ::grpc::Service::experimental().MarkMethodRawCallback(76,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetCollSensParam(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetCollSensParam(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCollSensParam() {
      ::grpc::Service::experimental().MarkMethodRawCallback(77,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetCollSensParam(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCollSensParam(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetCollPolicy() {
      ::grpc::Service::experimental().MarkMethodRawCallback(78,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetCollPolicy(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetCollPolicy(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCollPolicy() {
      ::grpc::Service::experimental().MarkMethodRawCallback(79,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetCollPolicy(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCollPolicy(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCollTuningParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCollTuningParam() {
      ::grpc::Service::experimental().MarkMethodRawCallback(80,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetCollTuningParam(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCollTuningParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollTuningParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCollTuningParam(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetSafetyLimitConfig() {
      ::grpc::Service::experimental().MarkMethodRawCallback(81,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetSafetyLimitConfig(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetSafetyLimitConfig() {
      ::grpc::Service::experimental().MarkMethodRawCallback(82,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetSafetyLimitConfig(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetSafetyStopConfig() {
      ::grpc::Service::experimental().MarkMethodRawCallback(83,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetSafetyStopConfig(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetSafetyStopConfig() {
      ::grpc::Service::experimental().MarkMethodRawCallback(84,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetSafetyStopConfig(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetEL5001 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetEL5001() {
      ::grpc::Service::experimental().MarkMethodRawCallback(85,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetEL5001(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetEL5001() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5001(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEL5001Req* /*request*/, ::IndyFramework::Protobuf::Control::GetEL5001Res* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetEL5001(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetEL5101 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetEL5101() {
      ::grpc::Service::experimental().MarkMethodRawCallback(86,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetEL5101(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetEL5101() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5101(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEL5101Req* /*request*/, ::IndyFramework::Protobuf::Control::GetEL5101Res* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetEL5101(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AMoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AMoveJ() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveJReq, ::IndyFramework::Protobuf::Control::AMoveJRes>(std::bind(&WithStreamedUnaryMethod_AMoveJ<BaseClass>::StreamedAMoveJ, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AMoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AMoveJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveJReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveJRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAMoveJ(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::AMoveJReq,::IndyFramework::Protobuf::Control::AMoveJRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AMoveJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AMoveJT() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveJTReq, ::IndyFramework::Protobuf::Control::AMoveJTRes>(std::bind(&WithStreamedUnaryMethod_AMoveJT<BaseClass>::StreamedAMoveJT, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AMoveJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AMoveJT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveJTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveJTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAMoveJT(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::AMoveJTReq,::IndyFramework::Protobuf::Control::AMoveJTRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AMoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AMoveL() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveLReq, ::IndyFramework::Protobuf::Control::AMoveLRes>(std::bind(&WithStreamedUnaryMethod_AMoveL<BaseClass>::StreamedAMoveL, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AMoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AMoveL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveLReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAMoveL(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::AMoveLReq,::IndyFramework::Protobuf::Control::AMoveLRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AMoveLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AMoveLT() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveLTReq, ::IndyFramework::Protobuf::Control::AMoveLTRes>(std::bind(&WithStreamedUnaryMethod_AMoveLT<BaseClass>::StreamedAMoveLT, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AMoveLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AMoveLT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveLTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveLTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAMoveLT(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::AMoveLTReq,::IndyFramework::Protobuf::Control::AMoveLTRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AMoveC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AMoveC() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveCReq, ::IndyFramework::Protobuf::Control::AMoveCRes>(std::bind(&WithStreamedUnaryMethod_AMoveC<BaseClass>::StreamedAMoveC, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AMoveC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AMoveC(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveCReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveCRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAMoveC(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::AMoveCReq,::IndyFramework::Protobuf::Control::AMoveCRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AMoveCT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AMoveCT() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::AMoveCTReq, ::IndyFramework::Protobuf::Control::AMoveCTRes>(std::bind(&WithStreamedUnaryMethod_AMoveCT<BaseClass>::StreamedAMoveCT, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AMoveCT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AMoveCT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMoveCTReq* /*request*/, ::IndyFramework::Protobuf::Control::AMoveCTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAMoveCT(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::AMoveCTReq,::IndyFramework::Protobuf::Control::AMoveCTRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AWaitIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AWaitIO() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::AWaitIOReq, ::IndyFramework::Protobuf::Control::AWaitIORes>(std::bind(&WithStreamedUnaryMethod_AWaitIO<BaseClass>::StreamedAWaitIO, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AWaitIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AWaitIO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitIOReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitIORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAWaitIO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::AWaitIOReq,::IndyFramework::Protobuf::Control::AWaitIORes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AWaitTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AWaitTime() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::AWaitTimeReq, ::IndyFramework::Protobuf::Control::AWaitTimeRes>(std::bind(&WithStreamedUnaryMethod_AWaitTime<BaseClass>::StreamedAWaitTime, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AWaitTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AWaitTime(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitTimeReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAWaitTime(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::AWaitTimeReq,::IndyFramework::Protobuf::Control::AWaitTimeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AWaitProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AWaitProgress() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::AWaitProgressReq, ::IndyFramework::Protobuf::Control::AWaitProgressRes>(std::bind(&WithStreamedUnaryMethod_AWaitProgress<BaseClass>::StreamedAWaitProgress, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AWaitProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AWaitProgress(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitProgressReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitProgressRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAWaitProgress(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::AWaitProgressReq,::IndyFramework::Protobuf::Control::AWaitProgressRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AWaitTraj : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AWaitTraj() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::AWaitTrajReq, ::IndyFramework::Protobuf::Control::AWaitTrajRes>(std::bind(&WithStreamedUnaryMethod_AWaitTraj<BaseClass>::StreamedAWaitTraj, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AWaitTraj() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AWaitTraj(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitTrajReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitTrajRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAWaitTraj(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::AWaitTrajReq,::IndyFramework::Protobuf::Control::AWaitTrajRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AWaitRadius : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AWaitRadius() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::AWaitRadiusReq, ::IndyFramework::Protobuf::Control::AWaitRadiusRes>(std::bind(&WithStreamedUnaryMethod_AWaitRadius<BaseClass>::StreamedAWaitRadius, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AWaitRadius() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AWaitRadius(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AWaitRadiusReq* /*request*/, ::IndyFramework::Protobuf::Control::AWaitRadiusRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAWaitRadius(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::AWaitRadiusReq,::IndyFramework::Protobuf::Control::AWaitRadiusRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AMotionStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AMotionStop() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::AMotionStopReq, ::IndyFramework::Protobuf::Control::AMotionStopRes>(std::bind(&WithStreamedUnaryMethod_AMotionStop<BaseClass>::StreamedAMotionStop, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AMotionStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AMotionStop(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::AMotionStopReq* /*request*/, ::IndyFramework::Protobuf::Control::AMotionStopRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAMotionStop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::AMotionStopReq,::IndyFramework::Protobuf::Control::AMotionStopRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveSJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveSJ() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::MoveSJReq, ::IndyFramework::Protobuf::Control::MoveSJRes>(std::bind(&WithStreamedUnaryMethod_MoveSJ<BaseClass>::StreamedMoveSJ, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_MoveSJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveSJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSJReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSJRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveSJ(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::MoveSJReq,::IndyFramework::Protobuf::Control::MoveSJRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveSJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveSJT() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::MoveSJTReq, ::IndyFramework::Protobuf::Control::MoveSJTRes>(std::bind(&WithStreamedUnaryMethod_MoveSJT<BaseClass>::StreamedMoveSJT, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_MoveSJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveSJT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSJTReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSJTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveSJT(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::MoveSJTReq,::IndyFramework::Protobuf::Control::MoveSJTRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveSL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveSL() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::MoveSLReq, ::IndyFramework::Protobuf::Control::MoveSLRes>(std::bind(&WithStreamedUnaryMethod_MoveSL<BaseClass>::StreamedMoveSL, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_MoveSL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveSL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSLReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveSL(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::MoveSLReq,::IndyFramework::Protobuf::Control::MoveSLRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveSLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveSLT() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::MoveSLTReq, ::IndyFramework::Protobuf::Control::MoveSLTRes>(std::bind(&WithStreamedUnaryMethod_MoveSLT<BaseClass>::StreamedMoveSLT, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_MoveSLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveSLT(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSLTReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSLTRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveSLT(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::MoveSLTReq,::IndyFramework::Protobuf::Control::MoveSLTRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveSpiral : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveSpiral() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::MoveSpiralReq, ::IndyFramework::Protobuf::Control::MoveSpiralRes>(std::bind(&WithStreamedUnaryMethod_MoveSpiral<BaseClass>::StreamedMoveSpiral, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_MoveSpiral() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveSpiral(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::MoveSpiralReq* /*request*/, ::IndyFramework::Protobuf::Control::MoveSpiralRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveSpiral(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::MoveSpiralReq,::IndyFramework::Protobuf::Control::MoveSpiralRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRefFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetRefFrame() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetRefFrameReq, ::IndyFramework::Protobuf::Control::SetRefFrameRes>(std::bind(&WithStreamedUnaryMethod_SetRefFrame<BaseClass>::StreamedSetRefFrame, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetRefFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRefFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetRefFrameReq* /*request*/, ::IndyFramework::Protobuf::Control::SetRefFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRefFrame(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetRefFrameReq,::IndyFramework::Protobuf::Control::SetRefFrameRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRefFramePlanar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetRefFramePlanar() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>(std::bind(&WithStreamedUnaryMethod_SetRefFramePlanar<BaseClass>::StreamedSetRefFramePlanar, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetRefFramePlanar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRefFramePlanar(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq* /*request*/, ::IndyFramework::Protobuf::Control::SetRefFramePlanarRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRefFramePlanar(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetRefFramePlanarReq,::IndyFramework::Protobuf::Control::SetRefFramePlanarRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetToolFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetToolFrame() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetToolFrameReq, ::IndyFramework::Protobuf::Control::SetToolFrameRes>(std::bind(&WithStreamedUnaryMethod_SetToolFrame<BaseClass>::StreamedSetToolFrame, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetToolFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetToolFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetToolFrameReq* /*request*/, ::IndyFramework::Protobuf::Control::SetToolFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetToolFrame(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetToolFrameReq,::IndyFramework::Protobuf::Control::SetToolFrameRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSpeedRatio() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetSpeedRatioReq, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes>(std::bind(&WithStreamedUnaryMethod_SetSpeedRatio<BaseClass>::StreamedSetSpeedRatio, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSpeedRatio(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetSpeedRatioReq,::IndyFramework::Protobuf::Control::SetSpeedRatioRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCommandSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCommandSpeedRatio() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>(std::bind(&WithStreamedUnaryMethod_SetCommandSpeedRatio<BaseClass>::StreamedSetCommandSpeedRatio, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetCommandSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCommandSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCommandSpeedRatio(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetCommandSpeedRatioReq,::IndyFramework::Protobuf::Control::SetCommandSpeedRatioRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Reboot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Reboot() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::RebootReq, ::IndyFramework::Protobuf::Control::RebootRes>(std::bind(&WithStreamedUnaryMethod_Reboot<BaseClass>::StreamedReboot, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Reboot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Reboot(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::RebootReq* /*request*/, ::IndyFramework::Protobuf::Control::RebootRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReboot(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::RebootReq,::IndyFramework::Protobuf::Control::RebootRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Recover() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::RecoverReq, ::IndyFramework::Protobuf::Control::RecoverRes>(std::bind(&WithStreamedUnaryMethod_Recover<BaseClass>::StreamedRecover, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::RecoverReq* /*request*/, ::IndyFramework::Protobuf::Control::RecoverRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRecover(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::RecoverReq,::IndyFramework::Protobuf::Control::RecoverRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Stop() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::StopReq, ::IndyFramework::Protobuf::Control::StopRes>(std::bind(&WithStreamedUnaryMethod_Stop<BaseClass>::StreamedStop, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::StopReq* /*request*/, ::IndyFramework::Protobuf::Control::StopRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::StopReq,::IndyFramework::Protobuf::Control::StopRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Pause() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::PauseReq, ::IndyFramework::Protobuf::Control::PauseRes>(std::bind(&WithStreamedUnaryMethod_Pause<BaseClass>::StreamedPause, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Pause(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::PauseReq* /*request*/, ::IndyFramework::Protobuf::Control::PauseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPause(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::PauseReq,::IndyFramework::Protobuf::Control::PauseRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Resume() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::ResumeReq, ::IndyFramework::Protobuf::Control::ResumeRes>(std::bind(&WithStreamedUnaryMethod_Resume<BaseClass>::StreamedResume, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Resume(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::ResumeReq* /*request*/, ::IndyFramework::Protobuf::Control::ResumeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::ResumeReq,::IndyFramework::Protobuf::Control::ResumeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Brake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Brake() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::BrakeReq, ::IndyFramework::Protobuf::Control::BrakeRes>(std::bind(&WithStreamedUnaryMethod_Brake<BaseClass>::StreamedBrake, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Brake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Brake(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::BrakeReq* /*request*/, ::IndyFramework::Protobuf::Control::BrakeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBrake(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::BrakeReq,::IndyFramework::Protobuf::Control::BrakeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Servo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Servo() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::ServoReq, ::IndyFramework::Protobuf::Control::ServoRes>(std::bind(&WithStreamedUnaryMethod_Servo<BaseClass>::StreamedServo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Servo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Servo(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::ServoReq* /*request*/, ::IndyFramework::Protobuf::Control::ServoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedServo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::ServoReq,::IndyFramework::Protobuf::Control::ServoRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetAutoServoOff() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetAutoServoOffReq, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes>(std::bind(&WithStreamedUnaryMethod_SetAutoServoOff<BaseClass>::StreamedSetAutoServoOff, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetAutoServoOff(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetAutoServoOffReq,::IndyFramework::Protobuf::Control::SetAutoServoOffRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAutoServoOff() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetAutoServoOffReq, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes>(std::bind(&WithStreamedUnaryMethod_GetAutoServoOff<BaseClass>::StreamedGetAutoServoOff, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAutoServoOff(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetAutoServoOffReq,::IndyFramework::Protobuf::Control::GetAutoServoOffRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SimulationMode() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SimulationModeReq, ::IndyFramework::Protobuf::Control::SimulationModeRes>(std::bind(&WithStreamedUnaryMethod_SimulationMode<BaseClass>::StreamedSimulationMode, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SimulationMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SimulationModeReq* /*request*/, ::IndyFramework::Protobuf::Control::SimulationModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSimulationMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SimulationModeReq,::IndyFramework::Protobuf::Control::SimulationModeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DirectTeachingMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DirectTeachingMode() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::DirectTeachingModeReq, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes>(std::bind(&WithStreamedUnaryMethod_DirectTeachingMode<BaseClass>::StreamedDirectTeachingMode, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DirectTeachingMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DirectTeachingMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::DirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::Control::DirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDirectTeachingMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::DirectTeachingModeReq,::IndyFramework::Protobuf::Control::DirectTeachingModeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRTControlData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRTControlData() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetRTControlDataReq, ::IndyFramework::Protobuf::Control::GetRTControlDataRes>(std::bind(&WithStreamedUnaryMethod_GetRTControlData<BaseClass>::StreamedGetRTControlData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetRTControlData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRTControlData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetRTControlDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetRTControlDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRTControlData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetRTControlDataReq,::IndyFramework::Protobuf::Control::GetRTControlDataRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetIOData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetIOData() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetIODataReq, ::IndyFramework::Protobuf::Control::GetIODataRes>(std::bind(&WithStreamedUnaryMethod_GetIOData<BaseClass>::StreamedGetIOData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetIOData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetIOData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetIODataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetIODataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetIOData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetIODataReq,::IndyFramework::Protobuf::Control::GetIODataRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCoreData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCoreData() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetCoreDataReq, ::IndyFramework::Protobuf::Control::GetCoreDataRes>(std::bind(&WithStreamedUnaryMethod_GetCoreData<BaseClass>::StreamedGetCoreData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetCoreData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCoreData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCoreDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCoreDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCoreData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetCoreDataReq,::IndyFramework::Protobuf::Control::GetCoreDataRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSystemInfoData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSystemInfoData() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>(std::bind(&WithStreamedUnaryMethod_GetSystemInfoData<BaseClass>::StreamedGetSystemInfoData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetSystemInfoData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSystemInfoData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSystemInfoDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSystemInfoData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetSystemInfoDataReq,::IndyFramework::Protobuf::Control::GetSystemInfoDataRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMotionData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMotionData() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetMotionDataReq, ::IndyFramework::Protobuf::Control::GetMotionDataRes>(std::bind(&WithStreamedUnaryMethod_GetMotionData<BaseClass>::StreamedGetMotionData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetMotionData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMotionData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetMotionDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetMotionDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMotionData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetMotionDataReq,::IndyFramework::Protobuf::Control::GetMotionDataRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetStateData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetStateData() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetStateDataReq, ::IndyFramework::Protobuf::Control::GetStateDataRes>(std::bind(&WithStreamedUnaryMethod_GetStateData<BaseClass>::StreamedGetStateData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetStateData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStateData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetStateDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetStateDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetStateData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetStateDataReq,::IndyFramework::Protobuf::Control::GetStateDataRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetViolationData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetViolationData() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetViolationDataReq, ::IndyFramework::Protobuf::Control::GetViolationDataRes>(std::bind(&WithStreamedUnaryMethod_GetViolationData<BaseClass>::StreamedGetViolationData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetViolationData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetViolationData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetViolationDataReq* /*request*/, ::IndyFramework::Protobuf::Control::GetViolationDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetViolationData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetViolationDataReq,::IndyFramework::Protobuf::Control::GetViolationDataRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetProgramState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetProgramState() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetProgramStateReq, ::IndyFramework::Protobuf::Control::SetProgramStateRes>(std::bind(&WithStreamedUnaryMethod_SetProgramState<BaseClass>::StreamedSetProgramState, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetProgramState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetProgramState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetProgramStateReq* /*request*/, ::IndyFramework::Protobuf::Control::SetProgramStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetProgramState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetProgramStateReq,::IndyFramework::Protobuf::Control::SetProgramStateRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::InverseKinematicsReq, ::IndyFramework::Protobuf::Control::InverseKinematicsRes>(std::bind(&WithStreamedUnaryMethod_InverseKinematics<BaseClass>::StreamedInverseKinematics, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::InverseKinematicsReq* /*request*/, ::IndyFramework::Protobuf::Control::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInverseKinematics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::InverseKinematicsReq,::IndyFramework::Protobuf::Control::InverseKinematicsRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>(std::bind(&WithStreamedUnaryMethod_CheckAproachRetractValid<BaseClass>::StreamedCheckAproachRetractValid, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq* /*request*/, ::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckAproachRetractValid(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::CheckAproachRetractValidReq,::IndyFramework::Protobuf::Control::CheckAproachRetractValidRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetPalletPointListReq, ::IndyFramework::Protobuf::Control::GetPalletPointListRes>(std::bind(&WithStreamedUnaryMethod_GetPalletPointList<BaseClass>::StreamedGetPalletPointList, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::Control::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPalletPointList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetPalletPointListReq,::IndyFramework::Protobuf::Control::GetPalletPointListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>(std::bind(&WithStreamedUnaryMethod_CalculateRelativePose<BaseClass>::StreamedCalculateRelativePose, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq* /*request*/, ::IndyFramework::Protobuf::Control::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCalculateRelativePose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::CalculateRelativePoseReq,::IndyFramework::Protobuf::Control::CalculateRelativePoseRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>(std::bind(&WithStreamedUnaryMethod_CalculateCurrentPoseRel<BaseClass>::StreamedCalculateCurrentPoseRel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq* /*request*/, ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCalculateCurrentPoseRel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelReq,::IndyFramework::Protobuf::Control::CalculateCurrentPoseRelRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDI() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetDIReq, ::IndyFramework::Protobuf::Control::GetDIRes>(std::bind(&WithStreamedUnaryMethod_GetDI<BaseClass>::StreamedGetDI, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetDIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetDIReq,::IndyFramework::Protobuf::Control::GetDIRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetDI() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetDIReq, ::IndyFramework::Protobuf::Control::SetDIRes>(std::bind(&WithStreamedUnaryMethod_SetDI<BaseClass>::StreamedSetDI, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetDIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetDI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetDIReq,::IndyFramework::Protobuf::Control::SetDIRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetDO() {
      ::grpc::Service::MarkMethodStreamed(48,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetDOReq, ::IndyFramework::Protobuf::Control::SetDORes>(std::bind(&WithStreamedUnaryMethod_SetDO<BaseClass>::StreamedSetDO, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetDOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetDOReq,::IndyFramework::Protobuf::Control::SetDORes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDO() {
      ::grpc::Service::MarkMethodStreamed(49,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetDOReq, ::IndyFramework::Protobuf::Control::GetDORes>(std::bind(&WithStreamedUnaryMethod_GetDO<BaseClass>::StreamedGetDO, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetDOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetDOReq,::IndyFramework::Protobuf::Control::GetDORes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAI() {
      ::grpc::Service::MarkMethodStreamed(50,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetAIReq, ::IndyFramework::Protobuf::Control::GetAIRes>(std::bind(&WithStreamedUnaryMethod_GetAI<BaseClass>::StreamedGetAI, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetAIReq,::IndyFramework::Protobuf::Control::GetAIRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetAI() {
      ::grpc::Service::MarkMethodStreamed(51,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetAIReq, ::IndyFramework::Protobuf::Control::SetAIRes>(std::bind(&WithStreamedUnaryMethod_SetAI<BaseClass>::StreamedSetAI, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetAI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetAIReq,::IndyFramework::Protobuf::Control::SetAIRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAO() {
      ::grpc::Service::MarkMethodStreamed(52,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetAOReq, ::IndyFramework::Protobuf::Control::GetAORes>(std::bind(&WithStreamedUnaryMethod_GetAO<BaseClass>::StreamedGetAO, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetAOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetAOReq,::IndyFramework::Protobuf::Control::GetAORes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetAO() {
      ::grpc::Service::MarkMethodStreamed(53,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetAOReq, ::IndyFramework::Protobuf::Control::SetAORes>(std::bind(&WithStreamedUnaryMethod_SetAO<BaseClass>::StreamedSetAO, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetAOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetAO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetAOReq,::IndyFramework::Protobuf::Control::SetAORes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEndDI() {
      ::grpc::Service::MarkMethodStreamed(54,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetEndDIReq, ::IndyFramework::Protobuf::Control::GetEndDIRes>(std::bind(&WithStreamedUnaryMethod_GetEndDI<BaseClass>::StreamedGetEndDI, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEndDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndDIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEndDI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetEndDIReq,::IndyFramework::Protobuf::Control::GetEndDIRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEndDI() {
      ::grpc::Service::MarkMethodStreamed(55,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetEndDIReq, ::IndyFramework::Protobuf::Control::SetEndDIRes>(std::bind(&WithStreamedUnaryMethod_SetEndDI<BaseClass>::StreamedSetEndDI, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEndDI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndDIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndDIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEndDI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetEndDIReq,::IndyFramework::Protobuf::Control::SetEndDIRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEndDO() {
      ::grpc::Service::MarkMethodStreamed(56,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetEndDOReq, ::IndyFramework::Protobuf::Control::SetEndDORes>(std::bind(&WithStreamedUnaryMethod_SetEndDO<BaseClass>::StreamedSetEndDO, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndDOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEndDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetEndDOReq,::IndyFramework::Protobuf::Control::SetEndDORes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEndDO() {
      ::grpc::Service::MarkMethodStreamed(57,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetEndDOReq, ::IndyFramework::Protobuf::Control::GetEndDORes>(std::bind(&WithStreamedUnaryMethod_GetEndDO<BaseClass>::StreamedGetEndDO, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndDOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndDORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEndDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetEndDOReq,::IndyFramework::Protobuf::Control::GetEndDORes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEndAI() {
      ::grpc::Service::MarkMethodStreamed(58,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetEndAIReq, ::IndyFramework::Protobuf::Control::GetEndAIRes>(std::bind(&WithStreamedUnaryMethod_GetEndAI<BaseClass>::StreamedGetEndAI, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEndAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndAIReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEndAI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetEndAIReq,::IndyFramework::Protobuf::Control::GetEndAIRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEndAI() {
      ::grpc::Service::MarkMethodStreamed(59,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetEndAIReq, ::IndyFramework::Protobuf::Control::SetEndAIRes>(std::bind(&WithStreamedUnaryMethod_SetEndAI<BaseClass>::StreamedSetEndAI, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEndAI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndAIReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndAIRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEndAI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetEndAIReq,::IndyFramework::Protobuf::Control::SetEndAIRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEndAO() {
      ::grpc::Service::MarkMethodStreamed(60,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetEndAOReq, ::IndyFramework::Protobuf::Control::GetEndAORes>(std::bind(&WithStreamedUnaryMethod_GetEndAO<BaseClass>::StreamedGetEndAO, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEndAOReq* /*request*/, ::IndyFramework::Protobuf::Control::GetEndAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEndAO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetEndAOReq,::IndyFramework::Protobuf::Control::GetEndAORes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEndAO() {
      ::grpc::Service::MarkMethodStreamed(61,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetEndAOReq, ::IndyFramework::Protobuf::Control::SetEndAORes>(std::bind(&WithStreamedUnaryMethod_SetEndAO<BaseClass>::StreamedSetEndAO, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetEndAOReq* /*request*/, ::IndyFramework::Protobuf::Control::SetEndAORes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEndAO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetEndAOReq,::IndyFramework::Protobuf::Control::SetEndAORes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetJointControlGain() {
      ::grpc::Service::MarkMethodStreamed(62,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetJointControlGainReq, ::IndyFramework::Protobuf::Control::SetJointControlGainRes>(std::bind(&WithStreamedUnaryMethod_SetJointControlGain<BaseClass>::StreamedSetJointControlGain, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetJointControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetJointControlGainReq,::IndyFramework::Protobuf::Control::SetJointControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetJointControlGain() {
      ::grpc::Service::MarkMethodStreamed(63,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetJointControlGainReq, ::IndyFramework::Protobuf::Control::GetJointControlGainRes>(std::bind(&WithStreamedUnaryMethod_GetJointControlGain<BaseClass>::StreamedGetJointControlGain, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetJointControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetJointControlGainReq,::IndyFramework::Protobuf::Control::GetJointControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetTaskControlGain() {
      ::grpc::Service::MarkMethodStreamed(64,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetTaskControlGainReq, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes>(std::bind(&WithStreamedUnaryMethod_SetTaskControlGain<BaseClass>::StreamedSetTaskControlGain, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetTaskControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetTaskControlGainReq,::IndyFramework::Protobuf::Control::SetTaskControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTaskControlGain() {
      ::grpc::Service::MarkMethodStreamed(65,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetTaskControlGainReq, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes>(std::bind(&WithStreamedUnaryMethod_GetTaskControlGain<BaseClass>::StreamedGetTaskControlGain, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTaskControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetTaskControlGainReq,::IndyFramework::Protobuf::Control::GetTaskControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetImpedanceControlGain() {
      ::grpc::Service::MarkMethodStreamed(66,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>(std::bind(&WithStreamedUnaryMethod_SetImpedanceControlGain<BaseClass>::StreamedSetImpedanceControlGain, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetImpedanceControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetImpedanceControlGainReq,::IndyFramework::Protobuf::Control::SetImpedanceControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetImpedanceControlGain() {
      ::grpc::Service::MarkMethodStreamed(67,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>(std::bind(&WithStreamedUnaryMethod_GetImpedanceControlGain<BaseClass>::StreamedGetImpedanceControlGain, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetImpedanceControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetImpedanceControlGainReq,::IndyFramework::Protobuf::Control::GetImpedanceControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetFricComp() {
      ::grpc::Service::MarkMethodStreamed(68,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetFricCompReq, ::IndyFramework::Protobuf::Control::SetFricCompRes>(std::bind(&WithStreamedUnaryMethod_SetFricComp<BaseClass>::StreamedSetFricComp, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetFricCompReq* /*request*/, ::IndyFramework::Protobuf::Control::SetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetFricComp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetFricCompReq,::IndyFramework::Protobuf::Control::SetFricCompRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFricComp() {
      ::grpc::Service::MarkMethodStreamed(69,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetFricCompReq, ::IndyFramework::Protobuf::Control::GetFricCompRes>(std::bind(&WithStreamedUnaryMethod_GetFricComp<BaseClass>::StreamedGetFricComp, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetFricCompReq* /*request*/, ::IndyFramework::Protobuf::Control::GetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFricComp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetFricCompReq,::IndyFramework::Protobuf::Control::GetFricCompRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetMountPos() {
      ::grpc::Service::MarkMethodStreamed(70,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetMountPosReq, ::IndyFramework::Protobuf::Control::SetMountPosRes>(std::bind(&WithStreamedUnaryMethod_SetMountPos<BaseClass>::StreamedSetMountPos, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetMountPosReq* /*request*/, ::IndyFramework::Protobuf::Control::SetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetMountPos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetMountPosReq,::IndyFramework::Protobuf::Control::SetMountPosRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMountPos() {
      ::grpc::Service::MarkMethodStreamed(71,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetMountPosReq, ::IndyFramework::Protobuf::Control::GetMountPosRes>(std::bind(&WithStreamedUnaryMethod_GetMountPos<BaseClass>::StreamedGetMountPos, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetMountPosReq* /*request*/, ::IndyFramework::Protobuf::Control::GetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMountPos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetMountPosReq,::IndyFramework::Protobuf::Control::GetMountPosRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetToolProperty() {
      ::grpc::Service::MarkMethodStreamed(72,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetToolPropertyReq, ::IndyFramework::Protobuf::Control::SetToolPropertyRes>(std::bind(&WithStreamedUnaryMethod_SetToolProperty<BaseClass>::StreamedSetToolProperty, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::Control::SetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetToolProperty(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetToolPropertyReq,::IndyFramework::Protobuf::Control::SetToolPropertyRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetToolProperty() {
      ::grpc::Service::MarkMethodStreamed(73,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetToolPropertyReq, ::IndyFramework::Protobuf::Control::GetToolPropertyRes>(std::bind(&WithStreamedUnaryMethod_GetToolProperty<BaseClass>::StreamedGetToolProperty, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::Control::GetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetToolProperty(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetToolPropertyReq,::IndyFramework::Protobuf::Control::GetToolPropertyRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCollSensLevel() {
      ::grpc::Service::MarkMethodStreamed(74,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetCollSensLevelReq, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes>(std::bind(&WithStreamedUnaryMethod_SetCollSensLevel<BaseClass>::StreamedSetCollSensLevel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollSensLevelReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollSensLevelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCollSensLevel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetCollSensLevelReq,::IndyFramework::Protobuf::Control::SetCollSensLevelRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCollSensLevel() {
      ::grpc::Service::MarkMethodStreamed(75,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetCollSensLevelReq, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes>(std::bind(&WithStreamedUnaryMethod_GetCollSensLevel<BaseClass>::StreamedGetCollSensLevel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollSensLevelReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollSensLevelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCollSensLevel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetCollSensLevelReq,::IndyFramework::Protobuf::Control::GetCollSensLevelRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCollSensParam() {
      ::grpc::Service::MarkMethodStreamed(76,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetCollSensParamReq, ::IndyFramework::Protobuf::Control::SetCollSensParamRes>(std::bind(&WithStreamedUnaryMethod_SetCollSensParam<BaseClass>::StreamedSetCollSensParam, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollSensParamReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollSensParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCollSensParam(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetCollSensParamReq,::IndyFramework::Protobuf::Control::SetCollSensParamRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCollSensParam() {
      ::grpc::Service::MarkMethodStreamed(77,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetCollSensParamReq, ::IndyFramework::Protobuf::Control::GetCollSensParamRes>(std::bind(&WithStreamedUnaryMethod_GetCollSensParam<BaseClass>::StreamedGetCollSensParam, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollSensParamReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollSensParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCollSensParam(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetCollSensParamReq,::IndyFramework::Protobuf::Control::GetCollSensParamRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCollPolicy() {
      ::grpc::Service::MarkMethodStreamed(78,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetCollPolicyReq, ::IndyFramework::Protobuf::Control::SetCollPolicyRes>(std::bind(&WithStreamedUnaryMethod_SetCollPolicy<BaseClass>::StreamedSetCollPolicy, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetCollPolicyReq* /*request*/, ::IndyFramework::Protobuf::Control::SetCollPolicyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCollPolicy(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetCollPolicyReq,::IndyFramework::Protobuf::Control::SetCollPolicyRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCollPolicy() {
      ::grpc::Service::MarkMethodStreamed(79,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetCollPolicyReq, ::IndyFramework::Protobuf::Control::GetCollPolicyRes>(std::bind(&WithStreamedUnaryMethod_GetCollPolicy<BaseClass>::StreamedGetCollPolicy, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollPolicyReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollPolicyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCollPolicy(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetCollPolicyReq,::IndyFramework::Protobuf::Control::GetCollPolicyRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCollTuningParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCollTuningParam() {
      ::grpc::Service::MarkMethodStreamed(80,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetCollTuningParamReq, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes>(std::bind(&WithStreamedUnaryMethod_GetCollTuningParam<BaseClass>::StreamedGetCollTuningParam, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetCollTuningParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCollTuningParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetCollTuningParamReq* /*request*/, ::IndyFramework::Protobuf::Control::GetCollTuningParamRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCollTuningParam(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetCollTuningParamReq,::IndyFramework::Protobuf::Control::GetCollTuningParamRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodStreamed(81,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>(std::bind(&WithStreamedUnaryMethod_GetSafetyLimitConfig<BaseClass>::StreamedGetSafetyLimitConfig, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSafetyLimitConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetSafetyLimitConfigReq,::IndyFramework::Protobuf::Control::GetSafetyLimitConfigRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodStreamed(82,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>(std::bind(&WithStreamedUnaryMethod_SetSafetyLimitConfig<BaseClass>::StreamedSetSafetyLimitConfig, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSafetyLimitConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetSafetyLimitConfigReq,::IndyFramework::Protobuf::Control::SetSafetyLimitConfigRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSafetyStopConfig() {
      ::grpc::Service::MarkMethodStreamed(83,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>(std::bind(&WithStreamedUnaryMethod_GetSafetyStopConfig<BaseClass>::StreamedGetSafetyStopConfig, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSafetyStopConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetSafetyStopConfigReq,::IndyFramework::Protobuf::Control::GetSafetyStopConfigRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSafetyStopConfig() {
      ::grpc::Service::MarkMethodStreamed(84,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>(std::bind(&WithStreamedUnaryMethod_SetSafetyStopConfig<BaseClass>::StreamedSetSafetyStopConfig, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSafetyStopConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::SetSafetyStopConfigReq,::IndyFramework::Protobuf::Control::SetSafetyStopConfigRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEL5001 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEL5001() {
      ::grpc::Service::MarkMethodStreamed(85,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetEL5001Req, ::IndyFramework::Protobuf::Control::GetEL5001Res>(std::bind(&WithStreamedUnaryMethod_GetEL5001<BaseClass>::StreamedGetEL5001, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetEL5001() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEL5001(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEL5001Req* /*request*/, ::IndyFramework::Protobuf::Control::GetEL5001Res* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEL5001(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetEL5001Req,::IndyFramework::Protobuf::Control::GetEL5001Res>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEL5101 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEL5101() {
      ::grpc::Service::MarkMethodStreamed(86,
        new ::grpc::internal::StreamedUnaryHandler< ::IndyFramework::Protobuf::Control::GetEL5101Req, ::IndyFramework::Protobuf::Control::GetEL5101Res>(std::bind(&WithStreamedUnaryMethod_GetEL5101<BaseClass>::StreamedGetEL5101, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetEL5101() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEL5101(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::Control::GetEL5101Req* /*request*/, ::IndyFramework::Protobuf::Control::GetEL5101Res* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEL5101(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::Control::GetEL5101Req,::IndyFramework::Protobuf::Control::GetEL5101Res>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_AMoveJ<WithStreamedUnaryMethod_AMoveJT<WithStreamedUnaryMethod_AMoveL<WithStreamedUnaryMethod_AMoveLT<WithStreamedUnaryMethod_AMoveC<WithStreamedUnaryMethod_AMoveCT<WithStreamedUnaryMethod_AWaitIO<WithStreamedUnaryMethod_AWaitTime<WithStreamedUnaryMethod_AWaitProgress<WithStreamedUnaryMethod_AWaitTraj<WithStreamedUnaryMethod_AWaitRadius<WithStreamedUnaryMethod_AMotionStop<WithStreamedUnaryMethod_MoveSJ<WithStreamedUnaryMethod_MoveSJT<WithStreamedUnaryMethod_MoveSL<WithStreamedUnaryMethod_MoveSLT<WithStreamedUnaryMethod_MoveSpiral<WithStreamedUnaryMethod_SetRefFrame<WithStreamedUnaryMethod_SetRefFramePlanar<WithStreamedUnaryMethod_SetToolFrame<WithStreamedUnaryMethod_SetSpeedRatio<WithStreamedUnaryMethod_SetCommandSpeedRatio<WithStreamedUnaryMethod_Reboot<WithStreamedUnaryMethod_Recover<WithStreamedUnaryMethod_Stop<WithStreamedUnaryMethod_Pause<WithStreamedUnaryMethod_Resume<WithStreamedUnaryMethod_Brake<WithStreamedUnaryMethod_Servo<WithStreamedUnaryMethod_SetAutoServoOff<WithStreamedUnaryMethod_GetAutoServoOff<WithStreamedUnaryMethod_SimulationMode<WithStreamedUnaryMethod_DirectTeachingMode<WithStreamedUnaryMethod_GetRTControlData<WithStreamedUnaryMethod_GetIOData<WithStreamedUnaryMethod_GetCoreData<WithStreamedUnaryMethod_GetSystemInfoData<WithStreamedUnaryMethod_GetMotionData<WithStreamedUnaryMethod_GetStateData<WithStreamedUnaryMethod_GetViolationData<WithStreamedUnaryMethod_SetProgramState<WithStreamedUnaryMethod_InverseKinematics<WithStreamedUnaryMethod_CheckAproachRetractValid<WithStreamedUnaryMethod_GetPalletPointList<WithStreamedUnaryMethod_CalculateRelativePose<WithStreamedUnaryMethod_CalculateCurrentPoseRel<WithStreamedUnaryMethod_GetDI<WithStreamedUnaryMethod_SetDI<WithStreamedUnaryMethod_SetDO<WithStreamedUnaryMethod_GetDO<WithStreamedUnaryMethod_GetAI<WithStreamedUnaryMethod_SetAI<WithStreamedUnaryMethod_GetAO<WithStreamedUnaryMethod_SetAO<WithStreamedUnaryMethod_GetEndDI<WithStreamedUnaryMethod_SetEndDI<WithStreamedUnaryMethod_SetEndDO<WithStreamedUnaryMethod_GetEndDO<WithStreamedUnaryMethod_GetEndAI<WithStreamedUnaryMethod_SetEndAI<WithStreamedUnaryMethod_GetEndAO<WithStreamedUnaryMethod_SetEndAO<WithStreamedUnaryMethod_SetJointControlGain<WithStreamedUnaryMethod_GetJointControlGain<WithStreamedUnaryMethod_SetTaskControlGain<WithStreamedUnaryMethod_GetTaskControlGain<WithStreamedUnaryMethod_SetImpedanceControlGain<WithStreamedUnaryMethod_GetImpedanceControlGain<WithStreamedUnaryMethod_SetFricComp<WithStreamedUnaryMethod_GetFricComp<WithStreamedUnaryMethod_SetMountPos<WithStreamedUnaryMethod_GetMountPos<WithStreamedUnaryMethod_SetToolProperty<WithStreamedUnaryMethod_GetToolProperty<WithStreamedUnaryMethod_SetCollSensLevel<WithStreamedUnaryMethod_GetCollSensLevel<WithStreamedUnaryMethod_SetCollSensParam<WithStreamedUnaryMethod_GetCollSensParam<WithStreamedUnaryMethod_SetCollPolicy<WithStreamedUnaryMethod_GetCollPolicy<WithStreamedUnaryMethod_GetCollTuningParam<WithStreamedUnaryMethod_GetSafetyLimitConfig<WithStreamedUnaryMethod_SetSafetyLimitConfig<WithStreamedUnaryMethod_GetSafetyStopConfig<WithStreamedUnaryMethod_SetSafetyStopConfig<WithStreamedUnaryMethod_GetEL5001<WithStreamedUnaryMethod_GetEL5101<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_AMoveJ<WithStreamedUnaryMethod_AMoveJT<WithStreamedUnaryMethod_AMoveL<WithStreamedUnaryMethod_AMoveLT<WithStreamedUnaryMethod_AMoveC<WithStreamedUnaryMethod_AMoveCT<WithStreamedUnaryMethod_AWaitIO<WithStreamedUnaryMethod_AWaitTime<WithStreamedUnaryMethod_AWaitProgress<WithStreamedUnaryMethod_AWaitTraj<WithStreamedUnaryMethod_AWaitRadius<WithStreamedUnaryMethod_AMotionStop<WithStreamedUnaryMethod_MoveSJ<WithStreamedUnaryMethod_MoveSJT<WithStreamedUnaryMethod_MoveSL<WithStreamedUnaryMethod_MoveSLT<WithStreamedUnaryMethod_MoveSpiral<WithStreamedUnaryMethod_SetRefFrame<WithStreamedUnaryMethod_SetRefFramePlanar<WithStreamedUnaryMethod_SetToolFrame<WithStreamedUnaryMethod_SetSpeedRatio<WithStreamedUnaryMethod_SetCommandSpeedRatio<WithStreamedUnaryMethod_Reboot<WithStreamedUnaryMethod_Recover<WithStreamedUnaryMethod_Stop<WithStreamedUnaryMethod_Pause<WithStreamedUnaryMethod_Resume<WithStreamedUnaryMethod_Brake<WithStreamedUnaryMethod_Servo<WithStreamedUnaryMethod_SetAutoServoOff<WithStreamedUnaryMethod_GetAutoServoOff<WithStreamedUnaryMethod_SimulationMode<WithStreamedUnaryMethod_DirectTeachingMode<WithStreamedUnaryMethod_GetRTControlData<WithStreamedUnaryMethod_GetIOData<WithStreamedUnaryMethod_GetCoreData<WithStreamedUnaryMethod_GetSystemInfoData<WithStreamedUnaryMethod_GetMotionData<WithStreamedUnaryMethod_GetStateData<WithStreamedUnaryMethod_GetViolationData<WithStreamedUnaryMethod_SetProgramState<WithStreamedUnaryMethod_InverseKinematics<WithStreamedUnaryMethod_CheckAproachRetractValid<WithStreamedUnaryMethod_GetPalletPointList<WithStreamedUnaryMethod_CalculateRelativePose<WithStreamedUnaryMethod_CalculateCurrentPoseRel<WithStreamedUnaryMethod_GetDI<WithStreamedUnaryMethod_SetDI<WithStreamedUnaryMethod_SetDO<WithStreamedUnaryMethod_GetDO<WithStreamedUnaryMethod_GetAI<WithStreamedUnaryMethod_SetAI<WithStreamedUnaryMethod_GetAO<WithStreamedUnaryMethod_SetAO<WithStreamedUnaryMethod_GetEndDI<WithStreamedUnaryMethod_SetEndDI<WithStreamedUnaryMethod_SetEndDO<WithStreamedUnaryMethod_GetEndDO<WithStreamedUnaryMethod_GetEndAI<WithStreamedUnaryMethod_SetEndAI<WithStreamedUnaryMethod_GetEndAO<WithStreamedUnaryMethod_SetEndAO<WithStreamedUnaryMethod_SetJointControlGain<WithStreamedUnaryMethod_GetJointControlGain<WithStreamedUnaryMethod_SetTaskControlGain<WithStreamedUnaryMethod_GetTaskControlGain<WithStreamedUnaryMethod_SetImpedanceControlGain<WithStreamedUnaryMethod_GetImpedanceControlGain<WithStreamedUnaryMethod_SetFricComp<WithStreamedUnaryMethod_GetFricComp<WithStreamedUnaryMethod_SetMountPos<WithStreamedUnaryMethod_GetMountPos<WithStreamedUnaryMethod_SetToolProperty<WithStreamedUnaryMethod_GetToolProperty<WithStreamedUnaryMethod_SetCollSensLevel<WithStreamedUnaryMethod_GetCollSensLevel<WithStreamedUnaryMethod_SetCollSensParam<WithStreamedUnaryMethod_GetCollSensParam<WithStreamedUnaryMethod_SetCollPolicy<WithStreamedUnaryMethod_GetCollPolicy<WithStreamedUnaryMethod_GetCollTuningParam<WithStreamedUnaryMethod_GetSafetyLimitConfig<WithStreamedUnaryMethod_SetSafetyLimitConfig<WithStreamedUnaryMethod_GetSafetyStopConfig<WithStreamedUnaryMethod_SetSafetyStopConfig<WithStreamedUnaryMethod_GetEL5001<WithStreamedUnaryMethod_GetEL5101<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};
// ---------------------------------------------------------------- //
// Motion
// ---------------------------------------------------------------- //

}  // namespace Control
}  // namespace Protobuf
}  // namespace IndyFramework


#endif  // GRPC_control_2eproto__INCLUDED
