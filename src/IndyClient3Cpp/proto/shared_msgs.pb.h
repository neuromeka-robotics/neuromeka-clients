// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: shared_msgs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_shared_5fmsgs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_shared_5fmsgs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_shared_5fmsgs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_shared_5fmsgs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_shared_5fmsgs_2eproto;
namespace IndyFramework {
namespace Protobuf {
namespace Shared {
class AnalogSignal;
class AnalogSignalDefaultTypeInternal;
extern AnalogSignalDefaultTypeInternal _AnalogSignal_default_instance_;
class BoolVariable;
class BoolVariableDefaultTypeInternal;
extern BoolVariableDefaultTypeInternal _BoolVariable_default_instance_;
class DigitalSignal;
class DigitalSignalDefaultTypeInternal;
extern DigitalSignalDefaultTypeInternal _DigitalSignal_default_instance_;
class FloatVariable;
class FloatVariableDefaultTypeInternal;
extern FloatVariableDefaultTypeInternal _FloatVariable_default_instance_;
class IntVariable;
class IntVariableDefaultTypeInternal;
extern IntVariableDefaultTypeInternal _IntVariable_default_instance_;
class JPosVariable;
class JPosVariableDefaultTypeInternal;
extern JPosVariableDefaultTypeInternal _JPosVariable_default_instance_;
class ModbusVariable;
class ModbusVariableDefaultTypeInternal;
extern ModbusVariableDefaultTypeInternal _ModbusVariable_default_instance_;
class MoveSJPoint;
class MoveSJPointDefaultTypeInternal;
extern MoveSJPointDefaultTypeInternal _MoveSJPoint_default_instance_;
class MoveSJTPoint;
class MoveSJTPointDefaultTypeInternal;
extern MoveSJTPointDefaultTypeInternal _MoveSJTPoint_default_instance_;
class MoveSLPoint;
class MoveSLPointDefaultTypeInternal;
extern MoveSLPointDefaultTypeInternal _MoveSLPoint_default_instance_;
class MoveSLTPoint;
class MoveSLTPointDefaultTypeInternal;
extern MoveSLTPointDefaultTypeInternal _MoveSLTPoint_default_instance_;
class NamedJointPosition;
class NamedJointPositionDefaultTypeInternal;
extern NamedJointPositionDefaultTypeInternal _NamedJointPosition_default_instance_;
class NamedReferencePosition;
class NamedReferencePositionDefaultTypeInternal;
extern NamedReferencePositionDefaultTypeInternal _NamedReferencePosition_default_instance_;
class NamedTaskPosition;
class NamedTaskPositionDefaultTypeInternal;
extern NamedTaskPositionDefaultTypeInternal _NamedTaskPosition_default_instance_;
class PalletPoint;
class PalletPointDefaultTypeInternal;
extern PalletPointDefaultTypeInternal _PalletPoint_default_instance_;
class TPosVariable;
class TPosVariableDefaultTypeInternal;
extern TPosVariableDefaultTypeInternal _TPosVariable_default_instance_;
class Tool;
class ToolDefaultTypeInternal;
extern ToolDefaultTypeInternal _Tool_default_instance_;
class VisionServer;
class VisionServerDefaultTypeInternal;
extern VisionServerDefaultTypeInternal _VisionServer_default_instance_;
}  // namespace Shared
}  // namespace Protobuf
}  // namespace IndyFramework
PROTOBUF_NAMESPACE_OPEN
template<> ::IndyFramework::Protobuf::Shared::AnalogSignal* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::AnalogSignal>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::BoolVariable* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::BoolVariable>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::DigitalSignal* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::DigitalSignal>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::FloatVariable* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::FloatVariable>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::IntVariable* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::IntVariable>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::JPosVariable* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::JPosVariable>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::ModbusVariable* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::ModbusVariable>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::MoveSJPoint* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::MoveSJPoint>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::MoveSJTPoint* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::MoveSJTPoint>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::MoveSLPoint* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::MoveSLPoint>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::MoveSLTPoint* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::MoveSLTPoint>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::NamedJointPosition* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::NamedJointPosition>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::NamedReferencePosition* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::NamedReferencePosition>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::NamedTaskPosition* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::NamedTaskPosition>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::PalletPoint* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::PalletPoint>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::TPosVariable* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::TPosVariable>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::Tool* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::Tool>(Arena*);
template<> ::IndyFramework::Protobuf::Shared::VisionServer* Arena::CreateMaybeMessage<::IndyFramework::Protobuf::Shared::VisionServer>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace IndyFramework {
namespace Protobuf {
namespace Shared {

enum Tool_ToolType : int {
  Tool_ToolType_DIGITAL_OUTPUT = 0,
  Tool_ToolType_MODBUS = 1,
  Tool_ToolType_Tool_ToolType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Tool_ToolType_Tool_ToolType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Tool_ToolType_IsValid(int value);
constexpr Tool_ToolType Tool_ToolType_ToolType_MIN = Tool_ToolType_DIGITAL_OUTPUT;
constexpr Tool_ToolType Tool_ToolType_ToolType_MAX = Tool_ToolType_MODBUS;
constexpr int Tool_ToolType_ToolType_ARRAYSIZE = Tool_ToolType_ToolType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Tool_ToolType_descriptor();
template<typename T>
inline const std::string& Tool_ToolType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Tool_ToolType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Tool_ToolType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Tool_ToolType_descriptor(), enum_t_value);
}
inline bool Tool_ToolType_Parse(
    const std::string& name, Tool_ToolType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Tool_ToolType>(
    Tool_ToolType_descriptor(), name, value);
}
enum VisionServer_VisionServerType : int {
  VisionServer_VisionServerType_INDYEYE = 0,
  VisionServer_VisionServerType_PICKIT = 1,
  VisionServer_VisionServerType_OMRON = 2,
  VisionServer_VisionServerType_VisionServer_VisionServerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  VisionServer_VisionServerType_VisionServer_VisionServerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool VisionServer_VisionServerType_IsValid(int value);
constexpr VisionServer_VisionServerType VisionServer_VisionServerType_VisionServerType_MIN = VisionServer_VisionServerType_INDYEYE;
constexpr VisionServer_VisionServerType VisionServer_VisionServerType_VisionServerType_MAX = VisionServer_VisionServerType_OMRON;
constexpr int VisionServer_VisionServerType_VisionServerType_ARRAYSIZE = VisionServer_VisionServerType_VisionServerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VisionServer_VisionServerType_descriptor();
template<typename T>
inline const std::string& VisionServer_VisionServerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VisionServer_VisionServerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VisionServer_VisionServerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VisionServer_VisionServerType_descriptor(), enum_t_value);
}
inline bool VisionServer_VisionServerType_Parse(
    const std::string& name, VisionServer_VisionServerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VisionServer_VisionServerType>(
    VisionServer_VisionServerType_descriptor(), name, value);
}
enum MotionState : int {
  IDLING = 0,
  RUNNING = 1,
  PAUSING = 2,
  STOPPING = 3,
  MotionState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MotionState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MotionState_IsValid(int value);
constexpr MotionState MotionState_MIN = IDLING;
constexpr MotionState MotionState_MAX = STOPPING;
constexpr int MotionState_ARRAYSIZE = MotionState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionState_descriptor();
template<typename T>
inline const std::string& MotionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotionState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotionState_descriptor(), enum_t_value);
}
inline bool MotionState_Parse(
    const std::string& name, MotionState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotionState>(
    MotionState_descriptor(), name, value);
}
enum EndToolPortType : int {
  END_TOOL_PORT_TYPE_A = 0,
  END_TOOL_PORT_TYPE_B = 1,
  END_TOOL_PORT_TYPE_AB = 2,
  END_TOOL_PORT_TYPE_REVC = 3,
  EndToolPortType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EndToolPortType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EndToolPortType_IsValid(int value);
constexpr EndToolPortType EndToolPortType_MIN = END_TOOL_PORT_TYPE_A;
constexpr EndToolPortType EndToolPortType_MAX = END_TOOL_PORT_TYPE_REVC;
constexpr int EndToolPortType_ARRAYSIZE = EndToolPortType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EndToolPortType_descriptor();
template<typename T>
inline const std::string& EndToolPortType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EndToolPortType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EndToolPortType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EndToolPortType_descriptor(), enum_t_value);
}
inline bool EndToolPortType_Parse(
    const std::string& name, EndToolPortType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EndToolPortType>(
    EndToolPortType_descriptor(), name, value);
}
enum ControlBoxType : int {
  NORMAL_2 = 0,
  NORMAL_3 = 1,
  KEY_2 = 2,
  KEY_3 = 3,
  ControlBoxType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ControlBoxType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ControlBoxType_IsValid(int value);
constexpr ControlBoxType ControlBoxType_MIN = NORMAL_2;
constexpr ControlBoxType ControlBoxType_MAX = KEY_3;
constexpr int ControlBoxType_ARRAYSIZE = ControlBoxType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControlBoxType_descriptor();
template<typename T>
inline const std::string& ControlBoxType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ControlBoxType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ControlBoxType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ControlBoxType_descriptor(), enum_t_value);
}
inline bool ControlBoxType_Parse(
    const std::string& name, ControlBoxType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ControlBoxType>(
    ControlBoxType_descriptor(), name, value);
}
enum VariableType : int {
  VariableTypeInt = 0,
  VariableTypeFloat = 1,
  VariableTypeBool = 2,
  VariableTypeModbus = 3,
  VariableTypeJPos = 4,
  VariableTypeTPos = 5,
  VariableType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  VariableType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool VariableType_IsValid(int value);
constexpr VariableType VariableType_MIN = VariableTypeInt;
constexpr VariableType VariableType_MAX = VariableTypeTPos;
constexpr int VariableType_ARRAYSIZE = VariableType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VariableType_descriptor();
template<typename T>
inline const std::string& VariableType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VariableType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VariableType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VariableType_descriptor(), enum_t_value);
}
inline bool VariableType_Parse(
    const std::string& name, VariableType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VariableType>(
    VariableType_descriptor(), name, value);
}
enum ProgramState : int {
  PROGRAM_STATE_STOPPED = 0,
  PROGRAM_STATE_RUNNING = 1,
  PROGRAM_STATE_PAUSED = 2,
  PROGRAM_STATE_ERROR = 3,
  PROGRAM_STATE_COLLISION = 4,
  PROGRAM_STATE_START_COLLISION_TUNING = 5,
  PROGRAM_STATE_STOP_COLLISION_TUNING = 6,
  ProgramState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProgramState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProgramState_IsValid(int value);
constexpr ProgramState ProgramState_MIN = PROGRAM_STATE_STOPPED;
constexpr ProgramState ProgramState_MAX = PROGRAM_STATE_STOP_COLLISION_TUNING;
constexpr int ProgramState_ARRAYSIZE = ProgramState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProgramState_descriptor();
template<typename T>
inline const std::string& ProgramState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProgramState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProgramState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProgramState_descriptor(), enum_t_value);
}
inline bool ProgramState_Parse(
    const std::string& name, ProgramState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProgramState>(
    ProgramState_descriptor(), name, value);
}
enum ProgramControl : int {
  PROGRAM_CTRL_NONE = 0,
  PROGRAM_CTRL_RUN = 1,
  PROGRAM_CTRL_PAUSE = 2,
  PROGRAM_CTRL_STOP = 3,
  ProgramControl_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProgramControl_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProgramControl_IsValid(int value);
constexpr ProgramControl ProgramControl_MIN = PROGRAM_CTRL_NONE;
constexpr ProgramControl ProgramControl_MAX = PROGRAM_CTRL_STOP;
constexpr int ProgramControl_ARRAYSIZE = ProgramControl_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProgramControl_descriptor();
template<typename T>
inline const std::string& ProgramControl_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProgramControl>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProgramControl_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProgramControl_descriptor(), enum_t_value);
}
inline bool ProgramControl_Parse(
    const std::string& name, ProgramControl* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProgramControl>(
    ProgramControl_descriptor(), name, value);
}
enum ProgramCategory : int {
  PROGRAM_CAT_NORMAL = 0,
  PROGRAM_CAT_INDEX = 1,
  ProgramCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProgramCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProgramCategory_IsValid(int value);
constexpr ProgramCategory ProgramCategory_MIN = PROGRAM_CAT_NORMAL;
constexpr ProgramCategory ProgramCategory_MAX = PROGRAM_CAT_INDEX;
constexpr int ProgramCategory_ARRAYSIZE = ProgramCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProgramCategory_descriptor();
template<typename T>
inline const std::string& ProgramCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProgramCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProgramCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProgramCategory_descriptor(), enum_t_value);
}
inline bool ProgramCategory_Parse(
    const std::string& name, ProgramCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProgramCategory>(
    ProgramCategory_descriptor(), name, value);
}
enum JointBaseType : int {
  JOINT_BASE_TYPE_ABSOLUTE = 0,
  JOINT_BASE_TYPE_RELATIVE = 1,
  JointBaseType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  JointBaseType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool JointBaseType_IsValid(int value);
constexpr JointBaseType JointBaseType_MIN = JOINT_BASE_TYPE_ABSOLUTE;
constexpr JointBaseType JointBaseType_MAX = JOINT_BASE_TYPE_RELATIVE;
constexpr int JointBaseType_ARRAYSIZE = JointBaseType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JointBaseType_descriptor();
template<typename T>
inline const std::string& JointBaseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JointBaseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JointBaseType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JointBaseType_descriptor(), enum_t_value);
}
inline bool JointBaseType_Parse(
    const std::string& name, JointBaseType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JointBaseType>(
    JointBaseType_descriptor(), name, value);
}
enum TaskBaseType : int {
  TASK_BASE_TYPE_ABSOLUTE = 0,
  TASK_BASE_TYPE_RELATIVE = 1,
  TASK_BASE_TYPE_TCP = 2,
  TaskBaseType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskBaseType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskBaseType_IsValid(int value);
constexpr TaskBaseType TaskBaseType_MIN = TASK_BASE_TYPE_ABSOLUTE;
constexpr TaskBaseType TaskBaseType_MAX = TASK_BASE_TYPE_TCP;
constexpr int TaskBaseType_ARRAYSIZE = TaskBaseType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskBaseType_descriptor();
template<typename T>
inline const std::string& TaskBaseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskBaseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskBaseType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskBaseType_descriptor(), enum_t_value);
}
inline bool TaskBaseType_Parse(
    const std::string& name, TaskBaseType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskBaseType>(
    TaskBaseType_descriptor(), name, value);
}
enum BlendingType : int {
  BLENDING_TYPE_NONE = 0,
  BLENDING_TYPE_OVERRIDE = 1,
  BLENDING_TYPE_DUPLICATE = 2,
  BLENDING_TYPE_INTERRUPT = 3,
  BlendingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BlendingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BlendingType_IsValid(int value);
constexpr BlendingType BlendingType_MIN = BLENDING_TYPE_NONE;
constexpr BlendingType BlendingType_MAX = BLENDING_TYPE_INTERRUPT;
constexpr int BlendingType_ARRAYSIZE = BlendingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BlendingType_descriptor();
template<typename T>
inline const std::string& BlendingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BlendingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BlendingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BlendingType_descriptor(), enum_t_value);
}
inline bool BlendingType_Parse(
    const std::string& name, BlendingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BlendingType>(
    BlendingType_descriptor(), name, value);
}
enum CircularSettingType : int {
  POINT_SET = 0,
  CENTER_AXIS = 1,
  CircularSettingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CircularSettingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CircularSettingType_IsValid(int value);
constexpr CircularSettingType CircularSettingType_MIN = POINT_SET;
constexpr CircularSettingType CircularSettingType_MAX = CENTER_AXIS;
constexpr int CircularSettingType_ARRAYSIZE = CircularSettingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CircularSettingType_descriptor();
template<typename T>
inline const std::string& CircularSettingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CircularSettingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CircularSettingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CircularSettingType_descriptor(), enum_t_value);
}
inline bool CircularSettingType_Parse(
    const std::string& name, CircularSettingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CircularSettingType>(
    CircularSettingType_descriptor(), name, value);
}
enum CircularMovingType : int {
  CONSTANT = 0,
  RADIAL = 1,
  SMOOTH = 2,
  CircularMovingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CircularMovingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CircularMovingType_IsValid(int value);
constexpr CircularMovingType CircularMovingType_MIN = CONSTANT;
constexpr CircularMovingType CircularMovingType_MAX = SMOOTH;
constexpr int CircularMovingType_ARRAYSIZE = CircularMovingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CircularMovingType_descriptor();
template<typename T>
inline const std::string& CircularMovingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CircularMovingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CircularMovingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CircularMovingType_descriptor(), enum_t_value);
}
inline bool CircularMovingType_Parse(
    const std::string& name, CircularMovingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CircularMovingType>(
    CircularMovingType_descriptor(), name, value);
}
enum TrajState : int {
  TRAJSTATE_NONE = 0,
  TRAJSTATE_INIT = 1,
  TRAJSTATE_CALC = 2,
  TRAJSTATE_STBY = 3,
  TRAJSTATE_ACC = 4,
  TRAJSTATE_CRZ = 5,
  TRAJSTATE_DEC = 6,
  TRAJSTATE_CANC = 7,
  TRAJSTATE_FIN = 8,
  TRAJSTATE_ERR = 9,
  TrajState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TrajState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TrajState_IsValid(int value);
constexpr TrajState TrajState_MIN = TRAJSTATE_NONE;
constexpr TrajState TrajState_MAX = TRAJSTATE_ERR;
constexpr int TrajState_ARRAYSIZE = TrajState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrajState_descriptor();
template<typename T>
inline const std::string& TrajState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrajState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrajState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrajState_descriptor(), enum_t_value);
}
inline bool TrajState_Parse(
    const std::string& name, TrajState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrajState>(
    TrajState_descriptor(), name, value);
}
enum TrajCondition : int {
  TRAJ_STARTED = 0,
  TRAJ_ACC_DONE = 1,
  TRAJ_CRZ_DONE = 2,
  TRAJ_DEC_DONE = 3,
  TrajCondition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TrajCondition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TrajCondition_IsValid(int value);
constexpr TrajCondition TrajCondition_MIN = TRAJ_STARTED;
constexpr TrajCondition TrajCondition_MAX = TRAJ_DEC_DONE;
constexpr int TrajCondition_ARRAYSIZE = TrajCondition_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrajCondition_descriptor();
template<typename T>
inline const std::string& TrajCondition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrajCondition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrajCondition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrajCondition_descriptor(), enum_t_value);
}
inline bool TrajCondition_Parse(
    const std::string& name, TrajCondition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrajCondition>(
    TrajCondition_descriptor(), name, value);
}
enum CollisionPolicy : int {
  COLLISION_POLICY_NO_DETECT = 0,
  COLLISION_POLICY_PAUSE = 1,
  COLLISION_POLICY_RESUME_AFTER_SLEEP = 2,
  COLLISION_POLICY_STOP = 3,
  CollisionPolicy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CollisionPolicy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CollisionPolicy_IsValid(int value);
constexpr CollisionPolicy CollisionPolicy_MIN = COLLISION_POLICY_NO_DETECT;
constexpr CollisionPolicy CollisionPolicy_MAX = COLLISION_POLICY_STOP;
constexpr int CollisionPolicy_ARRAYSIZE = CollisionPolicy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CollisionPolicy_descriptor();
template<typename T>
inline const std::string& CollisionPolicy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CollisionPolicy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CollisionPolicy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CollisionPolicy_descriptor(), enum_t_value);
}
inline bool CollisionPolicy_Parse(
    const std::string& name, CollisionPolicy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CollisionPolicy>(
    CollisionPolicy_descriptor(), name, value);
}
enum StopCategory : int {
  STOP_CAT_IMMEDIATE_BRAKE = 0,
  STOP_CAT_REDUCE_SPEED_AND_BRAKE = 1,
  STOP_CAT_REDUCE_SPEED = 2,
  StopCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StopCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StopCategory_IsValid(int value);
constexpr StopCategory StopCategory_MIN = STOP_CAT_IMMEDIATE_BRAKE;
constexpr StopCategory StopCategory_MAX = STOP_CAT_REDUCE_SPEED;
constexpr int StopCategory_ARRAYSIZE = StopCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StopCategory_descriptor();
template<typename T>
inline const std::string& StopCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StopCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StopCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StopCategory_descriptor(), enum_t_value);
}
inline bool StopCategory_Parse(
    const std::string& name, StopCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StopCategory>(
    StopCategory_descriptor(), name, value);
}
enum PauseCategory : int {
  PAUSE_CAT_REDUCE_SPEED = 0,
  PAUSE_CAT_IMMEDIATE = 1,
  PauseCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PauseCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PauseCategory_IsValid(int value);
constexpr PauseCategory PauseCategory_MIN = PAUSE_CAT_REDUCE_SPEED;
constexpr PauseCategory PauseCategory_MAX = PAUSE_CAT_IMMEDIATE;
constexpr int PauseCategory_ARRAYSIZE = PauseCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PauseCategory_descriptor();
template<typename T>
inline const std::string& PauseCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PauseCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PauseCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PauseCategory_descriptor(), enum_t_value);
}
inline bool PauseCategory_Parse(
    const std::string& name, PauseCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PauseCategory>(
    PauseCategory_descriptor(), name, value);
}
enum EyeCommandType : int {
  EYE_COMMAND_TYPE_DETECT = 0,
  EYE_COMMAND_TYPE_EXTRACT = 1,
  EyeCommandType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EyeCommandType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EyeCommandType_IsValid(int value);
constexpr EyeCommandType EyeCommandType_MIN = EYE_COMMAND_TYPE_DETECT;
constexpr EyeCommandType EyeCommandType_MAX = EYE_COMMAND_TYPE_EXTRACT;
constexpr int EyeCommandType_ARRAYSIZE = EyeCommandType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EyeCommandType_descriptor();
template<typename T>
inline const std::string& EyeCommandType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EyeCommandType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EyeCommandType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EyeCommandType_descriptor(), enum_t_value);
}
inline bool EyeCommandType_Parse(
    const std::string& name, EyeCommandType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EyeCommandType>(
    EyeCommandType_descriptor(), name, value);
}
enum DIConfigFunc : int {
  DI_RUN_INDEX_PROGRAM = 0,
  DI_STOP_PROGRAM = 1,
  DI_PAUSE_PROGRAM = 2,
  DI_RESUME_PROGRAM = 3,
  DI_RECOVER = 4,
  DI_STOP_SLOW = 5,
  DI_STOP_IMMADIATE = 6,
  DI_MOVE_TO_HOME = 7,
  DI_MOVE_TO_ZERO = 8,
  DI_DIRECT_TEACHING_MODE_ON = 9,
  DI_DIRECT_TEACHING_MODE_OFF = 10,
  DI_REDUCED_SPEED_MODE_ON = 11,
  DI_REDUCED_SPEED_MODE_OFF = 12,
  DIConfigFunc_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DIConfigFunc_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DIConfigFunc_IsValid(int value);
constexpr DIConfigFunc DIConfigFunc_MIN = DI_RUN_INDEX_PROGRAM;
constexpr DIConfigFunc DIConfigFunc_MAX = DI_REDUCED_SPEED_MODE_OFF;
constexpr int DIConfigFunc_ARRAYSIZE = DIConfigFunc_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DIConfigFunc_descriptor();
template<typename T>
inline const std::string& DIConfigFunc_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DIConfigFunc>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DIConfigFunc_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DIConfigFunc_descriptor(), enum_t_value);
}
inline bool DIConfigFunc_Parse(
    const std::string& name, DIConfigFunc* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DIConfigFunc>(
    DIConfigFunc_descriptor(), name, value);
}
enum DOConfigState : int {
  DO_IS_IDLE = 0,
  DO_IS_MOVING = 1,
  DO_IS_VIOLATE = 2,
  DO_IS_RECOVER = 3,
  DO_IS_TEACHING = 4,
  DO_IS_COLLISION = 5,
  DO_IS_PROGRAM_RUNNING = 6,
  DO_IS_PROGRAM_PAUSED = 7,
  DOConfigState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DOConfigState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DOConfigState_IsValid(int value);
constexpr DOConfigState DOConfigState_MIN = DO_IS_IDLE;
constexpr DOConfigState DOConfigState_MAX = DO_IS_PROGRAM_PAUSED;
constexpr int DOConfigState_ARRAYSIZE = DOConfigState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOConfigState_descriptor();
template<typename T>
inline const std::string& DOConfigState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOConfigState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOConfigState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOConfigState_descriptor(), enum_t_value);
}
inline bool DOConfigState_Parse(
    const std::string& name, DOConfigState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOConfigState>(
    DOConfigState_descriptor(), name, value);
}
enum OpState : int {
  OP_SYSTEM_OFF = 0,
  OP_SYSTEM_ON = 1,
  OP_VIOLATE = 2,
  OP_RECOVER_HARD = 3,
  OP_RECOVER_SOFT = 4,
  OP_IDLE = 5,
  OP_MOVING = 6,
  OP_TEACHING = 7,
  OP_COLLISION = 8,
  OP_STOP_AND_OFF = 9,
  COMPLIANCE = 10,
  BRAKE_CONTROL = 11,
  SYSTEM_RESET = 12,
  SYSTEM_SWITCH = 13,
  OpState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OpState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OpState_IsValid(int value);
constexpr OpState OpState_MIN = OP_SYSTEM_OFF;
constexpr OpState OpState_MAX = SYSTEM_SWITCH;
constexpr int OpState_ARRAYSIZE = OpState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OpState_descriptor();
template<typename T>
inline const std::string& OpState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OpState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OpState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OpState_descriptor(), enum_t_value);
}
inline bool OpState_Parse(
    const std::string& name, OpState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OpState>(
    OpState_descriptor(), name, value);
}
enum LogLevel : int {
  LOG_LEVEL_INFO = 0,
  LOG_LEVEL_ERROR = 1,
  LogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LogLevel_IsValid(int value);
constexpr LogLevel LogLevel_MIN = LOG_LEVEL_INFO;
constexpr LogLevel LogLevel_MAX = LOG_LEVEL_ERROR;
constexpr int LogLevel_ARRAYSIZE = LogLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogLevel_descriptor();
template<typename T>
inline const std::string& LogLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogLevel_descriptor(), enum_t_value);
}
inline bool LogLevel_Parse(
    const std::string& name, LogLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogLevel>(
    LogLevel_descriptor(), name, value);
}
enum JogFrameType : int {
  JOG_FRAME_TYPE_REF = 0,
  JOG_FRAME_TYPE_TOOL = 1,
  JogFrameType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  JogFrameType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool JogFrameType_IsValid(int value);
constexpr JogFrameType JogFrameType_MIN = JOG_FRAME_TYPE_REF;
constexpr JogFrameType JogFrameType_MAX = JOG_FRAME_TYPE_TOOL;
constexpr int JogFrameType_ARRAYSIZE = JogFrameType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JogFrameType_descriptor();
template<typename T>
inline const std::string& JogFrameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JogFrameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JogFrameType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JogFrameType_descriptor(), enum_t_value);
}
inline bool JogFrameType_Parse(
    const std::string& name, JogFrameType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JogFrameType>(
    JogFrameType_descriptor(), name, value);
}
enum Axis : int {
  AXIS_X = 0,
  AXIS_Y = 1,
  AXIS_Z = 2,
  AXIS_U = 3,
  AXIS_V = 4,
  AXIS_W = 5,
  Axis_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Axis_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Axis_IsValid(int value);
constexpr Axis Axis_MIN = AXIS_X;
constexpr Axis Axis_MAX = AXIS_W;
constexpr int Axis_ARRAYSIZE = Axis_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Axis_descriptor();
template<typename T>
inline const std::string& Axis_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Axis>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Axis_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Axis_descriptor(), enum_t_value);
}
inline bool Axis_Parse(
    const std::string& name, Axis* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Axis>(
    Axis_descriptor(), name, value);
}
enum VisionFrameType : int {
  OBJECT = 0,
  END_EFFECTOR = 1,
  VisionFrameType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  VisionFrameType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool VisionFrameType_IsValid(int value);
constexpr VisionFrameType VisionFrameType_MIN = OBJECT;
constexpr VisionFrameType VisionFrameType_MAX = END_EFFECTOR;
constexpr int VisionFrameType_ARRAYSIZE = VisionFrameType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VisionFrameType_descriptor();
template<typename T>
inline const std::string& VisionFrameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VisionFrameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VisionFrameType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VisionFrameType_descriptor(), enum_t_value);
}
inline bool VisionFrameType_Parse(
    const std::string& name, VisionFrameType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VisionFrameType>(
    VisionFrameType_descriptor(), name, value);
}
enum WeavingBase : int {
  WEAVE_FRAME_TYPE_TOOL = 0,
  WEAVE_FRAME_TYPE_REF = 1,
  WeavingBase_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WeavingBase_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WeavingBase_IsValid(int value);
constexpr WeavingBase WeavingBase_MIN = WEAVE_FRAME_TYPE_TOOL;
constexpr WeavingBase WeavingBase_MAX = WEAVE_FRAME_TYPE_REF;
constexpr int WeavingBase_ARRAYSIZE = WeavingBase_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WeavingBase_descriptor();
template<typename T>
inline const std::string& WeavingBase_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeavingBase>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeavingBase_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WeavingBase_descriptor(), enum_t_value);
}
inline bool WeavingBase_Parse(
    const std::string& name, WeavingBase* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WeavingBase>(
    WeavingBase_descriptor(), name, value);
}
// ===================================================================

class MoveSJPoint :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.MoveSJPoint) */ {
 public:
  MoveSJPoint();
  virtual ~MoveSJPoint();

  MoveSJPoint(const MoveSJPoint& from);
  MoveSJPoint(MoveSJPoint&& from) noexcept
    : MoveSJPoint() {
    *this = ::std::move(from);
  }

  inline MoveSJPoint& operator=(const MoveSJPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveSJPoint& operator=(MoveSJPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MoveSJPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoveSJPoint* internal_default_instance() {
    return reinterpret_cast<const MoveSJPoint*>(
               &_MoveSJPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MoveSJPoint* other);
  friend void swap(MoveSJPoint& a, MoveSJPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoveSJPoint* New() const final {
    return CreateMaybeMessage<MoveSJPoint>(nullptr);
  }

  MoveSJPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveSJPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MoveSJPoint& from);
  void MergeFrom(const MoveSJPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveSJPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.MoveSJPoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float jpos = 1;
  int jpos_size() const;
  void clear_jpos();
  static const int kJposFieldNumber = 1;
  float jpos(int index) const;
  void set_jpos(int index, float value);
  void add_jpos(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      jpos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_jpos();

  // float blending_radius = 2;
  void clear_blending_radius();
  static const int kBlendingRadiusFieldNumber = 2;
  float blending_radius() const;
  void set_blending_radius(float value);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.MoveSJPoint)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > jpos_;
  mutable std::atomic<int> _jpos_cached_byte_size_;
  float blending_radius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class MoveSJTPoint :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.MoveSJTPoint) */ {
 public:
  MoveSJTPoint();
  virtual ~MoveSJTPoint();

  MoveSJTPoint(const MoveSJTPoint& from);
  MoveSJTPoint(MoveSJTPoint&& from) noexcept
    : MoveSJTPoint() {
    *this = ::std::move(from);
  }

  inline MoveSJTPoint& operator=(const MoveSJTPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveSJTPoint& operator=(MoveSJTPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MoveSJTPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoveSJTPoint* internal_default_instance() {
    return reinterpret_cast<const MoveSJTPoint*>(
               &_MoveSJTPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MoveSJTPoint* other);
  friend void swap(MoveSJTPoint& a, MoveSJTPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoveSJTPoint* New() const final {
    return CreateMaybeMessage<MoveSJTPoint>(nullptr);
  }

  MoveSJTPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveSJTPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MoveSJTPoint& from);
  void MergeFrom(const MoveSJTPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveSJTPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.MoveSJTPoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float jpos = 1;
  int jpos_size() const;
  void clear_jpos();
  static const int kJposFieldNumber = 1;
  float jpos(int index) const;
  void set_jpos(int index, float value);
  void add_jpos(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      jpos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_jpos();

  // float blending_radius = 2;
  void clear_blending_radius();
  static const int kBlendingRadiusFieldNumber = 2;
  float blending_radius() const;
  void set_blending_radius(float value);

  // float time = 3;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  float time() const;
  void set_time(float value);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.MoveSJTPoint)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > jpos_;
  mutable std::atomic<int> _jpos_cached_byte_size_;
  float blending_radius_;
  float time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class MoveSLPoint :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.MoveSLPoint) */ {
 public:
  MoveSLPoint();
  virtual ~MoveSLPoint();

  MoveSLPoint(const MoveSLPoint& from);
  MoveSLPoint(MoveSLPoint&& from) noexcept
    : MoveSLPoint() {
    *this = ::std::move(from);
  }

  inline MoveSLPoint& operator=(const MoveSLPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveSLPoint& operator=(MoveSLPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MoveSLPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoveSLPoint* internal_default_instance() {
    return reinterpret_cast<const MoveSLPoint*>(
               &_MoveSLPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(MoveSLPoint* other);
  friend void swap(MoveSLPoint& a, MoveSLPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoveSLPoint* New() const final {
    return CreateMaybeMessage<MoveSLPoint>(nullptr);
  }

  MoveSLPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveSLPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MoveSLPoint& from);
  void MergeFrom(const MoveSLPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveSLPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.MoveSLPoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float tpos = 1;
  int tpos_size() const;
  void clear_tpos();
  static const int kTposFieldNumber = 1;
  float tpos(int index) const;
  void set_tpos(int index, float value);
  void add_tpos(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      tpos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_tpos();

  // float blending_radius = 2;
  void clear_blending_radius();
  static const int kBlendingRadiusFieldNumber = 2;
  float blending_radius() const;
  void set_blending_radius(float value);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.MoveSLPoint)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > tpos_;
  mutable std::atomic<int> _tpos_cached_byte_size_;
  float blending_radius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class MoveSLTPoint :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.MoveSLTPoint) */ {
 public:
  MoveSLTPoint();
  virtual ~MoveSLTPoint();

  MoveSLTPoint(const MoveSLTPoint& from);
  MoveSLTPoint(MoveSLTPoint&& from) noexcept
    : MoveSLTPoint() {
    *this = ::std::move(from);
  }

  inline MoveSLTPoint& operator=(const MoveSLTPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveSLTPoint& operator=(MoveSLTPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MoveSLTPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoveSLTPoint* internal_default_instance() {
    return reinterpret_cast<const MoveSLTPoint*>(
               &_MoveSLTPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MoveSLTPoint* other);
  friend void swap(MoveSLTPoint& a, MoveSLTPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoveSLTPoint* New() const final {
    return CreateMaybeMessage<MoveSLTPoint>(nullptr);
  }

  MoveSLTPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveSLTPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MoveSLTPoint& from);
  void MergeFrom(const MoveSLTPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveSLTPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.MoveSLTPoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float tpos = 1;
  int tpos_size() const;
  void clear_tpos();
  static const int kTposFieldNumber = 1;
  float tpos(int index) const;
  void set_tpos(int index, float value);
  void add_tpos(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      tpos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_tpos();

  // float blending_radius = 2;
  void clear_blending_radius();
  static const int kBlendingRadiusFieldNumber = 2;
  float blending_radius() const;
  void set_blending_radius(float value);

  // float time = 3;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  float time() const;
  void set_time(float value);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.MoveSLTPoint)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > tpos_;
  mutable std::atomic<int> _tpos_cached_byte_size_;
  float blending_radius_;
  float time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class DigitalSignal :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.DigitalSignal) */ {
 public:
  DigitalSignal();
  virtual ~DigitalSignal();

  DigitalSignal(const DigitalSignal& from);
  DigitalSignal(DigitalSignal&& from) noexcept
    : DigitalSignal() {
    *this = ::std::move(from);
  }

  inline DigitalSignal& operator=(const DigitalSignal& from) {
    CopyFrom(from);
    return *this;
  }
  inline DigitalSignal& operator=(DigitalSignal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DigitalSignal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DigitalSignal* internal_default_instance() {
    return reinterpret_cast<const DigitalSignal*>(
               &_DigitalSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(DigitalSignal* other);
  friend void swap(DigitalSignal& a, DigitalSignal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DigitalSignal* New() const final {
    return CreateMaybeMessage<DigitalSignal>(nullptr);
  }

  DigitalSignal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DigitalSignal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DigitalSignal& from);
  void MergeFrom(const DigitalSignal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DigitalSignal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.DigitalSignal";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 addr = 1;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 addr() const;
  void set_addr(::PROTOBUF_NAMESPACE_ID::int32 value);

  // bool on = 2;
  void clear_on();
  static const int kOnFieldNumber = 2;
  bool on() const;
  void set_on(bool value);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.DigitalSignal)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 addr_;
  bool on_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class AnalogSignal :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.AnalogSignal) */ {
 public:
  AnalogSignal();
  virtual ~AnalogSignal();

  AnalogSignal(const AnalogSignal& from);
  AnalogSignal(AnalogSignal&& from) noexcept
    : AnalogSignal() {
    *this = ::std::move(from);
  }

  inline AnalogSignal& operator=(const AnalogSignal& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalogSignal& operator=(AnalogSignal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnalogSignal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalogSignal* internal_default_instance() {
    return reinterpret_cast<const AnalogSignal*>(
               &_AnalogSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AnalogSignal* other);
  friend void swap(AnalogSignal& a, AnalogSignal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalogSignal* New() const final {
    return CreateMaybeMessage<AnalogSignal>(nullptr);
  }

  AnalogSignal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnalogSignal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnalogSignal& from);
  void MergeFrom(const AnalogSignal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalogSignal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.AnalogSignal";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 addr = 1;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 addr() const;
  void set_addr(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 voltage = 2;
  void clear_voltage();
  static const int kVoltageFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 voltage() const;
  void set_voltage(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.AnalogSignal)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 addr_;
  ::PROTOBUF_NAMESPACE_ID::int32 voltage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class NamedTaskPosition :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.NamedTaskPosition) */ {
 public:
  NamedTaskPosition();
  virtual ~NamedTaskPosition();

  NamedTaskPosition(const NamedTaskPosition& from);
  NamedTaskPosition(NamedTaskPosition&& from) noexcept
    : NamedTaskPosition() {
    *this = ::std::move(from);
  }

  inline NamedTaskPosition& operator=(const NamedTaskPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedTaskPosition& operator=(NamedTaskPosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NamedTaskPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NamedTaskPosition* internal_default_instance() {
    return reinterpret_cast<const NamedTaskPosition*>(
               &_NamedTaskPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(NamedTaskPosition* other);
  friend void swap(NamedTaskPosition& a, NamedTaskPosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NamedTaskPosition* New() const final {
    return CreateMaybeMessage<NamedTaskPosition>(nullptr);
  }

  NamedTaskPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NamedTaskPosition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NamedTaskPosition& from);
  void MergeFrom(const NamedTaskPosition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedTaskPosition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.NamedTaskPosition";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float tpos = 2;
  int tpos_size() const;
  void clear_tpos();
  static const int kTposFieldNumber = 2;
  float tpos(int index) const;
  void set_tpos(int index, float value);
  void add_tpos(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      tpos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_tpos();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.NamedTaskPosition)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > tpos_;
  mutable std::atomic<int> _tpos_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class NamedJointPosition :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.NamedJointPosition) */ {
 public:
  NamedJointPosition();
  virtual ~NamedJointPosition();

  NamedJointPosition(const NamedJointPosition& from);
  NamedJointPosition(NamedJointPosition&& from) noexcept
    : NamedJointPosition() {
    *this = ::std::move(from);
  }

  inline NamedJointPosition& operator=(const NamedJointPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedJointPosition& operator=(NamedJointPosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NamedJointPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NamedJointPosition* internal_default_instance() {
    return reinterpret_cast<const NamedJointPosition*>(
               &_NamedJointPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(NamedJointPosition* other);
  friend void swap(NamedJointPosition& a, NamedJointPosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NamedJointPosition* New() const final {
    return CreateMaybeMessage<NamedJointPosition>(nullptr);
  }

  NamedJointPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NamedJointPosition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NamedJointPosition& from);
  void MergeFrom(const NamedJointPosition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedJointPosition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.NamedJointPosition";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float jpos = 2;
  int jpos_size() const;
  void clear_jpos();
  static const int kJposFieldNumber = 2;
  float jpos(int index) const;
  void set_jpos(int index, float value);
  void add_jpos(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      jpos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_jpos();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.NamedJointPosition)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > jpos_;
  mutable std::atomic<int> _jpos_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class NamedReferencePosition :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.NamedReferencePosition) */ {
 public:
  NamedReferencePosition();
  virtual ~NamedReferencePosition();

  NamedReferencePosition(const NamedReferencePosition& from);
  NamedReferencePosition(NamedReferencePosition&& from) noexcept
    : NamedReferencePosition() {
    *this = ::std::move(from);
  }

  inline NamedReferencePosition& operator=(const NamedReferencePosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedReferencePosition& operator=(NamedReferencePosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NamedReferencePosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NamedReferencePosition* internal_default_instance() {
    return reinterpret_cast<const NamedReferencePosition*>(
               &_NamedReferencePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(NamedReferencePosition* other);
  friend void swap(NamedReferencePosition& a, NamedReferencePosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NamedReferencePosition* New() const final {
    return CreateMaybeMessage<NamedReferencePosition>(nullptr);
  }

  NamedReferencePosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NamedReferencePosition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NamedReferencePosition& from);
  void MergeFrom(const NamedReferencePosition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedReferencePosition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.NamedReferencePosition";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float tpos = 2;
  int tpos_size() const;
  void clear_tpos();
  static const int kTposFieldNumber = 2;
  float tpos(int index) const;
  void set_tpos(int index, float value);
  void add_tpos(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      tpos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_tpos();

  // repeated float tpos0 = 3;
  int tpos0_size() const;
  void clear_tpos0();
  static const int kTpos0FieldNumber = 3;
  float tpos0(int index) const;
  void set_tpos0(int index, float value);
  void add_tpos0(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      tpos0() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_tpos0();

  // repeated float tpos1 = 4;
  int tpos1_size() const;
  void clear_tpos1();
  static const int kTpos1FieldNumber = 4;
  float tpos1(int index) const;
  void set_tpos1(int index, float value);
  void add_tpos1(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      tpos1() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_tpos1();

  // repeated float tpos2 = 5;
  int tpos2_size() const;
  void clear_tpos2();
  static const int kTpos2FieldNumber = 5;
  float tpos2(int index) const;
  void set_tpos2(int index, float value);
  void add_tpos2(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      tpos2() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_tpos2();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.NamedReferencePosition)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > tpos_;
  mutable std::atomic<int> _tpos_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > tpos0_;
  mutable std::atomic<int> _tpos0_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > tpos1_;
  mutable std::atomic<int> _tpos1_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > tpos2_;
  mutable std::atomic<int> _tpos2_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class IntVariable :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.IntVariable) */ {
 public:
  IntVariable();
  virtual ~IntVariable();

  IntVariable(const IntVariable& from);
  IntVariable(IntVariable&& from) noexcept
    : IntVariable() {
    *this = ::std::move(from);
  }

  inline IntVariable& operator=(const IntVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntVariable& operator=(IntVariable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IntVariable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntVariable* internal_default_instance() {
    return reinterpret_cast<const IntVariable*>(
               &_IntVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(IntVariable* other);
  friend void swap(IntVariable& a, IntVariable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IntVariable* New() const final {
    return CreateMaybeMessage<IntVariable>(nullptr);
  }

  IntVariable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IntVariable>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IntVariable& from);
  void MergeFrom(const IntVariable& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntVariable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.IntVariable";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 addr = 1;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 addr() const;
  void set_addr(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.IntVariable)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 addr_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class ModbusVariable :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.ModbusVariable) */ {
 public:
  ModbusVariable();
  virtual ~ModbusVariable();

  ModbusVariable(const ModbusVariable& from);
  ModbusVariable(ModbusVariable&& from) noexcept
    : ModbusVariable() {
    *this = ::std::move(from);
  }

  inline ModbusVariable& operator=(const ModbusVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusVariable& operator=(ModbusVariable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModbusVariable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModbusVariable* internal_default_instance() {
    return reinterpret_cast<const ModbusVariable*>(
               &_ModbusVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ModbusVariable* other);
  friend void swap(ModbusVariable& a, ModbusVariable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModbusVariable* New() const final {
    return CreateMaybeMessage<ModbusVariable>(nullptr);
  }

  ModbusVariable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModbusVariable>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModbusVariable& from);
  void MergeFrom(const ModbusVariable& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusVariable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.ModbusVariable";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 addr = 1;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 addr() const;
  void set_addr(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.ModbusVariable)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 addr_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class BoolVariable :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.BoolVariable) */ {
 public:
  BoolVariable();
  virtual ~BoolVariable();

  BoolVariable(const BoolVariable& from);
  BoolVariable(BoolVariable&& from) noexcept
    : BoolVariable() {
    *this = ::std::move(from);
  }

  inline BoolVariable& operator=(const BoolVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolVariable& operator=(BoolVariable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BoolVariable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoolVariable* internal_default_instance() {
    return reinterpret_cast<const BoolVariable*>(
               &_BoolVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(BoolVariable* other);
  friend void swap(BoolVariable& a, BoolVariable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoolVariable* New() const final {
    return CreateMaybeMessage<BoolVariable>(nullptr);
  }

  BoolVariable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BoolVariable>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BoolVariable& from);
  void MergeFrom(const BoolVariable& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolVariable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.BoolVariable";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 addr = 1;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 addr() const;
  void set_addr(::PROTOBUF_NAMESPACE_ID::int32 value);

  // bool value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  bool value() const;
  void set_value(bool value);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.BoolVariable)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 addr_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class FloatVariable :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.FloatVariable) */ {
 public:
  FloatVariable();
  virtual ~FloatVariable();

  FloatVariable(const FloatVariable& from);
  FloatVariable(FloatVariable&& from) noexcept
    : FloatVariable() {
    *this = ::std::move(from);
  }

  inline FloatVariable& operator=(const FloatVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatVariable& operator=(FloatVariable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FloatVariable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FloatVariable* internal_default_instance() {
    return reinterpret_cast<const FloatVariable*>(
               &_FloatVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(FloatVariable* other);
  friend void swap(FloatVariable& a, FloatVariable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FloatVariable* New() const final {
    return CreateMaybeMessage<FloatVariable>(nullptr);
  }

  FloatVariable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FloatVariable>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FloatVariable& from);
  void MergeFrom(const FloatVariable& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatVariable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.FloatVariable";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 addr = 1;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 addr() const;
  void set_addr(::PROTOBUF_NAMESPACE_ID::int32 value);

  // float value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.FloatVariable)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 addr_;
  float value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class JPosVariable :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.JPosVariable) */ {
 public:
  JPosVariable();
  virtual ~JPosVariable();

  JPosVariable(const JPosVariable& from);
  JPosVariable(JPosVariable&& from) noexcept
    : JPosVariable() {
    *this = ::std::move(from);
  }

  inline JPosVariable& operator=(const JPosVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline JPosVariable& operator=(JPosVariable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const JPosVariable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JPosVariable* internal_default_instance() {
    return reinterpret_cast<const JPosVariable*>(
               &_JPosVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(JPosVariable* other);
  friend void swap(JPosVariable& a, JPosVariable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JPosVariable* New() const final {
    return CreateMaybeMessage<JPosVariable>(nullptr);
  }

  JPosVariable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JPosVariable>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const JPosVariable& from);
  void MergeFrom(const JPosVariable& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JPosVariable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.JPosVariable";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float jpos = 2;
  int jpos_size() const;
  void clear_jpos();
  static const int kJposFieldNumber = 2;
  float jpos(int index) const;
  void set_jpos(int index, float value);
  void add_jpos(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      jpos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_jpos();

  // int32 addr = 1;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 addr() const;
  void set_addr(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.JPosVariable)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > jpos_;
  mutable std::atomic<int> _jpos_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 addr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class TPosVariable :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.TPosVariable) */ {
 public:
  TPosVariable();
  virtual ~TPosVariable();

  TPosVariable(const TPosVariable& from);
  TPosVariable(TPosVariable&& from) noexcept
    : TPosVariable() {
    *this = ::std::move(from);
  }

  inline TPosVariable& operator=(const TPosVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline TPosVariable& operator=(TPosVariable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TPosVariable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TPosVariable* internal_default_instance() {
    return reinterpret_cast<const TPosVariable*>(
               &_TPosVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(TPosVariable* other);
  friend void swap(TPosVariable& a, TPosVariable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TPosVariable* New() const final {
    return CreateMaybeMessage<TPosVariable>(nullptr);
  }

  TPosVariable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TPosVariable>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TPosVariable& from);
  void MergeFrom(const TPosVariable& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TPosVariable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.TPosVariable";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float tpos = 2;
  int tpos_size() const;
  void clear_tpos();
  static const int kTposFieldNumber = 2;
  float tpos(int index) const;
  void set_tpos(int index, float value);
  void add_tpos(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      tpos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_tpos();

  // int32 addr = 1;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 addr() const;
  void set_addr(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.TPosVariable)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > tpos_;
  mutable std::atomic<int> _tpos_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 addr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class Tool :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.Tool) */ {
 public:
  Tool();
  virtual ~Tool();

  Tool(const Tool& from);
  Tool(Tool&& from) noexcept
    : Tool() {
    *this = ::std::move(from);
  }

  inline Tool& operator=(const Tool& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tool& operator=(Tool&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Tool& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tool* internal_default_instance() {
    return reinterpret_cast<const Tool*>(
               &_Tool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Tool* other);
  friend void swap(Tool& a, Tool& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tool* New() const final {
    return CreateMaybeMessage<Tool>(nullptr);
  }

  Tool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tool>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Tool& from);
  void MergeFrom(const Tool& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tool* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.Tool";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Tool_ToolType ToolType;
  static constexpr ToolType DIGITAL_OUTPUT =
    Tool_ToolType_DIGITAL_OUTPUT;
  static constexpr ToolType MODBUS =
    Tool_ToolType_MODBUS;
  static inline bool ToolType_IsValid(int value) {
    return Tool_ToolType_IsValid(value);
  }
  static constexpr ToolType ToolType_MIN =
    Tool_ToolType_ToolType_MIN;
  static constexpr ToolType ToolType_MAX =
    Tool_ToolType_ToolType_MAX;
  static constexpr int ToolType_ARRAYSIZE =
    Tool_ToolType_ToolType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ToolType_descriptor() {
    return Tool_ToolType_descriptor();
  }
  template<typename T>
  static inline const std::string& ToolType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ToolType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ToolType_Name.");
    return Tool_ToolType_Name(enum_t_value);
  }
  static inline bool ToolType_Parse(const std::string& name,
      ToolType* value) {
    return Tool_ToolType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .IndyFramework.Protobuf.Shared.DigitalSignal do_list = 5;
  int do_list_size() const;
  void clear_do_list();
  static const int kDoListFieldNumber = 5;
  ::IndyFramework::Protobuf::Shared::DigitalSignal* mutable_do_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::DigitalSignal >*
      mutable_do_list();
  const ::IndyFramework::Protobuf::Shared::DigitalSignal& do_list(int index) const;
  ::IndyFramework::Protobuf::Shared::DigitalSignal* add_do_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::DigitalSignal >&
      do_list() const;

  // repeated .IndyFramework.Protobuf.Shared.ModbusVariable m_vars = 6;
  int m_vars_size() const;
  void clear_m_vars();
  static const int kMVarsFieldNumber = 6;
  ::IndyFramework::Protobuf::Shared::ModbusVariable* mutable_m_vars(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::ModbusVariable >*
      mutable_m_vars();
  const ::IndyFramework::Protobuf::Shared::ModbusVariable& m_vars(int index) const;
  ::IndyFramework::Protobuf::Shared::ModbusVariable* add_m_vars();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::ModbusVariable >&
      m_vars() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // .IndyFramework.Protobuf.Shared.Tool.ToolType tool_type = 2;
  void clear_tool_type();
  static const int kToolTypeFieldNumber = 2;
  ::IndyFramework::Protobuf::Shared::Tool_ToolType tool_type() const;
  void set_tool_type(::IndyFramework::Protobuf::Shared::Tool_ToolType value);

  // float sleep_time = 10;
  void clear_sleep_time();
  static const int kSleepTimeFieldNumber = 10;
  float sleep_time() const;
  void set_sleep_time(float value);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.Tool)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::DigitalSignal > do_list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::ModbusVariable > m_vars_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int tool_type_;
  float sleep_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class PalletPoint :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.PalletPoint) */ {
 public:
  PalletPoint();
  virtual ~PalletPoint();

  PalletPoint(const PalletPoint& from);
  PalletPoint(PalletPoint&& from) noexcept
    : PalletPoint() {
    *this = ::std::move(from);
  }

  inline PalletPoint& operator=(const PalletPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline PalletPoint& operator=(PalletPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PalletPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PalletPoint* internal_default_instance() {
    return reinterpret_cast<const PalletPoint*>(
               &_PalletPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(PalletPoint* other);
  friend void swap(PalletPoint& a, PalletPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PalletPoint* New() const final {
    return CreateMaybeMessage<PalletPoint>(nullptr);
  }

  PalletPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PalletPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PalletPoint& from);
  void MergeFrom(const PalletPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PalletPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.PalletPoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float tar_pos = 1;
  int tar_pos_size() const;
  void clear_tar_pos();
  static const int kTarPosFieldNumber = 1;
  float tar_pos(int index) const;
  void set_tar_pos(int index, float value);
  void add_tar_pos(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      tar_pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_tar_pos();

  // repeated float approach_pos = 2;
  int approach_pos_size() const;
  void clear_approach_pos();
  static const int kApproachPosFieldNumber = 2;
  float approach_pos(int index) const;
  void set_approach_pos(int index, float value);
  void add_approach_pos(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      approach_pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_approach_pos();

  // repeated float retract_pos = 3;
  int retract_pos_size() const;
  void clear_retract_pos();
  static const int kRetractPosFieldNumber = 3;
  float retract_pos(int index) const;
  void set_retract_pos(int index, float value);
  void add_retract_pos(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      retract_pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_retract_pos();

  // repeated float tar_jpos = 4;
  int tar_jpos_size() const;
  void clear_tar_jpos();
  static const int kTarJposFieldNumber = 4;
  float tar_jpos(int index) const;
  void set_tar_jpos(int index, float value);
  void add_tar_jpos(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      tar_jpos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_tar_jpos();

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.PalletPoint)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > tar_pos_;
  mutable std::atomic<int> _tar_pos_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > approach_pos_;
  mutable std::atomic<int> _approach_pos_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > retract_pos_;
  mutable std::atomic<int> _retract_pos_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > tar_jpos_;
  mutable std::atomic<int> _tar_jpos_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class VisionServer :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.VisionServer) */ {
 public:
  VisionServer();
  virtual ~VisionServer();

  VisionServer(const VisionServer& from);
  VisionServer(VisionServer&& from) noexcept
    : VisionServer() {
    *this = ::std::move(from);
  }

  inline VisionServer& operator=(const VisionServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionServer& operator=(VisionServer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VisionServer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VisionServer* internal_default_instance() {
    return reinterpret_cast<const VisionServer*>(
               &_VisionServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(VisionServer* other);
  friend void swap(VisionServer& a, VisionServer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VisionServer* New() const final {
    return CreateMaybeMessage<VisionServer>(nullptr);
  }

  VisionServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VisionServer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VisionServer& from);
  void MergeFrom(const VisionServer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisionServer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndyFramework.Protobuf.Shared.VisionServer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_shared_5fmsgs_2eproto);
    return ::descriptor_table_shared_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef VisionServer_VisionServerType VisionServerType;
  static constexpr VisionServerType INDYEYE =
    VisionServer_VisionServerType_INDYEYE;
  static constexpr VisionServerType PICKIT =
    VisionServer_VisionServerType_PICKIT;
  static constexpr VisionServerType OMRON =
    VisionServer_VisionServerType_OMRON;
  static inline bool VisionServerType_IsValid(int value) {
    return VisionServer_VisionServerType_IsValid(value);
  }
  static constexpr VisionServerType VisionServerType_MIN =
    VisionServer_VisionServerType_VisionServerType_MIN;
  static constexpr VisionServerType VisionServerType_MAX =
    VisionServer_VisionServerType_VisionServerType_MAX;
  static constexpr int VisionServerType_ARRAYSIZE =
    VisionServer_VisionServerType_VisionServerType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VisionServerType_descriptor() {
    return VisionServer_VisionServerType_descriptor();
  }
  template<typename T>
  static inline const std::string& VisionServerType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VisionServerType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VisionServerType_Name.");
    return VisionServer_VisionServerType_Name(enum_t_value);
  }
  static inline bool VisionServerType_Parse(const std::string& name,
      VisionServerType* value) {
    return VisionServer_VisionServerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string ip = 3;
  void clear_ip();
  static const int kIpFieldNumber = 3;
  const std::string& ip() const;
  void set_ip(const std::string& value);
  void set_ip(std::string&& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  std::string* mutable_ip();
  std::string* release_ip();
  void set_allocated_ip(std::string* ip);

  // string port = 4;
  void clear_port();
  static const int kPortFieldNumber = 4;
  const std::string& port() const;
  void set_port(const std::string& value);
  void set_port(std::string&& value);
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  std::string* mutable_port();
  std::string* release_port();
  void set_allocated_port(std::string* port);

  // .IndyFramework.Protobuf.Shared.VisionServer.VisionServerType vision_server_type = 2;
  void clear_vision_server_type();
  static const int kVisionServerTypeFieldNumber = 2;
  ::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType vision_server_type() const;
  void set_vision_server_type(::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType value);

  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.VisionServer)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
  int vision_server_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MoveSJPoint

// repeated float jpos = 1;
inline int MoveSJPoint::jpos_size() const {
  return jpos_.size();
}
inline void MoveSJPoint::clear_jpos() {
  jpos_.Clear();
}
inline float MoveSJPoint::jpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSJPoint.jpos)
  return jpos_.Get(index);
}
inline void MoveSJPoint::set_jpos(int index, float value) {
  jpos_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSJPoint.jpos)
}
inline void MoveSJPoint::add_jpos(float value) {
  jpos_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.MoveSJPoint.jpos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
MoveSJPoint::jpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.MoveSJPoint.jpos)
  return jpos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
MoveSJPoint::mutable_jpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.MoveSJPoint.jpos)
  return &jpos_;
}

// float blending_radius = 2;
inline void MoveSJPoint::clear_blending_radius() {
  blending_radius_ = 0;
}
inline float MoveSJPoint::blending_radius() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSJPoint.blending_radius)
  return blending_radius_;
}
inline void MoveSJPoint::set_blending_radius(float value) {
  
  blending_radius_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSJPoint.blending_radius)
}

// -------------------------------------------------------------------

// MoveSJTPoint

// repeated float jpos = 1;
inline int MoveSJTPoint::jpos_size() const {
  return jpos_.size();
}
inline void MoveSJTPoint::clear_jpos() {
  jpos_.Clear();
}
inline float MoveSJTPoint::jpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSJTPoint.jpos)
  return jpos_.Get(index);
}
inline void MoveSJTPoint::set_jpos(int index, float value) {
  jpos_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSJTPoint.jpos)
}
inline void MoveSJTPoint::add_jpos(float value) {
  jpos_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.MoveSJTPoint.jpos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
MoveSJTPoint::jpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.MoveSJTPoint.jpos)
  return jpos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
MoveSJTPoint::mutable_jpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.MoveSJTPoint.jpos)
  return &jpos_;
}

// float blending_radius = 2;
inline void MoveSJTPoint::clear_blending_radius() {
  blending_radius_ = 0;
}
inline float MoveSJTPoint::blending_radius() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSJTPoint.blending_radius)
  return blending_radius_;
}
inline void MoveSJTPoint::set_blending_radius(float value) {
  
  blending_radius_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSJTPoint.blending_radius)
}

// float time = 3;
inline void MoveSJTPoint::clear_time() {
  time_ = 0;
}
inline float MoveSJTPoint::time() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSJTPoint.time)
  return time_;
}
inline void MoveSJTPoint::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSJTPoint.time)
}

// -------------------------------------------------------------------

// MoveSLPoint

// repeated float tpos = 1;
inline int MoveSLPoint::tpos_size() const {
  return tpos_.size();
}
inline void MoveSLPoint::clear_tpos() {
  tpos_.Clear();
}
inline float MoveSLPoint::tpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSLPoint.tpos)
  return tpos_.Get(index);
}
inline void MoveSLPoint::set_tpos(int index, float value) {
  tpos_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSLPoint.tpos)
}
inline void MoveSLPoint::add_tpos(float value) {
  tpos_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.MoveSLPoint.tpos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
MoveSLPoint::tpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.MoveSLPoint.tpos)
  return tpos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
MoveSLPoint::mutable_tpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.MoveSLPoint.tpos)
  return &tpos_;
}

// float blending_radius = 2;
inline void MoveSLPoint::clear_blending_radius() {
  blending_radius_ = 0;
}
inline float MoveSLPoint::blending_radius() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSLPoint.blending_radius)
  return blending_radius_;
}
inline void MoveSLPoint::set_blending_radius(float value) {
  
  blending_radius_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSLPoint.blending_radius)
}

// -------------------------------------------------------------------

// MoveSLTPoint

// repeated float tpos = 1;
inline int MoveSLTPoint::tpos_size() const {
  return tpos_.size();
}
inline void MoveSLTPoint::clear_tpos() {
  tpos_.Clear();
}
inline float MoveSLTPoint::tpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSLTPoint.tpos)
  return tpos_.Get(index);
}
inline void MoveSLTPoint::set_tpos(int index, float value) {
  tpos_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSLTPoint.tpos)
}
inline void MoveSLTPoint::add_tpos(float value) {
  tpos_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.MoveSLTPoint.tpos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
MoveSLTPoint::tpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.MoveSLTPoint.tpos)
  return tpos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
MoveSLTPoint::mutable_tpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.MoveSLTPoint.tpos)
  return &tpos_;
}

// float blending_radius = 2;
inline void MoveSLTPoint::clear_blending_radius() {
  blending_radius_ = 0;
}
inline float MoveSLTPoint::blending_radius() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSLTPoint.blending_radius)
  return blending_radius_;
}
inline void MoveSLTPoint::set_blending_radius(float value) {
  
  blending_radius_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSLTPoint.blending_radius)
}

// float time = 3;
inline void MoveSLTPoint::clear_time() {
  time_ = 0;
}
inline float MoveSLTPoint::time() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSLTPoint.time)
  return time_;
}
inline void MoveSLTPoint::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSLTPoint.time)
}

// -------------------------------------------------------------------

// DigitalSignal

// int32 addr = 1;
inline void DigitalSignal::clear_addr() {
  addr_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DigitalSignal::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.DigitalSignal.addr)
  return addr_;
}
inline void DigitalSignal::set_addr(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  addr_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.DigitalSignal.addr)
}

// bool on = 2;
inline void DigitalSignal::clear_on() {
  on_ = false;
}
inline bool DigitalSignal::on() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.DigitalSignal.on)
  return on_;
}
inline void DigitalSignal::set_on(bool value) {
  
  on_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.DigitalSignal.on)
}

// -------------------------------------------------------------------

// AnalogSignal

// int32 addr = 1;
inline void AnalogSignal::clear_addr() {
  addr_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AnalogSignal::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.AnalogSignal.addr)
  return addr_;
}
inline void AnalogSignal::set_addr(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  addr_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.AnalogSignal.addr)
}

// int32 voltage = 2;
inline void AnalogSignal::clear_voltage() {
  voltage_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AnalogSignal::voltage() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.AnalogSignal.voltage)
  return voltage_;
}
inline void AnalogSignal::set_voltage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  voltage_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.AnalogSignal.voltage)
}

// -------------------------------------------------------------------

// NamedTaskPosition

// string name = 1;
inline void NamedTaskPosition::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NamedTaskPosition::name() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedTaskPosition.name)
  return name_.GetNoArena();
}
inline void NamedTaskPosition::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedTaskPosition.name)
}
inline void NamedTaskPosition::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IndyFramework.Protobuf.Shared.NamedTaskPosition.name)
}
inline void NamedTaskPosition::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IndyFramework.Protobuf.Shared.NamedTaskPosition.name)
}
inline void NamedTaskPosition::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IndyFramework.Protobuf.Shared.NamedTaskPosition.name)
}
inline std::string* NamedTaskPosition::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.NamedTaskPosition.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NamedTaskPosition::release_name() {
  // @@protoc_insertion_point(field_release:IndyFramework.Protobuf.Shared.NamedTaskPosition.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NamedTaskPosition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:IndyFramework.Protobuf.Shared.NamedTaskPosition.name)
}

// repeated float tpos = 2;
inline int NamedTaskPosition::tpos_size() const {
  return tpos_.size();
}
inline void NamedTaskPosition::clear_tpos() {
  tpos_.Clear();
}
inline float NamedTaskPosition::tpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedTaskPosition.tpos)
  return tpos_.Get(index);
}
inline void NamedTaskPosition::set_tpos(int index, float value) {
  tpos_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedTaskPosition.tpos)
}
inline void NamedTaskPosition::add_tpos(float value) {
  tpos_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.NamedTaskPosition.tpos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
NamedTaskPosition::tpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.NamedTaskPosition.tpos)
  return tpos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
NamedTaskPosition::mutable_tpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.NamedTaskPosition.tpos)
  return &tpos_;
}

// -------------------------------------------------------------------

// NamedJointPosition

// string name = 1;
inline void NamedJointPosition::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NamedJointPosition::name() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedJointPosition.name)
  return name_.GetNoArena();
}
inline void NamedJointPosition::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedJointPosition.name)
}
inline void NamedJointPosition::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IndyFramework.Protobuf.Shared.NamedJointPosition.name)
}
inline void NamedJointPosition::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IndyFramework.Protobuf.Shared.NamedJointPosition.name)
}
inline void NamedJointPosition::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IndyFramework.Protobuf.Shared.NamedJointPosition.name)
}
inline std::string* NamedJointPosition::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.NamedJointPosition.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NamedJointPosition::release_name() {
  // @@protoc_insertion_point(field_release:IndyFramework.Protobuf.Shared.NamedJointPosition.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NamedJointPosition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:IndyFramework.Protobuf.Shared.NamedJointPosition.name)
}

// repeated float jpos = 2;
inline int NamedJointPosition::jpos_size() const {
  return jpos_.size();
}
inline void NamedJointPosition::clear_jpos() {
  jpos_.Clear();
}
inline float NamedJointPosition::jpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedJointPosition.jpos)
  return jpos_.Get(index);
}
inline void NamedJointPosition::set_jpos(int index, float value) {
  jpos_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedJointPosition.jpos)
}
inline void NamedJointPosition::add_jpos(float value) {
  jpos_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.NamedJointPosition.jpos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
NamedJointPosition::jpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.NamedJointPosition.jpos)
  return jpos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
NamedJointPosition::mutable_jpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.NamedJointPosition.jpos)
  return &jpos_;
}

// -------------------------------------------------------------------

// NamedReferencePosition

// string name = 1;
inline void NamedReferencePosition::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NamedReferencePosition::name() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedReferencePosition.name)
  return name_.GetNoArena();
}
inline void NamedReferencePosition::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedReferencePosition.name)
}
inline void NamedReferencePosition::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IndyFramework.Protobuf.Shared.NamedReferencePosition.name)
}
inline void NamedReferencePosition::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IndyFramework.Protobuf.Shared.NamedReferencePosition.name)
}
inline void NamedReferencePosition::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IndyFramework.Protobuf.Shared.NamedReferencePosition.name)
}
inline std::string* NamedReferencePosition::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.NamedReferencePosition.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NamedReferencePosition::release_name() {
  // @@protoc_insertion_point(field_release:IndyFramework.Protobuf.Shared.NamedReferencePosition.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NamedReferencePosition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:IndyFramework.Protobuf.Shared.NamedReferencePosition.name)
}

// repeated float tpos = 2;
inline int NamedReferencePosition::tpos_size() const {
  return tpos_.size();
}
inline void NamedReferencePosition::clear_tpos() {
  tpos_.Clear();
}
inline float NamedReferencePosition::tpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos)
  return tpos_.Get(index);
}
inline void NamedReferencePosition::set_tpos(int index, float value) {
  tpos_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos)
}
inline void NamedReferencePosition::add_tpos(float value) {
  tpos_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
NamedReferencePosition::tpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos)
  return tpos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
NamedReferencePosition::mutable_tpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos)
  return &tpos_;
}

// repeated float tpos0 = 3;
inline int NamedReferencePosition::tpos0_size() const {
  return tpos0_.size();
}
inline void NamedReferencePosition::clear_tpos0() {
  tpos0_.Clear();
}
inline float NamedReferencePosition::tpos0(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos0)
  return tpos0_.Get(index);
}
inline void NamedReferencePosition::set_tpos0(int index, float value) {
  tpos0_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos0)
}
inline void NamedReferencePosition::add_tpos0(float value) {
  tpos0_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos0)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
NamedReferencePosition::tpos0() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos0)
  return tpos0_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
NamedReferencePosition::mutable_tpos0() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos0)
  return &tpos0_;
}

// repeated float tpos1 = 4;
inline int NamedReferencePosition::tpos1_size() const {
  return tpos1_.size();
}
inline void NamedReferencePosition::clear_tpos1() {
  tpos1_.Clear();
}
inline float NamedReferencePosition::tpos1(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos1)
  return tpos1_.Get(index);
}
inline void NamedReferencePosition::set_tpos1(int index, float value) {
  tpos1_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos1)
}
inline void NamedReferencePosition::add_tpos1(float value) {
  tpos1_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos1)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
NamedReferencePosition::tpos1() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos1)
  return tpos1_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
NamedReferencePosition::mutable_tpos1() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos1)
  return &tpos1_;
}

// repeated float tpos2 = 5;
inline int NamedReferencePosition::tpos2_size() const {
  return tpos2_.size();
}
inline void NamedReferencePosition::clear_tpos2() {
  tpos2_.Clear();
}
inline float NamedReferencePosition::tpos2(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos2)
  return tpos2_.Get(index);
}
inline void NamedReferencePosition::set_tpos2(int index, float value) {
  tpos2_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos2)
}
inline void NamedReferencePosition::add_tpos2(float value) {
  tpos2_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos2)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
NamedReferencePosition::tpos2() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos2)
  return tpos2_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
NamedReferencePosition::mutable_tpos2() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos2)
  return &tpos2_;
}

// -------------------------------------------------------------------

// IntVariable

// int32 addr = 1;
inline void IntVariable::clear_addr() {
  addr_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntVariable::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.IntVariable.addr)
  return addr_;
}
inline void IntVariable::set_addr(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  addr_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.IntVariable.addr)
}

// int32 value = 2;
inline void IntVariable::clear_value() {
  value_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntVariable::value() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.IntVariable.value)
  return value_;
}
inline void IntVariable::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.IntVariable.value)
}

// -------------------------------------------------------------------

// ModbusVariable

// int32 addr = 1;
inline void ModbusVariable::clear_addr() {
  addr_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusVariable::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.ModbusVariable.addr)
  return addr_;
}
inline void ModbusVariable::set_addr(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  addr_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.ModbusVariable.addr)
}

// int32 value = 2;
inline void ModbusVariable::clear_value() {
  value_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusVariable::value() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.ModbusVariable.value)
  return value_;
}
inline void ModbusVariable::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.ModbusVariable.value)
}

// -------------------------------------------------------------------

// BoolVariable

// int32 addr = 1;
inline void BoolVariable::clear_addr() {
  addr_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BoolVariable::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.BoolVariable.addr)
  return addr_;
}
inline void BoolVariable::set_addr(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  addr_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.BoolVariable.addr)
}

// bool value = 2;
inline void BoolVariable::clear_value() {
  value_ = false;
}
inline bool BoolVariable::value() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.BoolVariable.value)
  return value_;
}
inline void BoolVariable::set_value(bool value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.BoolVariable.value)
}

// -------------------------------------------------------------------

// FloatVariable

// int32 addr = 1;
inline void FloatVariable::clear_addr() {
  addr_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FloatVariable::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.FloatVariable.addr)
  return addr_;
}
inline void FloatVariable::set_addr(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  addr_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.FloatVariable.addr)
}

// float value = 2;
inline void FloatVariable::clear_value() {
  value_ = 0;
}
inline float FloatVariable::value() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.FloatVariable.value)
  return value_;
}
inline void FloatVariable::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.FloatVariable.value)
}

// -------------------------------------------------------------------

// JPosVariable

// int32 addr = 1;
inline void JPosVariable::clear_addr() {
  addr_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JPosVariable::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.JPosVariable.addr)
  return addr_;
}
inline void JPosVariable::set_addr(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  addr_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.JPosVariable.addr)
}

// repeated float jpos = 2;
inline int JPosVariable::jpos_size() const {
  return jpos_.size();
}
inline void JPosVariable::clear_jpos() {
  jpos_.Clear();
}
inline float JPosVariable::jpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.JPosVariable.jpos)
  return jpos_.Get(index);
}
inline void JPosVariable::set_jpos(int index, float value) {
  jpos_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.JPosVariable.jpos)
}
inline void JPosVariable::add_jpos(float value) {
  jpos_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.JPosVariable.jpos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JPosVariable::jpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.JPosVariable.jpos)
  return jpos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JPosVariable::mutable_jpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.JPosVariable.jpos)
  return &jpos_;
}

// -------------------------------------------------------------------

// TPosVariable

// int32 addr = 1;
inline void TPosVariable::clear_addr() {
  addr_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TPosVariable::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.TPosVariable.addr)
  return addr_;
}
inline void TPosVariable::set_addr(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  addr_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.TPosVariable.addr)
}

// repeated float tpos = 2;
inline int TPosVariable::tpos_size() const {
  return tpos_.size();
}
inline void TPosVariable::clear_tpos() {
  tpos_.Clear();
}
inline float TPosVariable::tpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.TPosVariable.tpos)
  return tpos_.Get(index);
}
inline void TPosVariable::set_tpos(int index, float value) {
  tpos_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.TPosVariable.tpos)
}
inline void TPosVariable::add_tpos(float value) {
  tpos_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.TPosVariable.tpos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TPosVariable::tpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.TPosVariable.tpos)
  return tpos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TPosVariable::mutable_tpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.TPosVariable.tpos)
  return &tpos_;
}

// -------------------------------------------------------------------

// Tool

// string name = 1;
inline void Tool::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Tool::name() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.Tool.name)
  return name_.GetNoArena();
}
inline void Tool::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.Tool.name)
}
inline void Tool::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IndyFramework.Protobuf.Shared.Tool.name)
}
inline void Tool::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IndyFramework.Protobuf.Shared.Tool.name)
}
inline void Tool::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IndyFramework.Protobuf.Shared.Tool.name)
}
inline std::string* Tool::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.Tool.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Tool::release_name() {
  // @@protoc_insertion_point(field_release:IndyFramework.Protobuf.Shared.Tool.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Tool::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:IndyFramework.Protobuf.Shared.Tool.name)
}

// .IndyFramework.Protobuf.Shared.Tool.ToolType tool_type = 2;
inline void Tool::clear_tool_type() {
  tool_type_ = 0;
}
inline ::IndyFramework::Protobuf::Shared::Tool_ToolType Tool::tool_type() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.Tool.tool_type)
  return static_cast< ::IndyFramework::Protobuf::Shared::Tool_ToolType >(tool_type_);
}
inline void Tool::set_tool_type(::IndyFramework::Protobuf::Shared::Tool_ToolType value) {
  
  tool_type_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.Tool.tool_type)
}

// repeated .IndyFramework.Protobuf.Shared.DigitalSignal do_list = 5;
inline int Tool::do_list_size() const {
  return do_list_.size();
}
inline void Tool::clear_do_list() {
  do_list_.Clear();
}
inline ::IndyFramework::Protobuf::Shared::DigitalSignal* Tool::mutable_do_list(int index) {
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.Tool.do_list)
  return do_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::DigitalSignal >*
Tool::mutable_do_list() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.Tool.do_list)
  return &do_list_;
}
inline const ::IndyFramework::Protobuf::Shared::DigitalSignal& Tool::do_list(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.Tool.do_list)
  return do_list_.Get(index);
}
inline ::IndyFramework::Protobuf::Shared::DigitalSignal* Tool::add_do_list() {
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.Tool.do_list)
  return do_list_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::DigitalSignal >&
Tool::do_list() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.Tool.do_list)
  return do_list_;
}

// repeated .IndyFramework.Protobuf.Shared.ModbusVariable m_vars = 6;
inline int Tool::m_vars_size() const {
  return m_vars_.size();
}
inline void Tool::clear_m_vars() {
  m_vars_.Clear();
}
inline ::IndyFramework::Protobuf::Shared::ModbusVariable* Tool::mutable_m_vars(int index) {
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.Tool.m_vars)
  return m_vars_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::ModbusVariable >*
Tool::mutable_m_vars() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.Tool.m_vars)
  return &m_vars_;
}
inline const ::IndyFramework::Protobuf::Shared::ModbusVariable& Tool::m_vars(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.Tool.m_vars)
  return m_vars_.Get(index);
}
inline ::IndyFramework::Protobuf::Shared::ModbusVariable* Tool::add_m_vars() {
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.Tool.m_vars)
  return m_vars_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::ModbusVariable >&
Tool::m_vars() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.Tool.m_vars)
  return m_vars_;
}

// float sleep_time = 10;
inline void Tool::clear_sleep_time() {
  sleep_time_ = 0;
}
inline float Tool::sleep_time() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.Tool.sleep_time)
  return sleep_time_;
}
inline void Tool::set_sleep_time(float value) {
  
  sleep_time_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.Tool.sleep_time)
}

// -------------------------------------------------------------------

// PalletPoint

// repeated float tar_pos = 1;
inline int PalletPoint::tar_pos_size() const {
  return tar_pos_.size();
}
inline void PalletPoint::clear_tar_pos() {
  tar_pos_.Clear();
}
inline float PalletPoint::tar_pos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.PalletPoint.tar_pos)
  return tar_pos_.Get(index);
}
inline void PalletPoint::set_tar_pos(int index, float value) {
  tar_pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.PalletPoint.tar_pos)
}
inline void PalletPoint::add_tar_pos(float value) {
  tar_pos_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.PalletPoint.tar_pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PalletPoint::tar_pos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.PalletPoint.tar_pos)
  return tar_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PalletPoint::mutable_tar_pos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.PalletPoint.tar_pos)
  return &tar_pos_;
}

// repeated float approach_pos = 2;
inline int PalletPoint::approach_pos_size() const {
  return approach_pos_.size();
}
inline void PalletPoint::clear_approach_pos() {
  approach_pos_.Clear();
}
inline float PalletPoint::approach_pos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.PalletPoint.approach_pos)
  return approach_pos_.Get(index);
}
inline void PalletPoint::set_approach_pos(int index, float value) {
  approach_pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.PalletPoint.approach_pos)
}
inline void PalletPoint::add_approach_pos(float value) {
  approach_pos_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.PalletPoint.approach_pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PalletPoint::approach_pos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.PalletPoint.approach_pos)
  return approach_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PalletPoint::mutable_approach_pos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.PalletPoint.approach_pos)
  return &approach_pos_;
}

// repeated float retract_pos = 3;
inline int PalletPoint::retract_pos_size() const {
  return retract_pos_.size();
}
inline void PalletPoint::clear_retract_pos() {
  retract_pos_.Clear();
}
inline float PalletPoint::retract_pos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.PalletPoint.retract_pos)
  return retract_pos_.Get(index);
}
inline void PalletPoint::set_retract_pos(int index, float value) {
  retract_pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.PalletPoint.retract_pos)
}
inline void PalletPoint::add_retract_pos(float value) {
  retract_pos_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.PalletPoint.retract_pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PalletPoint::retract_pos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.PalletPoint.retract_pos)
  return retract_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PalletPoint::mutable_retract_pos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.PalletPoint.retract_pos)
  return &retract_pos_;
}

// repeated float tar_jpos = 4;
inline int PalletPoint::tar_jpos_size() const {
  return tar_jpos_.size();
}
inline void PalletPoint::clear_tar_jpos() {
  tar_jpos_.Clear();
}
inline float PalletPoint::tar_jpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.PalletPoint.tar_jpos)
  return tar_jpos_.Get(index);
}
inline void PalletPoint::set_tar_jpos(int index, float value) {
  tar_jpos_.Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.PalletPoint.tar_jpos)
}
inline void PalletPoint::add_tar_jpos(float value) {
  tar_jpos_.Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.PalletPoint.tar_jpos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PalletPoint::tar_jpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.PalletPoint.tar_jpos)
  return tar_jpos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PalletPoint::mutable_tar_jpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.PalletPoint.tar_jpos)
  return &tar_jpos_;
}

// -------------------------------------------------------------------

// VisionServer

// string name = 1;
inline void VisionServer::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VisionServer::name() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.VisionServer.name)
  return name_.GetNoArena();
}
inline void VisionServer::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.VisionServer.name)
}
inline void VisionServer::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IndyFramework.Protobuf.Shared.VisionServer.name)
}
inline void VisionServer::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IndyFramework.Protobuf.Shared.VisionServer.name)
}
inline void VisionServer::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IndyFramework.Protobuf.Shared.VisionServer.name)
}
inline std::string* VisionServer::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.VisionServer.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VisionServer::release_name() {
  // @@protoc_insertion_point(field_release:IndyFramework.Protobuf.Shared.VisionServer.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VisionServer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:IndyFramework.Protobuf.Shared.VisionServer.name)
}

// .IndyFramework.Protobuf.Shared.VisionServer.VisionServerType vision_server_type = 2;
inline void VisionServer::clear_vision_server_type() {
  vision_server_type_ = 0;
}
inline ::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType VisionServer::vision_server_type() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.VisionServer.vision_server_type)
  return static_cast< ::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType >(vision_server_type_);
}
inline void VisionServer::set_vision_server_type(::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType value) {
  
  vision_server_type_ = value;
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.VisionServer.vision_server_type)
}

// string ip = 3;
inline void VisionServer::clear_ip() {
  ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VisionServer::ip() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.VisionServer.ip)
  return ip_.GetNoArena();
}
inline void VisionServer::set_ip(const std::string& value) {
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.VisionServer.ip)
}
inline void VisionServer::set_ip(std::string&& value) {
  
  ip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IndyFramework.Protobuf.Shared.VisionServer.ip)
}
inline void VisionServer::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IndyFramework.Protobuf.Shared.VisionServer.ip)
}
inline void VisionServer::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IndyFramework.Protobuf.Shared.VisionServer.ip)
}
inline std::string* VisionServer::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.VisionServer.ip)
  return ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VisionServer::release_ip() {
  // @@protoc_insertion_point(field_release:IndyFramework.Protobuf.Shared.VisionServer.ip)
  
  return ip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VisionServer::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:IndyFramework.Protobuf.Shared.VisionServer.ip)
}

// string port = 4;
inline void VisionServer::clear_port() {
  port_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VisionServer::port() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.VisionServer.port)
  return port_.GetNoArena();
}
inline void VisionServer::set_port(const std::string& value) {
  
  port_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.VisionServer.port)
}
inline void VisionServer::set_port(std::string&& value) {
  
  port_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IndyFramework.Protobuf.Shared.VisionServer.port)
}
inline void VisionServer::set_port(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  port_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IndyFramework.Protobuf.Shared.VisionServer.port)
}
inline void VisionServer::set_port(const char* value, size_t size) {
  
  port_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IndyFramework.Protobuf.Shared.VisionServer.port)
}
inline std::string* VisionServer::mutable_port() {
  
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.VisionServer.port)
  return port_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VisionServer::release_port() {
  // @@protoc_insertion_point(field_release:IndyFramework.Protobuf.Shared.VisionServer.port)
  
  return port_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VisionServer::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    
  } else {
    
  }
  port_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:IndyFramework.Protobuf.Shared.VisionServer.port)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Shared
}  // namespace Protobuf
}  // namespace IndyFramework

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::Tool_ToolType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::Tool_ToolType>() {
  return ::IndyFramework::Protobuf::Shared::Tool_ToolType_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType>() {
  return ::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::MotionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::MotionState>() {
  return ::IndyFramework::Protobuf::Shared::MotionState_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::EndToolPortType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::EndToolPortType>() {
  return ::IndyFramework::Protobuf::Shared::EndToolPortType_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::ControlBoxType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::ControlBoxType>() {
  return ::IndyFramework::Protobuf::Shared::ControlBoxType_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::VariableType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::VariableType>() {
  return ::IndyFramework::Protobuf::Shared::VariableType_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::ProgramState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::ProgramState>() {
  return ::IndyFramework::Protobuf::Shared::ProgramState_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::ProgramControl> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::ProgramControl>() {
  return ::IndyFramework::Protobuf::Shared::ProgramControl_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::ProgramCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::ProgramCategory>() {
  return ::IndyFramework::Protobuf::Shared::ProgramCategory_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::JointBaseType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::JointBaseType>() {
  return ::IndyFramework::Protobuf::Shared::JointBaseType_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::TaskBaseType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::TaskBaseType>() {
  return ::IndyFramework::Protobuf::Shared::TaskBaseType_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::BlendingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::BlendingType>() {
  return ::IndyFramework::Protobuf::Shared::BlendingType_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::CircularSettingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::CircularSettingType>() {
  return ::IndyFramework::Protobuf::Shared::CircularSettingType_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::CircularMovingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::CircularMovingType>() {
  return ::IndyFramework::Protobuf::Shared::CircularMovingType_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::TrajState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::TrajState>() {
  return ::IndyFramework::Protobuf::Shared::TrajState_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::TrajCondition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::TrajCondition>() {
  return ::IndyFramework::Protobuf::Shared::TrajCondition_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::CollisionPolicy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::CollisionPolicy>() {
  return ::IndyFramework::Protobuf::Shared::CollisionPolicy_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::StopCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::StopCategory>() {
  return ::IndyFramework::Protobuf::Shared::StopCategory_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::PauseCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::PauseCategory>() {
  return ::IndyFramework::Protobuf::Shared::PauseCategory_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::EyeCommandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::EyeCommandType>() {
  return ::IndyFramework::Protobuf::Shared::EyeCommandType_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::DIConfigFunc> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::DIConfigFunc>() {
  return ::IndyFramework::Protobuf::Shared::DIConfigFunc_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::DOConfigState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::DOConfigState>() {
  return ::IndyFramework::Protobuf::Shared::DOConfigState_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::OpState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::OpState>() {
  return ::IndyFramework::Protobuf::Shared::OpState_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::LogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::LogLevel>() {
  return ::IndyFramework::Protobuf::Shared::LogLevel_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::JogFrameType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::JogFrameType>() {
  return ::IndyFramework::Protobuf::Shared::JogFrameType_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::Axis> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::Axis>() {
  return ::IndyFramework::Protobuf::Shared::Axis_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::VisionFrameType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::VisionFrameType>() {
  return ::IndyFramework::Protobuf::Shared::VisionFrameType_descriptor();
}
template <> struct is_proto_enum< ::IndyFramework::Protobuf::Shared::WeavingBase> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IndyFramework::Protobuf::Shared::WeavingBase>() {
  return ::IndyFramework::Protobuf::Shared::WeavingBase_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_shared_5fmsgs_2eproto
