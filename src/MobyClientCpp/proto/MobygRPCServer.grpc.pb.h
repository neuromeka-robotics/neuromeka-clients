// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: MobygRPCServer.proto
#ifndef GRPC_MobygRPCServer_2eproto__INCLUDED
#define GRPC_MobygRPCServer_2eproto__INCLUDED

#include "MobygRPCServer.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class CompletionQueue;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc

namespace GRPCMoby {

class GRPCMobyTask final {
 public:
  static constexpr char const* service_full_name() {
    return "GRPCMoby.GRPCMobyTask";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    //  Moby EtherCAT TxPDO and RxPDO data processing
    virtual ::grpc::Status GetMobyTxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::GRPCMoby::MotorDriverTx* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MotorDriverTx>> AsyncGetMobyTxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MotorDriverTx>>(AsyncGetMobyTxDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MotorDriverTx>> PrepareAsyncGetMobyTxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MotorDriverTx>>(PrepareAsyncGetMobyTxDataRaw(context, request, cq));
    }
    virtual ::grpc::Status GetMobyRxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::GRPCMoby::MotorDriverRx* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MotorDriverRx>> AsyncGetMobyRxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MotorDriverRx>>(AsyncGetMobyRxDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MotorDriverRx>> PrepareAsyncGetMobyRxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MotorDriverRx>>(PrepareAsyncGetMobyRxDataRaw(context, request, cq));
    }
    // Get Moby state
    virtual ::grpc::Status GetMobyState(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::MobyState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyState>> AsyncGetMobyState(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyState>>(AsyncGetMobyStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyState>> PrepareAsyncGetMobyState(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyState>>(PrepareAsyncGetMobyStateRaw(context, request, cq));
    }
    virtual ::grpc::Status GetMobyErrorState(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::MobyErrorState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyErrorState>> AsyncGetMobyErrorState(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyErrorState>>(AsyncGetMobyErrorStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyErrorState>> PrepareAsyncGetMobyErrorState(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyErrorState>>(PrepareAsyncGetMobyErrorStateRaw(context, request, cq));
    }
    virtual ::grpc::Status Recover(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncRecover(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncRecoverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncRecover(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncRecoverRaw(context, request, cq));
    }
    // Get Moby's odometry and physical data
    virtual ::grpc::Status GetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::MobyPose* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyPose>> AsyncGetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyPose>>(AsyncGetMobyPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyPose>> PrepareAsyncGetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyPose>>(PrepareAsyncGetMobyPoseRaw(context, request, cq));
    }
    virtual ::grpc::Status GetMobyVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::MobyVel* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyVel>> AsyncGetMobyVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyVel>>(AsyncGetMobyVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyVel>> PrepareAsyncGetMobyVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyVel>>(PrepareAsyncGetMobyVelRaw(context, request, cq));
    }
    virtual ::grpc::Status ResetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncResetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncResetMobyPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncResetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncResetMobyPoseRaw(context, request, cq));
    }
    virtual ::grpc::Status GetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::SwerveDoubles* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::SwerveDoubles>> AsyncGetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::SwerveDoubles>>(AsyncGetRotationAngleDegRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::SwerveDoubles>> PrepareAsyncGetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::SwerveDoubles>>(PrepareAsyncGetRotationAngleDegRaw(context, request, cq));
    }
    virtual ::grpc::Status GetDriveSpeed(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::SwerveDoubles* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::SwerveDoubles>> AsyncGetDriveSpeed(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::SwerveDoubles>>(AsyncGetDriveSpeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::SwerveDoubles>> PrepareAsyncGetDriveSpeed(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::SwerveDoubles>>(PrepareAsyncGetDriveSpeedRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTargetVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::TargetVel* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::TargetVel>> AsyncGetTargetVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::TargetVel>>(AsyncGetTargetVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::TargetVel>> PrepareAsyncGetTargetVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::TargetVel>>(PrepareAsyncGetTargetVelRaw(context, request, cq));
    }
    virtual ::grpc::Status GetRotationZeroCount(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::ZeroCount* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::ZeroCount>> AsyncGetRotationZeroCount(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::ZeroCount>>(AsyncGetRotationZeroCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::ZeroCount>> PrepareAsyncGetRotationZeroCount(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::ZeroCount>>(PrepareAsyncGetRotationZeroCountRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCMode(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::IntVal* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IntVal>> AsyncGetCMode(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IntVal>>(AsyncGetCModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IntVal>> PrepareAsyncGetCMode(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IntVal>>(PrepareAsyncGetCModeRaw(context, request, cq));
    }
    // Gyro value related
    virtual ::grpc::Status GetGyroData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::DoubleVals* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::DoubleVals>> AsyncGetGyroData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::DoubleVals>>(AsyncGetGyroDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::DoubleVals>> PrepareAsyncGetGyroData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::DoubleVals>>(PrepareAsyncGetGyroDataRaw(context, request, cq));
    }
    virtual ::grpc::Status ResetGyroSensor(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncResetGyroSensor(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncResetGyroSensorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncResetGyroSensor(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncResetGyroSensorRaw(context, request, cq));
    }
    virtual ::grpc::Status UseGyroForOdom(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncUseGyroForOdom(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncUseGyroForOdomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncUseGyroForOdom(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncUseGyroForOdomRaw(context, request, cq));
    }
    virtual ::grpc::Status GetGyroFullData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::IMUData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IMUData>> AsyncGetGyroFullData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IMUData>>(AsyncGetGyroFullDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IMUData>> PrepareAsyncGetGyroFullData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IMUData>>(PrepareAsyncGetGyroFullDataRaw(context, request, cq));
    }
    // IR sensor
    virtual ::grpc::Status GetIRSensorData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::IRData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IRData>> AsyncGetIRSensorData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IRData>>(AsyncGetIRSensorDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IRData>> PrepareAsyncGetIRSensorData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IRData>>(PrepareAsyncGetIRSensorDataRaw(context, request, cq));
    }
    // BMS data
    virtual ::grpc::Status GetBMSData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::BMSData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::BMSData>> AsyncGetBMSData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::BMSData>>(AsyncGetBMSDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::BMSData>> PrepareAsyncGetBMSData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::BMSData>>(PrepareAsyncGetBMSDataRaw(context, request, cq));
    }
    // Moby motion command
    virtual ::grpc::Status SetStepControl(::grpc::ClientContext* context, const ::GRPCMoby::TargetVel& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncSetStepControl(::grpc::ClientContext* context, const ::GRPCMoby::TargetVel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncSetStepControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncSetStepControl(::grpc::ClientContext* context, const ::GRPCMoby::TargetVel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncSetStepControlRaw(context, request, cq));
    }
    virtual ::grpc::Status StopMotion(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncStopMotion(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncStopMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncStopMotion(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncStopMotionRaw(context, request, cq));
    }
    virtual ::grpc::Status SetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncSetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncSetRotationAngleDegRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncSetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncSetRotationAngleDegRaw(context, request, cq));
    }
    virtual ::grpc::Status DriveWheel(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncDriveWheel(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncDriveWheelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncDriveWheel(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncDriveWheelRaw(context, request, cq));
    }
    // Set Moby parameters
    virtual ::grpc::Status SetZeroPosAsCurrentPos(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncSetZeroPosAsCurrentPos(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncSetZeroPosAsCurrentPosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncSetZeroPosAsCurrentPos(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncSetZeroPosAsCurrentPosRaw(context, request, cq));
    }
    virtual ::grpc::Status SetRotationVelAcc(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncSetRotationVelAcc(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncSetRotationVelAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncSetRotationVelAcc(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncSetRotationVelAccRaw(context, request, cq));
    }
    virtual ::grpc::Status SetDriveAccDec(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncSetDriveAccDec(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncSetDriveAccDecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncSetDriveAccDec(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncSetDriveAccDecRaw(context, request, cq));
    }
    virtual ::grpc::Status SetDriveInterpolatorOnOff(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncSetDriveInterpolatorOnOff(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncSetDriveInterpolatorOnOffRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncSetDriveInterpolatorOnOff(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncSetDriveInterpolatorOnOffRaw(context, request, cq));
    }
    virtual ::grpc::Status SetRotationInterpolatorParam(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncSetRotationInterpolatorParam(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncSetRotationInterpolatorParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncSetRotationInterpolatorParam(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncSetRotationInterpolatorParamRaw(context, request, cq));
    }
    // Gain setting
    virtual ::grpc::Status SetRotationTorqueMode(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncSetRotationTorqueMode(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncSetRotationTorqueModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncSetRotationTorqueMode(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncSetRotationTorqueModeRaw(context, request, cq));
    }
    virtual ::grpc::Status SetControlParam(::grpc::ClientContext* context, const ::GRPCMoby::RotationGain& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncSetControlParam(::grpc::ClientContext* context, const ::GRPCMoby::RotationGain& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncSetControlParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncSetControlParam(::grpc::ClientContext* context, const ::GRPCMoby::RotationGain& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncSetControlParamRaw(context, request, cq));
    }
    // Data logging
    virtual ::grpc::Status StartRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncStartRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncStartRTLoggingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncStartRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncStartRTLoggingRaw(context, request, cq));
    }
    virtual ::grpc::Status EndRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncEndRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncEndRTLoggingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncEndRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncEndRTLoggingRaw(context, request, cq));
    }
    virtual ::grpc::Status SetLoggerBuffer(::grpc::ClientContext* context, const ::GRPCMoby::IntVals& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncSetLoggerBuffer(::grpc::ClientContext* context, const ::GRPCMoby::IntVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncSetLoggerBufferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncSetLoggerBuffer(::grpc::ClientContext* context, const ::GRPCMoby::IntVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncSetLoggerBufferRaw(context, request, cq));
    }
    virtual ::grpc::Status RTLoggerSave(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> AsyncRTLoggerSave(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(AsyncRTLoggerSaveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>> PrepareAsyncRTLoggerSave(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>>(PrepareAsyncRTLoggerSaveRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      //  Moby EtherCAT TxPDO and RxPDO data processing
      virtual void GetMobyTxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal* request, ::GRPCMoby::MotorDriverTx* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMobyTxData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MotorDriverTx* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMobyTxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal* request, ::GRPCMoby::MotorDriverTx* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMobyTxData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MotorDriverTx* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMobyRxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal* request, ::GRPCMoby::MotorDriverRx* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMobyRxData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MotorDriverRx* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMobyRxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal* request, ::GRPCMoby::MotorDriverRx* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMobyRxData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MotorDriverRx* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Get Moby state
      virtual void GetMobyState(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMobyState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMobyState(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMobyState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMobyErrorState(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyErrorState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMobyErrorState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyErrorState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMobyErrorState(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyErrorState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMobyErrorState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyErrorState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Recover(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Recover(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Recover(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Recover(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Get Moby's odometry and physical data
      virtual void GetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyPose* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMobyPose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyPose* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyPose* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMobyPose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyPose* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMobyVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyVel* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMobyVel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyVel* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMobyVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyVel* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMobyVel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyVel* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ResetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResetMobyPose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ResetMobyPose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::SwerveDoubles* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRotationAngleDeg(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::SwerveDoubles* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::SwerveDoubles* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetRotationAngleDeg(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::SwerveDoubles* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetDriveSpeed(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::SwerveDoubles* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDriveSpeed(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::SwerveDoubles* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDriveSpeed(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::SwerveDoubles* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetDriveSpeed(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::SwerveDoubles* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetTargetVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::TargetVel* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTargetVel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::TargetVel* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTargetVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::TargetVel* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetTargetVel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::TargetVel* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetRotationZeroCount(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::ZeroCount* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRotationZeroCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::ZeroCount* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRotationZeroCount(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::ZeroCount* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetRotationZeroCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::ZeroCount* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetCMode(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::IntVal* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::IntVal* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCMode(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::IntVal* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetCMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::IntVal* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Gyro value related
      virtual void GetGyroData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::DoubleVals* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGyroData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::DoubleVals* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGyroData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::DoubleVals* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetGyroData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::DoubleVals* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ResetGyroSensor(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResetGyroSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResetGyroSensor(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ResetGyroSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UseGyroForOdom(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UseGyroForOdom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UseGyroForOdom(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UseGyroForOdom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetGyroFullData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::IMUData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGyroFullData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::IMUData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGyroFullData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::IMUData* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetGyroFullData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::IMUData* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // IR sensor
      virtual void GetIRSensorData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::IRData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIRSensorData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::IRData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIRSensorData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::IRData* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetIRSensorData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::IRData* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // BMS data
      virtual void GetBMSData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::BMSData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBMSData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::BMSData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBMSData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::BMSData* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetBMSData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::BMSData* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Moby motion command
      virtual void SetStepControl(::grpc::ClientContext* context, const ::GRPCMoby::TargetVel* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetStepControl(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetStepControl(::grpc::ClientContext* context, const ::GRPCMoby::TargetVel* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetStepControl(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StopMotion(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopMotion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopMotion(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StopMotion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRotationAngleDeg(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetRotationAngleDeg(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DriveWheel(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DriveWheel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DriveWheel(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DriveWheel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Set Moby parameters
      virtual void SetZeroPosAsCurrentPos(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetZeroPosAsCurrentPos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetZeroPosAsCurrentPos(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetZeroPosAsCurrentPos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetRotationVelAcc(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRotationVelAcc(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRotationVelAcc(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetRotationVelAcc(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetDriveAccDec(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDriveAccDec(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDriveAccDec(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetDriveAccDec(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetDriveInterpolatorOnOff(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDriveInterpolatorOnOff(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDriveInterpolatorOnOff(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetDriveInterpolatorOnOff(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetRotationInterpolatorParam(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRotationInterpolatorParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRotationInterpolatorParam(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetRotationInterpolatorParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Gain setting
      virtual void SetRotationTorqueMode(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRotationTorqueMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRotationTorqueMode(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetRotationTorqueMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetControlParam(::grpc::ClientContext* context, const ::GRPCMoby::RotationGain* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetControlParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetControlParam(::grpc::ClientContext* context, const ::GRPCMoby::RotationGain* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetControlParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Data logging
      virtual void StartRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartRTLogging(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StartRTLogging(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void EndRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EndRTLogging(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EndRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void EndRTLogging(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetLoggerBuffer(::grpc::ClientContext* context, const ::GRPCMoby::IntVals* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetLoggerBuffer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetLoggerBuffer(::grpc::ClientContext* context, const ::GRPCMoby::IntVals* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetLoggerBuffer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RTLoggerSave(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RTLoggerSave(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RTLoggerSave(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RTLoggerSave(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MotorDriverTx>* AsyncGetMobyTxDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MotorDriverTx>* PrepareAsyncGetMobyTxDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MotorDriverRx>* AsyncGetMobyRxDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MotorDriverRx>* PrepareAsyncGetMobyRxDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyState>* AsyncGetMobyStateRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyState>* PrepareAsyncGetMobyStateRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyErrorState>* AsyncGetMobyErrorStateRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyErrorState>* PrepareAsyncGetMobyErrorStateRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncRecoverRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncRecoverRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyPose>* AsyncGetMobyPoseRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyPose>* PrepareAsyncGetMobyPoseRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyVel>* AsyncGetMobyVelRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::MobyVel>* PrepareAsyncGetMobyVelRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncResetMobyPoseRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncResetMobyPoseRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::SwerveDoubles>* AsyncGetRotationAngleDegRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::SwerveDoubles>* PrepareAsyncGetRotationAngleDegRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::SwerveDoubles>* AsyncGetDriveSpeedRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::SwerveDoubles>* PrepareAsyncGetDriveSpeedRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::TargetVel>* AsyncGetTargetVelRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::TargetVel>* PrepareAsyncGetTargetVelRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::ZeroCount>* AsyncGetRotationZeroCountRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::ZeroCount>* PrepareAsyncGetRotationZeroCountRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IntVal>* AsyncGetCModeRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IntVal>* PrepareAsyncGetCModeRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::DoubleVals>* AsyncGetGyroDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::DoubleVals>* PrepareAsyncGetGyroDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncResetGyroSensorRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncResetGyroSensorRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncUseGyroForOdomRaw(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncUseGyroForOdomRaw(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IMUData>* AsyncGetGyroFullDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IMUData>* PrepareAsyncGetGyroFullDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IRData>* AsyncGetIRSensorDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::IRData>* PrepareAsyncGetIRSensorDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::BMSData>* AsyncGetBMSDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::BMSData>* PrepareAsyncGetBMSDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncSetStepControlRaw(::grpc::ClientContext* context, const ::GRPCMoby::TargetVel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncSetStepControlRaw(::grpc::ClientContext* context, const ::GRPCMoby::TargetVel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncStopMotionRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncStopMotionRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncSetRotationAngleDegRaw(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncSetRotationAngleDegRaw(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncDriveWheelRaw(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncDriveWheelRaw(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncSetZeroPosAsCurrentPosRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncSetZeroPosAsCurrentPosRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncSetRotationVelAccRaw(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncSetRotationVelAccRaw(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncSetDriveAccDecRaw(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncSetDriveAccDecRaw(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncSetDriveInterpolatorOnOffRaw(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncSetDriveInterpolatorOnOffRaw(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncSetRotationInterpolatorParamRaw(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncSetRotationInterpolatorParamRaw(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncSetRotationTorqueModeRaw(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncSetRotationTorqueModeRaw(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncSetControlParamRaw(::grpc::ClientContext* context, const ::GRPCMoby::RotationGain& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncSetControlParamRaw(::grpc::ClientContext* context, const ::GRPCMoby::RotationGain& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncStartRTLoggingRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncStartRTLoggingRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncEndRTLoggingRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncEndRTLoggingRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncSetLoggerBufferRaw(::grpc::ClientContext* context, const ::GRPCMoby::IntVals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncSetLoggerBufferRaw(::grpc::ClientContext* context, const ::GRPCMoby::IntVals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* AsyncRTLoggerSaveRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GRPCMoby::Empty>* PrepareAsyncRTLoggerSaveRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetMobyTxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::GRPCMoby::MotorDriverTx* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MotorDriverTx>> AsyncGetMobyTxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MotorDriverTx>>(AsyncGetMobyTxDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MotorDriverTx>> PrepareAsyncGetMobyTxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MotorDriverTx>>(PrepareAsyncGetMobyTxDataRaw(context, request, cq));
    }
    ::grpc::Status GetMobyRxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::GRPCMoby::MotorDriverRx* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MotorDriverRx>> AsyncGetMobyRxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MotorDriverRx>>(AsyncGetMobyRxDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MotorDriverRx>> PrepareAsyncGetMobyRxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MotorDriverRx>>(PrepareAsyncGetMobyRxDataRaw(context, request, cq));
    }
    ::grpc::Status GetMobyState(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::MobyState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyState>> AsyncGetMobyState(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyState>>(AsyncGetMobyStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyState>> PrepareAsyncGetMobyState(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyState>>(PrepareAsyncGetMobyStateRaw(context, request, cq));
    }
    ::grpc::Status GetMobyErrorState(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::MobyErrorState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyErrorState>> AsyncGetMobyErrorState(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyErrorState>>(AsyncGetMobyErrorStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyErrorState>> PrepareAsyncGetMobyErrorState(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyErrorState>>(PrepareAsyncGetMobyErrorStateRaw(context, request, cq));
    }
    ::grpc::Status Recover(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncRecover(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncRecoverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncRecover(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncRecoverRaw(context, request, cq));
    }
    ::grpc::Status GetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::MobyPose* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyPose>> AsyncGetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyPose>>(AsyncGetMobyPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyPose>> PrepareAsyncGetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyPose>>(PrepareAsyncGetMobyPoseRaw(context, request, cq));
    }
    ::grpc::Status GetMobyVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::MobyVel* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyVel>> AsyncGetMobyVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyVel>>(AsyncGetMobyVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyVel>> PrepareAsyncGetMobyVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyVel>>(PrepareAsyncGetMobyVelRaw(context, request, cq));
    }
    ::grpc::Status ResetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncResetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncResetMobyPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncResetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncResetMobyPoseRaw(context, request, cq));
    }
    ::grpc::Status GetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::SwerveDoubles* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::SwerveDoubles>> AsyncGetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::SwerveDoubles>>(AsyncGetRotationAngleDegRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::SwerveDoubles>> PrepareAsyncGetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::SwerveDoubles>>(PrepareAsyncGetRotationAngleDegRaw(context, request, cq));
    }
    ::grpc::Status GetDriveSpeed(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::SwerveDoubles* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::SwerveDoubles>> AsyncGetDriveSpeed(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::SwerveDoubles>>(AsyncGetDriveSpeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::SwerveDoubles>> PrepareAsyncGetDriveSpeed(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::SwerveDoubles>>(PrepareAsyncGetDriveSpeedRaw(context, request, cq));
    }
    ::grpc::Status GetTargetVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::TargetVel* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::TargetVel>> AsyncGetTargetVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::TargetVel>>(AsyncGetTargetVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::TargetVel>> PrepareAsyncGetTargetVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::TargetVel>>(PrepareAsyncGetTargetVelRaw(context, request, cq));
    }
    ::grpc::Status GetRotationZeroCount(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::ZeroCount* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::ZeroCount>> AsyncGetRotationZeroCount(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::ZeroCount>>(AsyncGetRotationZeroCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::ZeroCount>> PrepareAsyncGetRotationZeroCount(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::ZeroCount>>(PrepareAsyncGetRotationZeroCountRaw(context, request, cq));
    }
    ::grpc::Status GetCMode(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::IntVal* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IntVal>> AsyncGetCMode(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IntVal>>(AsyncGetCModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IntVal>> PrepareAsyncGetCMode(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IntVal>>(PrepareAsyncGetCModeRaw(context, request, cq));
    }
    ::grpc::Status GetGyroData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::DoubleVals* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::DoubleVals>> AsyncGetGyroData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::DoubleVals>>(AsyncGetGyroDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::DoubleVals>> PrepareAsyncGetGyroData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::DoubleVals>>(PrepareAsyncGetGyroDataRaw(context, request, cq));
    }
    ::grpc::Status ResetGyroSensor(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncResetGyroSensor(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncResetGyroSensorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncResetGyroSensor(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncResetGyroSensorRaw(context, request, cq));
    }
    ::grpc::Status UseGyroForOdom(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncUseGyroForOdom(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncUseGyroForOdomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncUseGyroForOdom(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncUseGyroForOdomRaw(context, request, cq));
    }
    ::grpc::Status GetGyroFullData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::IMUData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IMUData>> AsyncGetGyroFullData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IMUData>>(AsyncGetGyroFullDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IMUData>> PrepareAsyncGetGyroFullData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IMUData>>(PrepareAsyncGetGyroFullDataRaw(context, request, cq));
    }
    ::grpc::Status GetIRSensorData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::IRData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IRData>> AsyncGetIRSensorData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IRData>>(AsyncGetIRSensorDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IRData>> PrepareAsyncGetIRSensorData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IRData>>(PrepareAsyncGetIRSensorDataRaw(context, request, cq));
    }
    ::grpc::Status GetBMSData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::BMSData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::BMSData>> AsyncGetBMSData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::BMSData>>(AsyncGetBMSDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::BMSData>> PrepareAsyncGetBMSData(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::BMSData>>(PrepareAsyncGetBMSDataRaw(context, request, cq));
    }
    ::grpc::Status SetStepControl(::grpc::ClientContext* context, const ::GRPCMoby::TargetVel& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncSetStepControl(::grpc::ClientContext* context, const ::GRPCMoby::TargetVel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncSetStepControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncSetStepControl(::grpc::ClientContext* context, const ::GRPCMoby::TargetVel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncSetStepControlRaw(context, request, cq));
    }
    ::grpc::Status StopMotion(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncStopMotion(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncStopMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncStopMotion(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncStopMotionRaw(context, request, cq));
    }
    ::grpc::Status SetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncSetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncSetRotationAngleDegRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncSetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncSetRotationAngleDegRaw(context, request, cq));
    }
    ::grpc::Status DriveWheel(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncDriveWheel(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncDriveWheelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncDriveWheel(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncDriveWheelRaw(context, request, cq));
    }
    ::grpc::Status SetZeroPosAsCurrentPos(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncSetZeroPosAsCurrentPos(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncSetZeroPosAsCurrentPosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncSetZeroPosAsCurrentPos(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncSetZeroPosAsCurrentPosRaw(context, request, cq));
    }
    ::grpc::Status SetRotationVelAcc(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncSetRotationVelAcc(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncSetRotationVelAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncSetRotationVelAcc(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncSetRotationVelAccRaw(context, request, cq));
    }
    ::grpc::Status SetDriveAccDec(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncSetDriveAccDec(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncSetDriveAccDecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncSetDriveAccDec(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncSetDriveAccDecRaw(context, request, cq));
    }
    ::grpc::Status SetDriveInterpolatorOnOff(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncSetDriveInterpolatorOnOff(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncSetDriveInterpolatorOnOffRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncSetDriveInterpolatorOnOff(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncSetDriveInterpolatorOnOffRaw(context, request, cq));
    }
    ::grpc::Status SetRotationInterpolatorParam(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncSetRotationInterpolatorParam(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncSetRotationInterpolatorParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncSetRotationInterpolatorParam(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncSetRotationInterpolatorParamRaw(context, request, cq));
    }
    ::grpc::Status SetRotationTorqueMode(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncSetRotationTorqueMode(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncSetRotationTorqueModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncSetRotationTorqueMode(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncSetRotationTorqueModeRaw(context, request, cq));
    }
    ::grpc::Status SetControlParam(::grpc::ClientContext* context, const ::GRPCMoby::RotationGain& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncSetControlParam(::grpc::ClientContext* context, const ::GRPCMoby::RotationGain& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncSetControlParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncSetControlParam(::grpc::ClientContext* context, const ::GRPCMoby::RotationGain& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncSetControlParamRaw(context, request, cq));
    }
    ::grpc::Status StartRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncStartRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncStartRTLoggingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncStartRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncStartRTLoggingRaw(context, request, cq));
    }
    ::grpc::Status EndRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncEndRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncEndRTLoggingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncEndRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncEndRTLoggingRaw(context, request, cq));
    }
    ::grpc::Status SetLoggerBuffer(::grpc::ClientContext* context, const ::GRPCMoby::IntVals& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncSetLoggerBuffer(::grpc::ClientContext* context, const ::GRPCMoby::IntVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncSetLoggerBufferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncSetLoggerBuffer(::grpc::ClientContext* context, const ::GRPCMoby::IntVals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncSetLoggerBufferRaw(context, request, cq));
    }
    ::grpc::Status RTLoggerSave(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::GRPCMoby::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> AsyncRTLoggerSave(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(AsyncRTLoggerSaveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>> PrepareAsyncRTLoggerSave(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>>(PrepareAsyncRTLoggerSaveRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetMobyTxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal* request, ::GRPCMoby::MotorDriverTx* response, std::function<void(::grpc::Status)>) override;
      void GetMobyTxData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MotorDriverTx* response, std::function<void(::grpc::Status)>) override;
      void GetMobyTxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal* request, ::GRPCMoby::MotorDriverTx* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMobyTxData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MotorDriverTx* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMobyRxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal* request, ::GRPCMoby::MotorDriverRx* response, std::function<void(::grpc::Status)>) override;
      void GetMobyRxData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MotorDriverRx* response, std::function<void(::grpc::Status)>) override;
      void GetMobyRxData(::grpc::ClientContext* context, const ::GRPCMoby::IntVal* request, ::GRPCMoby::MotorDriverRx* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMobyRxData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MotorDriverRx* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMobyState(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyState* response, std::function<void(::grpc::Status)>) override;
      void GetMobyState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyState* response, std::function<void(::grpc::Status)>) override;
      void GetMobyState(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMobyState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMobyErrorState(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyErrorState* response, std::function<void(::grpc::Status)>) override;
      void GetMobyErrorState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyErrorState* response, std::function<void(::grpc::Status)>) override;
      void GetMobyErrorState(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyErrorState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMobyErrorState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyErrorState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Recover(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void Recover(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void Recover(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Recover(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyPose* response, std::function<void(::grpc::Status)>) override;
      void GetMobyPose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyPose* response, std::function<void(::grpc::Status)>) override;
      void GetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyPose* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMobyPose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyPose* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMobyVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyVel* response, std::function<void(::grpc::Status)>) override;
      void GetMobyVel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyVel* response, std::function<void(::grpc::Status)>) override;
      void GetMobyVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyVel* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMobyVel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::MobyVel* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ResetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void ResetMobyPose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void ResetMobyPose(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ResetMobyPose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::SwerveDoubles* response, std::function<void(::grpc::Status)>) override;
      void GetRotationAngleDeg(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::SwerveDoubles* response, std::function<void(::grpc::Status)>) override;
      void GetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::SwerveDoubles* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetRotationAngleDeg(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::SwerveDoubles* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetDriveSpeed(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::SwerveDoubles* response, std::function<void(::grpc::Status)>) override;
      void GetDriveSpeed(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::SwerveDoubles* response, std::function<void(::grpc::Status)>) override;
      void GetDriveSpeed(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::SwerveDoubles* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetDriveSpeed(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::SwerveDoubles* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetTargetVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::TargetVel* response, std::function<void(::grpc::Status)>) override;
      void GetTargetVel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::TargetVel* response, std::function<void(::grpc::Status)>) override;
      void GetTargetVel(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::TargetVel* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetTargetVel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::TargetVel* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetRotationZeroCount(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::ZeroCount* response, std::function<void(::grpc::Status)>) override;
      void GetRotationZeroCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::ZeroCount* response, std::function<void(::grpc::Status)>) override;
      void GetRotationZeroCount(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::ZeroCount* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetRotationZeroCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::ZeroCount* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCMode(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::IntVal* response, std::function<void(::grpc::Status)>) override;
      void GetCMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::IntVal* response, std::function<void(::grpc::Status)>) override;
      void GetCMode(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::IntVal* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetCMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::IntVal* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetGyroData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::DoubleVals* response, std::function<void(::grpc::Status)>) override;
      void GetGyroData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::DoubleVals* response, std::function<void(::grpc::Status)>) override;
      void GetGyroData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::DoubleVals* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetGyroData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::DoubleVals* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ResetGyroSensor(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void ResetGyroSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void ResetGyroSensor(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ResetGyroSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UseGyroForOdom(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void UseGyroForOdom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void UseGyroForOdom(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UseGyroForOdom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetGyroFullData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::IMUData* response, std::function<void(::grpc::Status)>) override;
      void GetGyroFullData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::IMUData* response, std::function<void(::grpc::Status)>) override;
      void GetGyroFullData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::IMUData* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetGyroFullData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::IMUData* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetIRSensorData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::IRData* response, std::function<void(::grpc::Status)>) override;
      void GetIRSensorData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::IRData* response, std::function<void(::grpc::Status)>) override;
      void GetIRSensorData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::IRData* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetIRSensorData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::IRData* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetBMSData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::BMSData* response, std::function<void(::grpc::Status)>) override;
      void GetBMSData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::BMSData* response, std::function<void(::grpc::Status)>) override;
      void GetBMSData(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::BMSData* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetBMSData(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::BMSData* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetStepControl(::grpc::ClientContext* context, const ::GRPCMoby::TargetVel* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetStepControl(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetStepControl(::grpc::ClientContext* context, const ::GRPCMoby::TargetVel* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetStepControl(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StopMotion(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void StopMotion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void StopMotion(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StopMotion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetRotationAngleDeg(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetRotationAngleDeg(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRotationAngleDeg(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DriveWheel(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void DriveWheel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void DriveWheel(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DriveWheel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetZeroPosAsCurrentPos(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetZeroPosAsCurrentPos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetZeroPosAsCurrentPos(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetZeroPosAsCurrentPos(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRotationVelAcc(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetRotationVelAcc(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetRotationVelAcc(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRotationVelAcc(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetDriveAccDec(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetDriveAccDec(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetDriveAccDec(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetDriveAccDec(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetDriveInterpolatorOnOff(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetDriveInterpolatorOnOff(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetDriveInterpolatorOnOff(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetDriveInterpolatorOnOff(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRotationInterpolatorParam(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetRotationInterpolatorParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetRotationInterpolatorParam(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRotationInterpolatorParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRotationTorqueMode(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetRotationTorqueMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetRotationTorqueMode(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetRotationTorqueMode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetControlParam(::grpc::ClientContext* context, const ::GRPCMoby::RotationGain* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetControlParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetControlParam(::grpc::ClientContext* context, const ::GRPCMoby::RotationGain* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetControlParam(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StartRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void StartRTLogging(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void StartRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StartRTLogging(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void EndRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void EndRTLogging(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void EndRTLogging(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void EndRTLogging(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetLoggerBuffer(::grpc::ClientContext* context, const ::GRPCMoby::IntVals* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetLoggerBuffer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetLoggerBuffer(::grpc::ClientContext* context, const ::GRPCMoby::IntVals* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetLoggerBuffer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RTLoggerSave(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void RTLoggerSave(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, std::function<void(::grpc::Status)>) override;
      void RTLoggerSave(::grpc::ClientContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RTLoggerSave(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::GRPCMoby::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MotorDriverTx>* AsyncGetMobyTxDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MotorDriverTx>* PrepareAsyncGetMobyTxDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MotorDriverRx>* AsyncGetMobyRxDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MotorDriverRx>* PrepareAsyncGetMobyRxDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::IntVal& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyState>* AsyncGetMobyStateRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyState>* PrepareAsyncGetMobyStateRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyErrorState>* AsyncGetMobyErrorStateRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyErrorState>* PrepareAsyncGetMobyErrorStateRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncRecoverRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncRecoverRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyPose>* AsyncGetMobyPoseRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyPose>* PrepareAsyncGetMobyPoseRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyVel>* AsyncGetMobyVelRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::MobyVel>* PrepareAsyncGetMobyVelRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncResetMobyPoseRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncResetMobyPoseRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::SwerveDoubles>* AsyncGetRotationAngleDegRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::SwerveDoubles>* PrepareAsyncGetRotationAngleDegRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::SwerveDoubles>* AsyncGetDriveSpeedRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::SwerveDoubles>* PrepareAsyncGetDriveSpeedRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::TargetVel>* AsyncGetTargetVelRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::TargetVel>* PrepareAsyncGetTargetVelRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::ZeroCount>* AsyncGetRotationZeroCountRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::ZeroCount>* PrepareAsyncGetRotationZeroCountRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IntVal>* AsyncGetCModeRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IntVal>* PrepareAsyncGetCModeRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::DoubleVals>* AsyncGetGyroDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::DoubleVals>* PrepareAsyncGetGyroDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncResetGyroSensorRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncResetGyroSensorRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncUseGyroForOdomRaw(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncUseGyroForOdomRaw(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IMUData>* AsyncGetGyroFullDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IMUData>* PrepareAsyncGetGyroFullDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IRData>* AsyncGetIRSensorDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::IRData>* PrepareAsyncGetIRSensorDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::BMSData>* AsyncGetBMSDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::BMSData>* PrepareAsyncGetBMSDataRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncSetStepControlRaw(::grpc::ClientContext* context, const ::GRPCMoby::TargetVel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncSetStepControlRaw(::grpc::ClientContext* context, const ::GRPCMoby::TargetVel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncStopMotionRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncStopMotionRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncSetRotationAngleDegRaw(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncSetRotationAngleDegRaw(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncDriveWheelRaw(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncDriveWheelRaw(::grpc::ClientContext* context, const ::GRPCMoby::SwerveDoubles& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncSetZeroPosAsCurrentPosRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncSetZeroPosAsCurrentPosRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncSetRotationVelAccRaw(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncSetRotationVelAccRaw(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncSetDriveAccDecRaw(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncSetDriveAccDecRaw(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncSetDriveInterpolatorOnOffRaw(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncSetDriveInterpolatorOnOffRaw(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncSetRotationInterpolatorParamRaw(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncSetRotationInterpolatorParamRaw(::grpc::ClientContext* context, const ::GRPCMoby::DoubleVals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncSetRotationTorqueModeRaw(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncSetRotationTorqueModeRaw(::grpc::ClientContext* context, const ::GRPCMoby::BoolVal& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncSetControlParamRaw(::grpc::ClientContext* context, const ::GRPCMoby::RotationGain& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncSetControlParamRaw(::grpc::ClientContext* context, const ::GRPCMoby::RotationGain& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncStartRTLoggingRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncStartRTLoggingRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncEndRTLoggingRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncEndRTLoggingRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncSetLoggerBufferRaw(::grpc::ClientContext* context, const ::GRPCMoby::IntVals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncSetLoggerBufferRaw(::grpc::ClientContext* context, const ::GRPCMoby::IntVals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* AsyncRTLoggerSaveRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GRPCMoby::Empty>* PrepareAsyncRTLoggerSaveRaw(::grpc::ClientContext* context, const ::GRPCMoby::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetMobyTxData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMobyRxData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMobyState_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMobyErrorState_;
    const ::grpc::internal::RpcMethod rpcmethod_Recover_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMobyPose_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMobyVel_;
    const ::grpc::internal::RpcMethod rpcmethod_ResetMobyPose_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRotationAngleDeg_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDriveSpeed_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTargetVel_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRotationZeroCount_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCMode_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGyroData_;
    const ::grpc::internal::RpcMethod rpcmethod_ResetGyroSensor_;
    const ::grpc::internal::RpcMethod rpcmethod_UseGyroForOdom_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGyroFullData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetIRSensorData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBMSData_;
    const ::grpc::internal::RpcMethod rpcmethod_SetStepControl_;
    const ::grpc::internal::RpcMethod rpcmethod_StopMotion_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRotationAngleDeg_;
    const ::grpc::internal::RpcMethod rpcmethod_DriveWheel_;
    const ::grpc::internal::RpcMethod rpcmethod_SetZeroPosAsCurrentPos_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRotationVelAcc_;
    const ::grpc::internal::RpcMethod rpcmethod_SetDriveAccDec_;
    const ::grpc::internal::RpcMethod rpcmethod_SetDriveInterpolatorOnOff_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRotationInterpolatorParam_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRotationTorqueMode_;
    const ::grpc::internal::RpcMethod rpcmethod_SetControlParam_;
    const ::grpc::internal::RpcMethod rpcmethod_StartRTLogging_;
    const ::grpc::internal::RpcMethod rpcmethod_EndRTLogging_;
    const ::grpc::internal::RpcMethod rpcmethod_SetLoggerBuffer_;
    const ::grpc::internal::RpcMethod rpcmethod_RTLoggerSave_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    //  Moby EtherCAT TxPDO and RxPDO data processing
    virtual ::grpc::Status GetMobyTxData(::grpc::ServerContext* context, const ::GRPCMoby::IntVal* request, ::GRPCMoby::MotorDriverTx* response);
    virtual ::grpc::Status GetMobyRxData(::grpc::ServerContext* context, const ::GRPCMoby::IntVal* request, ::GRPCMoby::MotorDriverRx* response);
    // Get Moby state
    virtual ::grpc::Status GetMobyState(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyState* response);
    virtual ::grpc::Status GetMobyErrorState(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyErrorState* response);
    virtual ::grpc::Status Recover(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response);
    // Get Moby's odometry and physical data
    virtual ::grpc::Status GetMobyPose(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyPose* response);
    virtual ::grpc::Status GetMobyVel(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::MobyVel* response);
    virtual ::grpc::Status ResetMobyPose(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response);
    virtual ::grpc::Status GetRotationAngleDeg(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::SwerveDoubles* response);
    virtual ::grpc::Status GetDriveSpeed(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::SwerveDoubles* response);
    virtual ::grpc::Status GetTargetVel(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::TargetVel* response);
    virtual ::grpc::Status GetRotationZeroCount(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::ZeroCount* response);
    virtual ::grpc::Status GetCMode(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::IntVal* response);
    // Gyro value related
    virtual ::grpc::Status GetGyroData(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::DoubleVals* response);
    virtual ::grpc::Status ResetGyroSensor(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response);
    virtual ::grpc::Status UseGyroForOdom(::grpc::ServerContext* context, const ::GRPCMoby::BoolVal* request, ::GRPCMoby::Empty* response);
    virtual ::grpc::Status GetGyroFullData(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::IMUData* response);
    // IR sensor
    virtual ::grpc::Status GetIRSensorData(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::IRData* response);
    // BMS data
    virtual ::grpc::Status GetBMSData(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::BMSData* response);
    // Moby motion command
    virtual ::grpc::Status SetStepControl(::grpc::ServerContext* context, const ::GRPCMoby::TargetVel* request, ::GRPCMoby::Empty* response);
    virtual ::grpc::Status StopMotion(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response);
    virtual ::grpc::Status SetRotationAngleDeg(::grpc::ServerContext* context, const ::GRPCMoby::SwerveDoubles* request, ::GRPCMoby::Empty* response);
    virtual ::grpc::Status DriveWheel(::grpc::ServerContext* context, const ::GRPCMoby::SwerveDoubles* request, ::GRPCMoby::Empty* response);
    // Set Moby parameters
    virtual ::grpc::Status SetZeroPosAsCurrentPos(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response);
    virtual ::grpc::Status SetRotationVelAcc(::grpc::ServerContext* context, const ::GRPCMoby::DoubleVals* request, ::GRPCMoby::Empty* response);
    virtual ::grpc::Status SetDriveAccDec(::grpc::ServerContext* context, const ::GRPCMoby::DoubleVals* request, ::GRPCMoby::Empty* response);
    virtual ::grpc::Status SetDriveInterpolatorOnOff(::grpc::ServerContext* context, const ::GRPCMoby::BoolVal* request, ::GRPCMoby::Empty* response);
    virtual ::grpc::Status SetRotationInterpolatorParam(::grpc::ServerContext* context, const ::GRPCMoby::DoubleVals* request, ::GRPCMoby::Empty* response);
    // Gain setting
    virtual ::grpc::Status SetRotationTorqueMode(::grpc::ServerContext* context, const ::GRPCMoby::BoolVal* request, ::GRPCMoby::Empty* response);
    virtual ::grpc::Status SetControlParam(::grpc::ServerContext* context, const ::GRPCMoby::RotationGain* request, ::GRPCMoby::Empty* response);
    // Data logging
    virtual ::grpc::Status StartRTLogging(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response);
    virtual ::grpc::Status EndRTLogging(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response);
    virtual ::grpc::Status SetLoggerBuffer(::grpc::ServerContext* context, const ::GRPCMoby::IntVals* request, ::GRPCMoby::Empty* response);
    virtual ::grpc::Status RTLoggerSave(::grpc::ServerContext* context, const ::GRPCMoby::Empty* request, ::GRPCMoby::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMobyTxData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMobyTxData() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetMobyTxData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyTxData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVal* /*request*/, ::GRPCMoby::MotorDriverTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMobyTxData(::grpc::ServerContext* context, ::GRPCMoby::IntVal* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::MotorDriverTx>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMobyRxData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMobyRxData() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetMobyRxData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyRxData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVal* /*request*/, ::GRPCMoby::MotorDriverRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMobyRxData(::grpc::ServerContext* context, ::GRPCMoby::IntVal* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::MotorDriverRx>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMobyState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMobyState() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetMobyState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyState(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMobyState(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::MobyState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMobyErrorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMobyErrorState() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetMobyErrorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyErrorState(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyErrorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMobyErrorState(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::MobyErrorState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Recover() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecover(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMobyPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMobyPose() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetMobyPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyPose(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyPose* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMobyPose(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::MobyPose>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMobyVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMobyVel() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetMobyVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyVel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyVel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMobyVel(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::MobyVel>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetMobyPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResetMobyPose() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_ResetMobyPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetMobyPose(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetMobyPose(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRotationAngleDeg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRotationAngleDeg() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_GetRotationAngleDeg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::SwerveDoubles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRotationAngleDeg(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::SwerveDoubles>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDriveSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDriveSpeed() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetDriveSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDriveSpeed(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::SwerveDoubles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDriveSpeed(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::SwerveDoubles>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTargetVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTargetVel() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetTargetVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTargetVel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::TargetVel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTargetVel(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::TargetVel>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRotationZeroCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRotationZeroCount() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetRotationZeroCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRotationZeroCount(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::ZeroCount* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRotationZeroCount(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::ZeroCount>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCMode() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetCMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCMode(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCMode(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::IntVal>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGyroData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGyroData() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_GetGyroData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGyroData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::DoubleVals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGyroData(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::DoubleVals>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetGyroSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResetGyroSensor() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_ResetGyroSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetGyroSensor(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetGyroSensor(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UseGyroForOdom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UseGyroForOdom() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_UseGyroForOdom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UseGyroForOdom(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUseGyroForOdom(::grpc::ServerContext* context, ::GRPCMoby::BoolVal* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGyroFullData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGyroFullData() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_GetGyroFullData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGyroFullData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IMUData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGyroFullData(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::IMUData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetIRSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetIRSensorData() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_GetIRSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIRSensorData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IRData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIRSensorData(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::IRData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBMSData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBMSData() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_GetBMSData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBMSData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::BMSData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBMSData(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::BMSData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetStepControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetStepControl() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_SetStepControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStepControl(::grpc::ServerContext* /*context*/, const ::GRPCMoby::TargetVel* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetStepControl(::grpc::ServerContext* context, ::GRPCMoby::TargetVel* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopMotion() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopMotion(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRotationAngleDeg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetRotationAngleDeg() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_SetRotationAngleDeg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::GRPCMoby::SwerveDoubles* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRotationAngleDeg(::grpc::ServerContext* context, ::GRPCMoby::SwerveDoubles* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DriveWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DriveWheel() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_DriveWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DriveWheel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::SwerveDoubles* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDriveWheel(::grpc::ServerContext* context, ::GRPCMoby::SwerveDoubles* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetZeroPosAsCurrentPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetZeroPosAsCurrentPos() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_SetZeroPosAsCurrentPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetZeroPosAsCurrentPos(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetZeroPosAsCurrentPos(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRotationVelAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetRotationVelAcc() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_SetRotationVelAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationVelAcc(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRotationVelAcc(::grpc::ServerContext* context, ::GRPCMoby::DoubleVals* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetDriveAccDec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetDriveAccDec() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_SetDriveAccDec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDriveAccDec(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDriveAccDec(::grpc::ServerContext* context, ::GRPCMoby::DoubleVals* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetDriveInterpolatorOnOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetDriveInterpolatorOnOff() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_SetDriveInterpolatorOnOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDriveInterpolatorOnOff(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDriveInterpolatorOnOff(::grpc::ServerContext* context, ::GRPCMoby::BoolVal* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRotationInterpolatorParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetRotationInterpolatorParam() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_SetRotationInterpolatorParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationInterpolatorParam(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRotationInterpolatorParam(::grpc::ServerContext* context, ::GRPCMoby::DoubleVals* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRotationTorqueMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetRotationTorqueMode() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_SetRotationTorqueMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationTorqueMode(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRotationTorqueMode(::grpc::ServerContext* context, ::GRPCMoby::BoolVal* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetControlParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetControlParam() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_SetControlParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetControlParam(::grpc::ServerContext* /*context*/, const ::GRPCMoby::RotationGain* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetControlParam(::grpc::ServerContext* context, ::GRPCMoby::RotationGain* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartRTLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartRTLogging() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_StartRTLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRTLogging(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRTLogging(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EndRTLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EndRTLogging() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_EndRTLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EndRTLogging(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEndRTLogging(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetLoggerBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetLoggerBuffer() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_SetLoggerBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLoggerBuffer(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetLoggerBuffer(::grpc::ServerContext* context, ::GRPCMoby::IntVals* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RTLoggerSave : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RTLoggerSave() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_RTLoggerSave() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RTLoggerSave(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRTLoggerSave(::grpc::ServerContext* context, ::GRPCMoby::Empty* request, ::grpc::ServerAsyncResponseWriter< ::GRPCMoby::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetMobyTxData<WithAsyncMethod_GetMobyRxData<WithAsyncMethod_GetMobyState<WithAsyncMethod_GetMobyErrorState<WithAsyncMethod_Recover<WithAsyncMethod_GetMobyPose<WithAsyncMethod_GetMobyVel<WithAsyncMethod_ResetMobyPose<WithAsyncMethod_GetRotationAngleDeg<WithAsyncMethod_GetDriveSpeed<WithAsyncMethod_GetTargetVel<WithAsyncMethod_GetRotationZeroCount<WithAsyncMethod_GetCMode<WithAsyncMethod_GetGyroData<WithAsyncMethod_ResetGyroSensor<WithAsyncMethod_UseGyroForOdom<WithAsyncMethod_GetGyroFullData<WithAsyncMethod_GetIRSensorData<WithAsyncMethod_GetBMSData<WithAsyncMethod_SetStepControl<WithAsyncMethod_StopMotion<WithAsyncMethod_SetRotationAngleDeg<WithAsyncMethod_DriveWheel<WithAsyncMethod_SetZeroPosAsCurrentPos<WithAsyncMethod_SetRotationVelAcc<WithAsyncMethod_SetDriveAccDec<WithAsyncMethod_SetDriveInterpolatorOnOff<WithAsyncMethod_SetRotationInterpolatorParam<WithAsyncMethod_SetRotationTorqueMode<WithAsyncMethod_SetControlParam<WithAsyncMethod_StartRTLogging<WithAsyncMethod_EndRTLogging<WithAsyncMethod_SetLoggerBuffer<WithAsyncMethod_RTLoggerSave<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetMobyTxData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetMobyTxData() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::IntVal, ::GRPCMoby::MotorDriverTx>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::IntVal* request,
                 ::GRPCMoby::MotorDriverTx* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetMobyTxData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetMobyTxData(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::IntVal, ::GRPCMoby::MotorDriverTx>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::IntVal, ::GRPCMoby::MotorDriverTx>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetMobyTxData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyTxData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVal* /*request*/, ::GRPCMoby::MotorDriverTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMobyTxData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVal* /*request*/, ::GRPCMoby::MotorDriverTx* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetMobyRxData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetMobyRxData() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::IntVal, ::GRPCMoby::MotorDriverRx>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::IntVal* request,
                 ::GRPCMoby::MotorDriverRx* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetMobyRxData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetMobyRxData(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::IntVal, ::GRPCMoby::MotorDriverRx>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::IntVal, ::GRPCMoby::MotorDriverRx>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetMobyRxData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyRxData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVal* /*request*/, ::GRPCMoby::MotorDriverRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMobyRxData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVal* /*request*/, ::GRPCMoby::MotorDriverRx* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetMobyState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetMobyState() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::MobyState>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::MobyState* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetMobyState(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetMobyState(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::MobyState>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::MobyState>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetMobyState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyState(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMobyState(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyState* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetMobyErrorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetMobyErrorState() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::MobyErrorState>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::MobyErrorState* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetMobyErrorState(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetMobyErrorState(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::MobyErrorState>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::MobyErrorState>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetMobyErrorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyErrorState(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyErrorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMobyErrorState(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyErrorState* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Recover() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Recover(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Recover(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Recover(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetMobyPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetMobyPose() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::MobyPose>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::MobyPose* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetMobyPose(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetMobyPose(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::MobyPose>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::MobyPose>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetMobyPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyPose(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyPose* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMobyPose(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyPose* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetMobyVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetMobyVel() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::MobyVel>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::MobyVel* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetMobyVel(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetMobyVel(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::MobyVel>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::MobyVel>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetMobyVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyVel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyVel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMobyVel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyVel* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ResetMobyPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ResetMobyPose() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ResetMobyPose(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ResetMobyPose(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ResetMobyPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetMobyPose(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ResetMobyPose(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRotationAngleDeg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRotationAngleDeg() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::SwerveDoubles>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::SwerveDoubles* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetRotationAngleDeg(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetRotationAngleDeg(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::SwerveDoubles>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::SwerveDoubles>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRotationAngleDeg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::SwerveDoubles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::SwerveDoubles* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetDriveSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetDriveSpeed() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::SwerveDoubles>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::SwerveDoubles* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetDriveSpeed(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetDriveSpeed(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::SwerveDoubles>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::SwerveDoubles>*>(
          ::grpc::Service::experimental().GetHandler(9))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetDriveSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDriveSpeed(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::SwerveDoubles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetDriveSpeed(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::SwerveDoubles* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTargetVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetTargetVel() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::TargetVel>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::TargetVel* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetTargetVel(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetTargetVel(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::TargetVel>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::TargetVel>*>(
          ::grpc::Service::experimental().GetHandler(10))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTargetVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTargetVel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::TargetVel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetTargetVel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::TargetVel* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRotationZeroCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRotationZeroCount() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::ZeroCount>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::ZeroCount* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetRotationZeroCount(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetRotationZeroCount(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::ZeroCount>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::ZeroCount>*>(
          ::grpc::Service::experimental().GetHandler(11))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRotationZeroCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRotationZeroCount(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::ZeroCount* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRotationZeroCount(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::ZeroCount* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetCMode() {
      ::grpc::Service::experimental().MarkMethodCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::IntVal>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::IntVal* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetCMode(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetCMode(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::IntVal>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::IntVal>*>(
          ::grpc::Service::experimental().GetHandler(12))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetCMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCMode(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCMode(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IntVal* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetGyroData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetGyroData() {
      ::grpc::Service::experimental().MarkMethodCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::DoubleVals>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::DoubleVals* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetGyroData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetGyroData(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::DoubleVals>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::DoubleVals>*>(
          ::grpc::Service::experimental().GetHandler(13))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetGyroData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGyroData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::DoubleVals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetGyroData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::DoubleVals* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ResetGyroSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ResetGyroSensor() {
      ::grpc::Service::experimental().MarkMethodCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ResetGyroSensor(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ResetGyroSensor(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(14))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ResetGyroSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetGyroSensor(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ResetGyroSensor(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UseGyroForOdom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UseGyroForOdom() {
      ::grpc::Service::experimental().MarkMethodCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::BoolVal, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::BoolVal* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UseGyroForOdom(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UseGyroForOdom(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::BoolVal, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::BoolVal, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(15))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UseGyroForOdom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UseGyroForOdom(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UseGyroForOdom(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetGyroFullData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetGyroFullData() {
      ::grpc::Service::experimental().MarkMethodCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::IMUData>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::IMUData* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetGyroFullData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetGyroFullData(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::IMUData>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::IMUData>*>(
          ::grpc::Service::experimental().GetHandler(16))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetGyroFullData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGyroFullData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IMUData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetGyroFullData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IMUData* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetIRSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetIRSensorData() {
      ::grpc::Service::experimental().MarkMethodCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::IRData>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::IRData* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetIRSensorData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetIRSensorData(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::IRData>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::IRData>*>(
          ::grpc::Service::experimental().GetHandler(17))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetIRSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIRSensorData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IRData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetIRSensorData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IRData* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBMSData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetBMSData() {
      ::grpc::Service::experimental().MarkMethodCallback(18,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::BMSData>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::BMSData* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetBMSData(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetBMSData(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::BMSData>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::BMSData>*>(
          ::grpc::Service::experimental().GetHandler(18))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetBMSData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBMSData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::BMSData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetBMSData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::BMSData* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetStepControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetStepControl() {
      ::grpc::Service::experimental().MarkMethodCallback(19,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::TargetVel, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::TargetVel* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetStepControl(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetStepControl(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::TargetVel, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::TargetVel, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(19))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetStepControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStepControl(::grpc::ServerContext* /*context*/, const ::GRPCMoby::TargetVel* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetStepControl(::grpc::ServerContext* /*context*/, const ::GRPCMoby::TargetVel* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StopMotion() {
      ::grpc::Service::experimental().MarkMethodCallback(20,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StopMotion(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StopMotion(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(20))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopMotion(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetRotationAngleDeg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetRotationAngleDeg() {
      ::grpc::Service::experimental().MarkMethodCallback(21,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::SwerveDoubles, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::SwerveDoubles* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetRotationAngleDeg(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetRotationAngleDeg(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::SwerveDoubles, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::SwerveDoubles, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(21))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetRotationAngleDeg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::GRPCMoby::SwerveDoubles* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::GRPCMoby::SwerveDoubles* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DriveWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DriveWheel() {
      ::grpc::Service::experimental().MarkMethodCallback(22,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::SwerveDoubles, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::SwerveDoubles* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->DriveWheel(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_DriveWheel(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::SwerveDoubles, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::SwerveDoubles, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(22))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DriveWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DriveWheel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::SwerveDoubles* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DriveWheel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::SwerveDoubles* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetZeroPosAsCurrentPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetZeroPosAsCurrentPos() {
      ::grpc::Service::experimental().MarkMethodCallback(23,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetZeroPosAsCurrentPos(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetZeroPosAsCurrentPos(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(23))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetZeroPosAsCurrentPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetZeroPosAsCurrentPos(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetZeroPosAsCurrentPos(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetRotationVelAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetRotationVelAcc() {
      ::grpc::Service::experimental().MarkMethodCallback(24,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::DoubleVals, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::DoubleVals* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetRotationVelAcc(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetRotationVelAcc(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::DoubleVals, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::DoubleVals, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(24))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetRotationVelAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationVelAcc(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRotationVelAcc(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetDriveAccDec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetDriveAccDec() {
      ::grpc::Service::experimental().MarkMethodCallback(25,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::DoubleVals, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::DoubleVals* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetDriveAccDec(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetDriveAccDec(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::DoubleVals, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::DoubleVals, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(25))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetDriveAccDec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDriveAccDec(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetDriveAccDec(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetDriveInterpolatorOnOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetDriveInterpolatorOnOff() {
      ::grpc::Service::experimental().MarkMethodCallback(26,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::BoolVal, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::BoolVal* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetDriveInterpolatorOnOff(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetDriveInterpolatorOnOff(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::BoolVal, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::BoolVal, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(26))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetDriveInterpolatorOnOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDriveInterpolatorOnOff(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetDriveInterpolatorOnOff(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetRotationInterpolatorParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetRotationInterpolatorParam() {
      ::grpc::Service::experimental().MarkMethodCallback(27,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::DoubleVals, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::DoubleVals* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetRotationInterpolatorParam(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetRotationInterpolatorParam(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::DoubleVals, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::DoubleVals, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(27))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetRotationInterpolatorParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationInterpolatorParam(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRotationInterpolatorParam(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetRotationTorqueMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetRotationTorqueMode() {
      ::grpc::Service::experimental().MarkMethodCallback(28,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::BoolVal, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::BoolVal* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetRotationTorqueMode(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetRotationTorqueMode(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::BoolVal, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::BoolVal, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(28))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetRotationTorqueMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationTorqueMode(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRotationTorqueMode(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetControlParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetControlParam() {
      ::grpc::Service::experimental().MarkMethodCallback(29,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::RotationGain, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::RotationGain* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetControlParam(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetControlParam(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::RotationGain, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::RotationGain, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(29))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetControlParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetControlParam(::grpc::ServerContext* /*context*/, const ::GRPCMoby::RotationGain* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetControlParam(::grpc::ServerContext* /*context*/, const ::GRPCMoby::RotationGain* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartRTLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StartRTLogging() {
      ::grpc::Service::experimental().MarkMethodCallback(30,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StartRTLogging(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StartRTLogging(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(30))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StartRTLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRTLogging(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StartRTLogging(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EndRTLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EndRTLogging() {
      ::grpc::Service::experimental().MarkMethodCallback(31,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->EndRTLogging(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_EndRTLogging(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(31))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EndRTLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EndRTLogging(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void EndRTLogging(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetLoggerBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetLoggerBuffer() {
      ::grpc::Service::experimental().MarkMethodCallback(32,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::IntVals, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::IntVals* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetLoggerBuffer(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetLoggerBuffer(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::IntVals, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::IntVals, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(32))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetLoggerBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLoggerBuffer(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetLoggerBuffer(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVals* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RTLoggerSave : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RTLoggerSave() {
      ::grpc::Service::experimental().MarkMethodCallback(33,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::GRPCMoby::Empty* request,
                 ::GRPCMoby::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->RTLoggerSave(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_RTLoggerSave(
        ::grpc::experimental::MessageAllocator< ::GRPCMoby::Empty, ::GRPCMoby::Empty>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>*>(
          ::grpc::Service::experimental().GetHandler(33))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RTLoggerSave() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RTLoggerSave(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RTLoggerSave(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_GetMobyTxData<ExperimentalWithCallbackMethod_GetMobyRxData<ExperimentalWithCallbackMethod_GetMobyState<ExperimentalWithCallbackMethod_GetMobyErrorState<ExperimentalWithCallbackMethod_Recover<ExperimentalWithCallbackMethod_GetMobyPose<ExperimentalWithCallbackMethod_GetMobyVel<ExperimentalWithCallbackMethod_ResetMobyPose<ExperimentalWithCallbackMethod_GetRotationAngleDeg<ExperimentalWithCallbackMethod_GetDriveSpeed<ExperimentalWithCallbackMethod_GetTargetVel<ExperimentalWithCallbackMethod_GetRotationZeroCount<ExperimentalWithCallbackMethod_GetCMode<ExperimentalWithCallbackMethod_GetGyroData<ExperimentalWithCallbackMethod_ResetGyroSensor<ExperimentalWithCallbackMethod_UseGyroForOdom<ExperimentalWithCallbackMethod_GetGyroFullData<ExperimentalWithCallbackMethod_GetIRSensorData<ExperimentalWithCallbackMethod_GetBMSData<ExperimentalWithCallbackMethod_SetStepControl<ExperimentalWithCallbackMethod_StopMotion<ExperimentalWithCallbackMethod_SetRotationAngleDeg<ExperimentalWithCallbackMethod_DriveWheel<ExperimentalWithCallbackMethod_SetZeroPosAsCurrentPos<ExperimentalWithCallbackMethod_SetRotationVelAcc<ExperimentalWithCallbackMethod_SetDriveAccDec<ExperimentalWithCallbackMethod_SetDriveInterpolatorOnOff<ExperimentalWithCallbackMethod_SetRotationInterpolatorParam<ExperimentalWithCallbackMethod_SetRotationTorqueMode<ExperimentalWithCallbackMethod_SetControlParam<ExperimentalWithCallbackMethod_StartRTLogging<ExperimentalWithCallbackMethod_EndRTLogging<ExperimentalWithCallbackMethod_SetLoggerBuffer<ExperimentalWithCallbackMethod_RTLoggerSave<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetMobyTxData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMobyTxData() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetMobyTxData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyTxData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVal* /*request*/, ::GRPCMoby::MotorDriverTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMobyRxData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMobyRxData() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetMobyRxData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyRxData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVal* /*request*/, ::GRPCMoby::MotorDriverRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMobyState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMobyState() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetMobyState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyState(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMobyErrorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMobyErrorState() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetMobyErrorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyErrorState(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyErrorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Recover() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMobyPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMobyPose() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetMobyPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyPose(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyPose* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMobyVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMobyVel() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetMobyVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyVel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyVel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResetMobyPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResetMobyPose() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_ResetMobyPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetMobyPose(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRotationAngleDeg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRotationAngleDeg() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_GetRotationAngleDeg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::SwerveDoubles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDriveSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDriveSpeed() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetDriveSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDriveSpeed(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::SwerveDoubles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTargetVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTargetVel() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetTargetVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTargetVel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::TargetVel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRotationZeroCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRotationZeroCount() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetRotationZeroCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRotationZeroCount(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::ZeroCount* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCMode() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetCMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCMode(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGyroData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGyroData() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_GetGyroData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGyroData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::DoubleVals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResetGyroSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResetGyroSensor() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_ResetGyroSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetGyroSensor(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UseGyroForOdom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UseGyroForOdom() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_UseGyroForOdom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UseGyroForOdom(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGyroFullData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGyroFullData() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_GetGyroFullData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGyroFullData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IMUData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetIRSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetIRSensorData() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_GetIRSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIRSensorData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IRData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBMSData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBMSData() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_GetBMSData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBMSData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::BMSData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetStepControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetStepControl() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_SetStepControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStepControl(::grpc::ServerContext* /*context*/, const ::GRPCMoby::TargetVel* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopMotion() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRotationAngleDeg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetRotationAngleDeg() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_SetRotationAngleDeg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::GRPCMoby::SwerveDoubles* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DriveWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DriveWheel() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_DriveWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DriveWheel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::SwerveDoubles* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetZeroPosAsCurrentPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetZeroPosAsCurrentPos() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_SetZeroPosAsCurrentPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetZeroPosAsCurrentPos(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRotationVelAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetRotationVelAcc() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_SetRotationVelAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationVelAcc(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetDriveAccDec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetDriveAccDec() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_SetDriveAccDec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDriveAccDec(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetDriveInterpolatorOnOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetDriveInterpolatorOnOff() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_SetDriveInterpolatorOnOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDriveInterpolatorOnOff(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRotationInterpolatorParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetRotationInterpolatorParam() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_SetRotationInterpolatorParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationInterpolatorParam(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRotationTorqueMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetRotationTorqueMode() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_SetRotationTorqueMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationTorqueMode(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetControlParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetControlParam() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_SetControlParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetControlParam(::grpc::ServerContext* /*context*/, const ::GRPCMoby::RotationGain* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartRTLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartRTLogging() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_StartRTLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRTLogging(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EndRTLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EndRTLogging() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_EndRTLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EndRTLogging(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetLoggerBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetLoggerBuffer() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_SetLoggerBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLoggerBuffer(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RTLoggerSave : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RTLoggerSave() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_RTLoggerSave() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RTLoggerSave(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMobyTxData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMobyTxData() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetMobyTxData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyTxData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVal* /*request*/, ::GRPCMoby::MotorDriverTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMobyTxData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMobyRxData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMobyRxData() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetMobyRxData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyRxData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVal* /*request*/, ::GRPCMoby::MotorDriverRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMobyRxData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMobyState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMobyState() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetMobyState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyState(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMobyState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMobyErrorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMobyErrorState() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetMobyErrorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyErrorState(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyErrorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMobyErrorState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Recover() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecover(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMobyPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMobyPose() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetMobyPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyPose(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyPose* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMobyPose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMobyVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMobyVel() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetMobyVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyVel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyVel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMobyVel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResetMobyPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResetMobyPose() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_ResetMobyPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetMobyPose(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetMobyPose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRotationAngleDeg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRotationAngleDeg() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_GetRotationAngleDeg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::SwerveDoubles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRotationAngleDeg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDriveSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDriveSpeed() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetDriveSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDriveSpeed(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::SwerveDoubles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDriveSpeed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTargetVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTargetVel() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetTargetVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTargetVel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::TargetVel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTargetVel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRotationZeroCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRotationZeroCount() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetRotationZeroCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRotationZeroCount(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::ZeroCount* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRotationZeroCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCMode() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_GetCMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCMode(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGyroData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGyroData() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_GetGyroData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGyroData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::DoubleVals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGyroData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResetGyroSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResetGyroSensor() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_ResetGyroSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetGyroSensor(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetGyroSensor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UseGyroForOdom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UseGyroForOdom() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_UseGyroForOdom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UseGyroForOdom(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUseGyroForOdom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGyroFullData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGyroFullData() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_GetGyroFullData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGyroFullData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IMUData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGyroFullData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetIRSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetIRSensorData() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_GetIRSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIRSensorData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IRData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIRSensorData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBMSData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBMSData() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_GetBMSData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBMSData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::BMSData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBMSData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetStepControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetStepControl() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_SetStepControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStepControl(::grpc::ServerContext* /*context*/, const ::GRPCMoby::TargetVel* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetStepControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopMotion() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopMotion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRotationAngleDeg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetRotationAngleDeg() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_SetRotationAngleDeg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::GRPCMoby::SwerveDoubles* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRotationAngleDeg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DriveWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DriveWheel() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_DriveWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DriveWheel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::SwerveDoubles* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDriveWheel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetZeroPosAsCurrentPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetZeroPosAsCurrentPos() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_SetZeroPosAsCurrentPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetZeroPosAsCurrentPos(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetZeroPosAsCurrentPos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRotationVelAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetRotationVelAcc() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_SetRotationVelAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationVelAcc(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRotationVelAcc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetDriveAccDec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetDriveAccDec() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_SetDriveAccDec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDriveAccDec(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDriveAccDec(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetDriveInterpolatorOnOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetDriveInterpolatorOnOff() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_SetDriveInterpolatorOnOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDriveInterpolatorOnOff(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDriveInterpolatorOnOff(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRotationInterpolatorParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetRotationInterpolatorParam() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_SetRotationInterpolatorParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationInterpolatorParam(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRotationInterpolatorParam(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRotationTorqueMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetRotationTorqueMode() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_SetRotationTorqueMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationTorqueMode(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRotationTorqueMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetControlParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetControlParam() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_SetControlParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetControlParam(::grpc::ServerContext* /*context*/, const ::GRPCMoby::RotationGain* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetControlParam(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartRTLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartRTLogging() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_StartRTLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRTLogging(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRTLogging(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EndRTLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EndRTLogging() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_EndRTLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EndRTLogging(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEndRTLogging(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetLoggerBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetLoggerBuffer() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_SetLoggerBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLoggerBuffer(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetLoggerBuffer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RTLoggerSave : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RTLoggerSave() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_RTLoggerSave() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RTLoggerSave(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRTLoggerSave(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetMobyTxData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetMobyTxData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetMobyTxData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetMobyTxData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyTxData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVal* /*request*/, ::GRPCMoby::MotorDriverTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMobyTxData(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetMobyRxData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetMobyRxData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetMobyRxData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetMobyRxData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyRxData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVal* /*request*/, ::GRPCMoby::MotorDriverRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMobyRxData(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetMobyState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetMobyState() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetMobyState(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetMobyState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyState(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMobyState(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetMobyErrorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetMobyErrorState() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetMobyErrorState(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetMobyErrorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyErrorState(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyErrorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMobyErrorState(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Recover() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Recover(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Recover(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetMobyPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetMobyPose() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetMobyPose(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetMobyPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyPose(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyPose* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMobyPose(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetMobyVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetMobyVel() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetMobyVel(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetMobyVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMobyVel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyVel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMobyVel(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ResetMobyPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ResetMobyPose() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ResetMobyPose(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ResetMobyPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetMobyPose(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ResetMobyPose(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRotationAngleDeg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRotationAngleDeg() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetRotationAngleDeg(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRotationAngleDeg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::SwerveDoubles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetDriveSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetDriveSpeed() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetDriveSpeed(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetDriveSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDriveSpeed(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::SwerveDoubles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetDriveSpeed(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTargetVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTargetVel() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetTargetVel(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTargetVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTargetVel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::TargetVel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetTargetVel(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRotationZeroCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRotationZeroCount() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetRotationZeroCount(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRotationZeroCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRotationZeroCount(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::ZeroCount* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRotationZeroCount(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCMode() {
      ::grpc::Service::experimental().MarkMethodRawCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetCMode(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCMode(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCMode(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetGyroData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetGyroData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetGyroData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetGyroData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGyroData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::DoubleVals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetGyroData(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ResetGyroSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ResetGyroSensor() {
      ::grpc::Service::experimental().MarkMethodRawCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ResetGyroSensor(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ResetGyroSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetGyroSensor(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ResetGyroSensor(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UseGyroForOdom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UseGyroForOdom() {
      ::grpc::Service::experimental().MarkMethodRawCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UseGyroForOdom(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UseGyroForOdom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UseGyroForOdom(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UseGyroForOdom(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetGyroFullData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetGyroFullData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetGyroFullData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetGyroFullData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGyroFullData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IMUData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetGyroFullData(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetIRSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetIRSensorData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetIRSensorData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetIRSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIRSensorData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IRData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetIRSensorData(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBMSData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBMSData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(18,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetBMSData(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBMSData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBMSData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::BMSData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetBMSData(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetStepControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetStepControl() {
      ::grpc::Service::experimental().MarkMethodRawCallback(19,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetStepControl(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetStepControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStepControl(::grpc::ServerContext* /*context*/, const ::GRPCMoby::TargetVel* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetStepControl(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StopMotion() {
      ::grpc::Service::experimental().MarkMethodRawCallback(20,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StopMotion(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopMotion(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetRotationAngleDeg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetRotationAngleDeg() {
      ::grpc::Service::experimental().MarkMethodRawCallback(21,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetRotationAngleDeg(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetRotationAngleDeg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::GRPCMoby::SwerveDoubles* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DriveWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DriveWheel() {
      ::grpc::Service::experimental().MarkMethodRawCallback(22,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->DriveWheel(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_DriveWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DriveWheel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::SwerveDoubles* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DriveWheel(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetZeroPosAsCurrentPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetZeroPosAsCurrentPos() {
      ::grpc::Service::experimental().MarkMethodRawCallback(23,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetZeroPosAsCurrentPos(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetZeroPosAsCurrentPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetZeroPosAsCurrentPos(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetZeroPosAsCurrentPos(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetRotationVelAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetRotationVelAcc() {
      ::grpc::Service::experimental().MarkMethodRawCallback(24,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetRotationVelAcc(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetRotationVelAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationVelAcc(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRotationVelAcc(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetDriveAccDec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetDriveAccDec() {
      ::grpc::Service::experimental().MarkMethodRawCallback(25,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetDriveAccDec(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetDriveAccDec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDriveAccDec(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetDriveAccDec(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetDriveInterpolatorOnOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetDriveInterpolatorOnOff() {
      ::grpc::Service::experimental().MarkMethodRawCallback(26,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetDriveInterpolatorOnOff(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetDriveInterpolatorOnOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDriveInterpolatorOnOff(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetDriveInterpolatorOnOff(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetRotationInterpolatorParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetRotationInterpolatorParam() {
      ::grpc::Service::experimental().MarkMethodRawCallback(27,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetRotationInterpolatorParam(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetRotationInterpolatorParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationInterpolatorParam(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRotationInterpolatorParam(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetRotationTorqueMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetRotationTorqueMode() {
      ::grpc::Service::experimental().MarkMethodRawCallback(28,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetRotationTorqueMode(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetRotationTorqueMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRotationTorqueMode(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetRotationTorqueMode(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetControlParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetControlParam() {
      ::grpc::Service::experimental().MarkMethodRawCallback(29,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetControlParam(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetControlParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetControlParam(::grpc::ServerContext* /*context*/, const ::GRPCMoby::RotationGain* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetControlParam(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartRTLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StartRTLogging() {
      ::grpc::Service::experimental().MarkMethodRawCallback(30,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StartRTLogging(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StartRTLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRTLogging(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StartRTLogging(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EndRTLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EndRTLogging() {
      ::grpc::Service::experimental().MarkMethodRawCallback(31,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->EndRTLogging(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_EndRTLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EndRTLogging(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void EndRTLogging(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetLoggerBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetLoggerBuffer() {
      ::grpc::Service::experimental().MarkMethodRawCallback(32,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetLoggerBuffer(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetLoggerBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLoggerBuffer(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetLoggerBuffer(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RTLoggerSave : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RTLoggerSave() {
      ::grpc::Service::experimental().MarkMethodRawCallback(33,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->RTLoggerSave(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_RTLoggerSave() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RTLoggerSave(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RTLoggerSave(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMobyTxData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMobyTxData() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::IntVal, ::GRPCMoby::MotorDriverTx>(std::bind(&WithStreamedUnaryMethod_GetMobyTxData<BaseClass>::StreamedGetMobyTxData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetMobyTxData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMobyTxData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVal* /*request*/, ::GRPCMoby::MotorDriverTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMobyTxData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::IntVal,::GRPCMoby::MotorDriverTx>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMobyRxData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMobyRxData() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::IntVal, ::GRPCMoby::MotorDriverRx>(std::bind(&WithStreamedUnaryMethod_GetMobyRxData<BaseClass>::StreamedGetMobyRxData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetMobyRxData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMobyRxData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVal* /*request*/, ::GRPCMoby::MotorDriverRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMobyRxData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::IntVal,::GRPCMoby::MotorDriverRx>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMobyState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMobyState() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::MobyState>(std::bind(&WithStreamedUnaryMethod_GetMobyState<BaseClass>::StreamedGetMobyState, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetMobyState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMobyState(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMobyState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::MobyState>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMobyErrorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMobyErrorState() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::MobyErrorState>(std::bind(&WithStreamedUnaryMethod_GetMobyErrorState<BaseClass>::StreamedGetMobyErrorState, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetMobyErrorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMobyErrorState(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyErrorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMobyErrorState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::MobyErrorState>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Recover() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_Recover<BaseClass>::StreamedRecover, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRecover(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMobyPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMobyPose() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::MobyPose>(std::bind(&WithStreamedUnaryMethod_GetMobyPose<BaseClass>::StreamedGetMobyPose, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetMobyPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMobyPose(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyPose* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMobyPose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::MobyPose>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMobyVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMobyVel() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::MobyVel>(std::bind(&WithStreamedUnaryMethod_GetMobyVel<BaseClass>::StreamedGetMobyVel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetMobyVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMobyVel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::MobyVel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMobyVel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::MobyVel>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetMobyPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResetMobyPose() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_ResetMobyPose<BaseClass>::StreamedResetMobyPose, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ResetMobyPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetMobyPose(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetMobyPose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRotationAngleDeg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRotationAngleDeg() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::SwerveDoubles>(std::bind(&WithStreamedUnaryMethod_GetRotationAngleDeg<BaseClass>::StreamedGetRotationAngleDeg, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetRotationAngleDeg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::SwerveDoubles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRotationAngleDeg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::SwerveDoubles>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDriveSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDriveSpeed() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::SwerveDoubles>(std::bind(&WithStreamedUnaryMethod_GetDriveSpeed<BaseClass>::StreamedGetDriveSpeed, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetDriveSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDriveSpeed(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::SwerveDoubles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDriveSpeed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::SwerveDoubles>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTargetVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTargetVel() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::TargetVel>(std::bind(&WithStreamedUnaryMethod_GetTargetVel<BaseClass>::StreamedGetTargetVel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetTargetVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTargetVel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::TargetVel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTargetVel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::TargetVel>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRotationZeroCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRotationZeroCount() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::ZeroCount>(std::bind(&WithStreamedUnaryMethod_GetRotationZeroCount<BaseClass>::StreamedGetRotationZeroCount, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetRotationZeroCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRotationZeroCount(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::ZeroCount* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRotationZeroCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::ZeroCount>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCMode() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::IntVal>(std::bind(&WithStreamedUnaryMethod_GetCMode<BaseClass>::StreamedGetCMode, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetCMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCMode(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::IntVal>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetGyroData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetGyroData() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::DoubleVals>(std::bind(&WithStreamedUnaryMethod_GetGyroData<BaseClass>::StreamedGetGyroData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetGyroData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGyroData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::DoubleVals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetGyroData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::DoubleVals>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetGyroSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResetGyroSensor() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_ResetGyroSensor<BaseClass>::StreamedResetGyroSensor, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ResetGyroSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetGyroSensor(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetGyroSensor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UseGyroForOdom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UseGyroForOdom() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::BoolVal, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_UseGyroForOdom<BaseClass>::StreamedUseGyroForOdom, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UseGyroForOdom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UseGyroForOdom(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUseGyroForOdom(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::BoolVal,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetGyroFullData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetGyroFullData() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::IMUData>(std::bind(&WithStreamedUnaryMethod_GetGyroFullData<BaseClass>::StreamedGetGyroFullData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetGyroFullData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGyroFullData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IMUData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetGyroFullData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::IMUData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetIRSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetIRSensorData() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::IRData>(std::bind(&WithStreamedUnaryMethod_GetIRSensorData<BaseClass>::StreamedGetIRSensorData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetIRSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetIRSensorData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::IRData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetIRSensorData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::IRData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBMSData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBMSData() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::BMSData>(std::bind(&WithStreamedUnaryMethod_GetBMSData<BaseClass>::StreamedGetBMSData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetBMSData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBMSData(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::BMSData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBMSData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::BMSData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetStepControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetStepControl() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::TargetVel, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_SetStepControl<BaseClass>::StreamedSetStepControl, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetStepControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetStepControl(::grpc::ServerContext* /*context*/, const ::GRPCMoby::TargetVel* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetStepControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::TargetVel,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopMotion() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_StopMotion<BaseClass>::StreamedStopMotion, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopMotion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRotationAngleDeg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetRotationAngleDeg() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::SwerveDoubles, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_SetRotationAngleDeg<BaseClass>::StreamedSetRotationAngleDeg, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetRotationAngleDeg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRotationAngleDeg(::grpc::ServerContext* /*context*/, const ::GRPCMoby::SwerveDoubles* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRotationAngleDeg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::SwerveDoubles,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DriveWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DriveWheel() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::SwerveDoubles, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_DriveWheel<BaseClass>::StreamedDriveWheel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DriveWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DriveWheel(::grpc::ServerContext* /*context*/, const ::GRPCMoby::SwerveDoubles* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDriveWheel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::SwerveDoubles,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetZeroPosAsCurrentPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetZeroPosAsCurrentPos() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_SetZeroPosAsCurrentPos<BaseClass>::StreamedSetZeroPosAsCurrentPos, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetZeroPosAsCurrentPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetZeroPosAsCurrentPos(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetZeroPosAsCurrentPos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRotationVelAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetRotationVelAcc() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::DoubleVals, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_SetRotationVelAcc<BaseClass>::StreamedSetRotationVelAcc, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetRotationVelAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRotationVelAcc(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRotationVelAcc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::DoubleVals,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetDriveAccDec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetDriveAccDec() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::DoubleVals, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_SetDriveAccDec<BaseClass>::StreamedSetDriveAccDec, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetDriveAccDec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetDriveAccDec(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetDriveAccDec(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::DoubleVals,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetDriveInterpolatorOnOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetDriveInterpolatorOnOff() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::BoolVal, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_SetDriveInterpolatorOnOff<BaseClass>::StreamedSetDriveInterpolatorOnOff, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetDriveInterpolatorOnOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetDriveInterpolatorOnOff(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetDriveInterpolatorOnOff(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::BoolVal,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRotationInterpolatorParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetRotationInterpolatorParam() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::DoubleVals, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_SetRotationInterpolatorParam<BaseClass>::StreamedSetRotationInterpolatorParam, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetRotationInterpolatorParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRotationInterpolatorParam(::grpc::ServerContext* /*context*/, const ::GRPCMoby::DoubleVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRotationInterpolatorParam(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::DoubleVals,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRotationTorqueMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetRotationTorqueMode() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::BoolVal, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_SetRotationTorqueMode<BaseClass>::StreamedSetRotationTorqueMode, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetRotationTorqueMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRotationTorqueMode(::grpc::ServerContext* /*context*/, const ::GRPCMoby::BoolVal* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRotationTorqueMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::BoolVal,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetControlParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetControlParam() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::RotationGain, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_SetControlParam<BaseClass>::StreamedSetControlParam, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetControlParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetControlParam(::grpc::ServerContext* /*context*/, const ::GRPCMoby::RotationGain* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetControlParam(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::RotationGain,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartRTLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartRTLogging() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_StartRTLogging<BaseClass>::StreamedStartRTLogging, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StartRTLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartRTLogging(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartRTLogging(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EndRTLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EndRTLogging() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_EndRTLogging<BaseClass>::StreamedEndRTLogging, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_EndRTLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EndRTLogging(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEndRTLogging(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetLoggerBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetLoggerBuffer() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::IntVals, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_SetLoggerBuffer<BaseClass>::StreamedSetLoggerBuffer, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetLoggerBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetLoggerBuffer(::grpc::ServerContext* /*context*/, const ::GRPCMoby::IntVals* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetLoggerBuffer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::IntVals,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RTLoggerSave : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RTLoggerSave() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler< ::GRPCMoby::Empty, ::GRPCMoby::Empty>(std::bind(&WithStreamedUnaryMethod_RTLoggerSave<BaseClass>::StreamedRTLoggerSave, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RTLoggerSave() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RTLoggerSave(::grpc::ServerContext* /*context*/, const ::GRPCMoby::Empty* /*request*/, ::GRPCMoby::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRTLoggerSave(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GRPCMoby::Empty,::GRPCMoby::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetMobyTxData<WithStreamedUnaryMethod_GetMobyRxData<WithStreamedUnaryMethod_GetMobyState<WithStreamedUnaryMethod_GetMobyErrorState<WithStreamedUnaryMethod_Recover<WithStreamedUnaryMethod_GetMobyPose<WithStreamedUnaryMethod_GetMobyVel<WithStreamedUnaryMethod_ResetMobyPose<WithStreamedUnaryMethod_GetRotationAngleDeg<WithStreamedUnaryMethod_GetDriveSpeed<WithStreamedUnaryMethod_GetTargetVel<WithStreamedUnaryMethod_GetRotationZeroCount<WithStreamedUnaryMethod_GetCMode<WithStreamedUnaryMethod_GetGyroData<WithStreamedUnaryMethod_ResetGyroSensor<WithStreamedUnaryMethod_UseGyroForOdom<WithStreamedUnaryMethod_GetGyroFullData<WithStreamedUnaryMethod_GetIRSensorData<WithStreamedUnaryMethod_GetBMSData<WithStreamedUnaryMethod_SetStepControl<WithStreamedUnaryMethod_StopMotion<WithStreamedUnaryMethod_SetRotationAngleDeg<WithStreamedUnaryMethod_DriveWheel<WithStreamedUnaryMethod_SetZeroPosAsCurrentPos<WithStreamedUnaryMethod_SetRotationVelAcc<WithStreamedUnaryMethod_SetDriveAccDec<WithStreamedUnaryMethod_SetDriveInterpolatorOnOff<WithStreamedUnaryMethod_SetRotationInterpolatorParam<WithStreamedUnaryMethod_SetRotationTorqueMode<WithStreamedUnaryMethod_SetControlParam<WithStreamedUnaryMethod_StartRTLogging<WithStreamedUnaryMethod_EndRTLogging<WithStreamedUnaryMethod_SetLoggerBuffer<WithStreamedUnaryMethod_RTLoggerSave<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetMobyTxData<WithStreamedUnaryMethod_GetMobyRxData<WithStreamedUnaryMethod_GetMobyState<WithStreamedUnaryMethod_GetMobyErrorState<WithStreamedUnaryMethod_Recover<WithStreamedUnaryMethod_GetMobyPose<WithStreamedUnaryMethod_GetMobyVel<WithStreamedUnaryMethod_ResetMobyPose<WithStreamedUnaryMethod_GetRotationAngleDeg<WithStreamedUnaryMethod_GetDriveSpeed<WithStreamedUnaryMethod_GetTargetVel<WithStreamedUnaryMethod_GetRotationZeroCount<WithStreamedUnaryMethod_GetCMode<WithStreamedUnaryMethod_GetGyroData<WithStreamedUnaryMethod_ResetGyroSensor<WithStreamedUnaryMethod_UseGyroForOdom<WithStreamedUnaryMethod_GetGyroFullData<WithStreamedUnaryMethod_GetIRSensorData<WithStreamedUnaryMethod_GetBMSData<WithStreamedUnaryMethod_SetStepControl<WithStreamedUnaryMethod_StopMotion<WithStreamedUnaryMethod_SetRotationAngleDeg<WithStreamedUnaryMethod_DriveWheel<WithStreamedUnaryMethod_SetZeroPosAsCurrentPos<WithStreamedUnaryMethod_SetRotationVelAcc<WithStreamedUnaryMethod_SetDriveAccDec<WithStreamedUnaryMethod_SetDriveInterpolatorOnOff<WithStreamedUnaryMethod_SetRotationInterpolatorParam<WithStreamedUnaryMethod_SetRotationTorqueMode<WithStreamedUnaryMethod_SetControlParam<WithStreamedUnaryMethod_StartRTLogging<WithStreamedUnaryMethod_EndRTLogging<WithStreamedUnaryMethod_SetLoggerBuffer<WithStreamedUnaryMethod_RTLoggerSave<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace GRPCMoby


#endif  // GRPC_MobygRPCServer_2eproto__INCLUDED
